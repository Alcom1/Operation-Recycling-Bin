{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\engine\\modules\\tag.ts"],
  "sourcesContent": ["import GameObject from \"engine/gameobjects/gameobject\";\r\n\r\ninterface Tag {\r\n    tag: string;\r\n    tagObjects: GameObject[];\r\n}\r\n\r\ninterface TaggedScene {\r\n    name: string;\r\n    tags: Tag[];\r\n}\r\n\r\n/** Module that handles tags and game objects grouped by tag. */\r\nexport default class TagModule {\r\n    private scenes: TaggedScene[] = [];\r\n\r\n    /** Return true if a scene by name exists in the scene. */\r\n    public exists(sceneName: string): boolean {\r\n        return this.scenes.some(s => s.name == sceneName);\r\n    }\r\n\r\n    /** Push a game object to the scene */\r\n    public pushGO(gameObject: GameObject, sceneName: string): void {\r\n        // Get scene with name\r\n        var curr = this.scenes.find(sg => sg.name == sceneName );\r\n\r\n        // Store new scene or push gameObject to existing scene  \r\n        if(curr == null) {\r\n            this.scenes.push({\r\n                name : sceneName,\r\n                tags : [{\r\n                    tag : gameObject.tag,\r\n                    tagObjects : [gameObject]\r\n                }]\r\n            });\r\n        }\r\n        else {\r\n            this.pushGOToGroup(gameObject, curr.tags);\r\n        }\r\n    }\r\n\r\n    /** Push a game object to the tag */\r\n    private pushGOToGroup(gameObject: GameObject, tags: Tag[]): void {\r\n        // Get tag with game object's name\r\n        var curr = tags.find(gos => gos.tag == gameObject.tag);\r\n\r\n        // Store new tag or push gameObject to existing tag\r\n        if (curr == null) {\r\n            tags.push({\r\n                tag : gameObject.tag,\r\n                tagObjects : [gameObject]\r\n            });\r\n        } else {\r\n            curr.tagObjects.push(gameObject);\r\n        }\r\n    }\r\n\r\n    /** Returns all game objects for the given tag and scene name */\r\n    public get(tag: string, sceneName: string): GameObject[] {\r\n        return this.scenes.find(\r\n            sg => sg.name == sceneName\r\n        )?.tags.find(\r\n            gos => gos.tag == tag\r\n        )?.tagObjects || [];\r\n    }\r\n\r\n    /** Remove scenes with names in the provided list */\r\n    public clear(sceneNames: string[]) {\r\n        this.scenes = this.scenes.filter(sg => !sceneNames.some(sn => sg.name == sn));\r\n    }\r\n}\r\n"],
  "mappings": "AAAA;AAAA;AAcY,kBAAwB;AAAA;AAAA,EAGzB,OAAO;AACV,WAAO,KAAK,OAAO,KAAK,OAAK,EAAE,QAAQ;AAAA;AAAA,EAIpC;AAEH,eAAW,KAAK,OAAO,KAAK,QAAM,GAAG,QAAQ;AAG7C,QAAG,QAAQ;AACP,WAAK,OAAO,KAAK;AAAA,QACb,MAAO;AAAA,QACP,MAAO,CAAC;AAAA,UACJ,KAAM,WAAW;AAAA,UACjB,YAAa,CAAC;AAAA;AAAA;AAAA;AAKtB,WAAK,cAAc,YAAY,KAAK;AAAA;AAAA;AAAA,EAKpC;AAEJ,eAAW,KAAK,KAAK,SAAO,IAAI,OAAO,WAAW;AAGlD,QAAI,QAAQ;AACR,WAAK,KAAK;AAAA,QACN,KAAM,WAAW;AAAA,QACjB,YAAa,CAAC;AAAA;AAAA;AAGlB,WAAK,WAAW,KAAK;AAAA;AAAA;AAAA,EAKtB;AACH,WAAO,KAAK,OAAO,KACf,QAAM,GAAG,QAAQ,YAClB,KAAK,KACJ,SAAO,IAAI,OAAO,MACnB,cAAc;AAAA;AAAA,EAId;AACH,SAAK,SAAS,KAAK,OAAO,OAAO,QAAM,CAAC,WAAW,KAAK,QAAM,GAAG,QAAQ;AAAA;AAAA;",
  "names": []
}
