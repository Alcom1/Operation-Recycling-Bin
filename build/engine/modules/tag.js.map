{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\engine\\modules\\tag.ts"],
  "sourcesContent": ["import GameObject from \"engine/gameobjects/gameobject\";\r\n\r\ninterface TagGroup {\r\n    tag: string;\r\n    tagObjects: GameObject[];\r\n}\r\n\r\ninterface TaggedScene {\r\n    name: string;\r\n    tags: TagGroup[];\r\n}\r\n\r\n/** Module that handles tags and game objects grouped by tag. */\r\nexport default class TagModule {\r\n    private scenes: TaggedScene[] = [];\r\n\r\n    /** Return true if a scene by name exists in the scene. */\r\n    public exists(sceneName: string): boolean {\r\n        return this.scenes.some(s => s.name == sceneName);\r\n    }\r\n\r\n    /** Push a game object to the scene */\r\n    public pushGO(gameObject: GameObject, sceneName: string): void {\r\n        // Get scene with name\r\n        var curr = this.scenes.find(sg => sg.name == sceneName );\r\n\r\n        // Store new scene or push gameObject to existing scene  \r\n        if(curr == null) {\r\n            gameObject.tags.forEach(tag => {\r\n                this.scenes.push({\r\n                    name : sceneName,\r\n                    tags : [{\r\n                        tag : tag,\r\n                        tagObjects : [gameObject]\r\n                    }]\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            this.pushGOToGroup(gameObject, curr.tags);\r\n        }\r\n    }\r\n\r\n    /** Push a game object to the tag */\r\n    private pushGOToGroup(gameObject: GameObject, tagGroups: TagGroup[]): void {\r\n        // Get tag with game object's name\r\n        var curr = tagGroups.find(tg => gameObject.tags.some(t => t == tg.tag));\r\n\r\n        // Store new tag or push gameObject to existing tag\r\n        if (curr == null) {\r\n            gameObject.tags.forEach(tag => {\r\n                tagGroups.push({\r\n                    tag : tag,\r\n                    tagObjects : [gameObject]\r\n                });\r\n            });\r\n        } else {\r\n            curr.tagObjects.push(gameObject);\r\n        }\r\n    }\r\n\r\n    /** Returns all game objects for the given tag(s) and scene name */\r\n    public get(tag: string | string[], sceneName: string): GameObject[] {\r\n\r\n        return this.scenes.find(\r\n            sg => sg.name == sceneName\r\n        )?.tags.filter(\r\n            gos => Array.isArray(tag) ? tag.includes(gos.tag) : gos.tag == tag\r\n        )?.flatMap(t => t.tagObjects) ?? [];\r\n    }\r\n\r\n    /** Remove scenes with names in the provided list */\r\n    public clear(sceneNames: string[]) {\r\n        this.scenes = this.scenes.filter(sg => !sceneNames.some(sn => sg.name == sn));\r\n    }\r\n}\r\n"],
  "mappings": "AAAA;AAAA;AAcY,kBAAwB;AAAA;AAAA,EAGzB,OAAO;AACV,WAAO,KAAK,OAAO,KAAK,OAAK,EAAE,QAAQ;AAAA;AAAA,EAIpC;AAEH,eAAW,KAAK,OAAO,KAAK,QAAM,GAAG,QAAQ;AAG7C,QAAG,QAAQ;AACP,iBAAW,KAAK,QAAQ;AACpB,aAAK,OAAO,KAAK;AAAA,UACb,MAAO;AAAA,UACP,MAAO,CAAC;AAAA,YACJ;AAAA,YACA,YAAa,CAAC;AAAA;AAAA;AAAA;AAAA;AAM1B,WAAK,cAAc,YAAY,KAAK;AAAA;AAAA;AAAA,EAKpC;AAEJ,eAAW,UAAU,KAAK,QAAM,WAAW,KAAK,KAAK,OAAK,KAAK,GAAG;AAGlE,QAAI,QAAQ;AACR,iBAAW,KAAK,QAAQ;AACpB,kBAAU,KAAK;AAAA,UACX;AAAA,UACA,YAAa,CAAC;AAAA;AAAA;AAAA;AAItB,WAAK,WAAW,KAAK;AAAA;AAAA;AAAA,EAKtB;AAEH,WAAO,KAAK,OAAO,KACf,QAAM,GAAG,QAAQ,YAClB,KAAK,OACJ,SAAO,MAAM,QAAQ,OAAO,IAAI,SAAS,IAAI,OAAO,IAAI,OAAO,MAChE,QAAQ,OAAK,EAAE,eAAe;AAAA;AAAA,EAI9B;AACH,SAAK,SAAS,KAAK,OAAO,OAAO,QAAM,CAAC,WAAW,KAAK,QAAM,GAAG,QAAQ;AAAA;AAAA;",
  "names": []
}
