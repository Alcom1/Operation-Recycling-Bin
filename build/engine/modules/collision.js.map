{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\engine\\modules\\collision.ts"],
  "sourcesContent": ["import GameObject from \"engine/gameobjects/gameobject\";\r\nimport Scene from \"engine/scene/scene\";\r\nimport { colRectRectCorners, GMULTX, GMULTY } from \"engine/utilities/math\";\r\nimport { Point } from \"engine/utilities/vect\";\r\n\r\nexport interface Collider {\r\n    mask : number,\r\n    min : Point,\r\n    max : Point\r\n}\r\n\r\ninterface GameObjectCollider {\r\n    colliders : Collider[],\r\n    gameObject : GameObject\r\n}\r\n\r\ninterface CollidersScene {\r\n    name: string;\r\n    gameObjects: GameObject[];\r\n    passObjects: GameObject[];  //Passive game objects that don't interact with each other\r\n}\r\n\r\n/** Module that handles tags and game objects grouped by tag. */\r\nexport default class CollisionModule {\r\n\r\n    private scenes : CollidersScene[] = [];\r\n\r\n    public pushGOs(sceneName : string, sceneObjects : GameObject[]) {\r\n\r\n        const gameObjects : GameObject[] = [];\r\n        const passObjects : GameObject[] = [];\r\n\r\n        //Assign all game objects with colliders in this scene as passive or normal.\r\n        sceneObjects.forEach(go => {\r\n\r\n            const colliders = go.getColliders();\r\n            \r\n            gameObjects.push(go);\r\n\r\n            if(colliders.some(c => c.mask == 0)) {\r\n                passObjects.push(go);\r\n            }\r\n        });\r\n\r\n        //Only add scene if it has collidables\r\n        if(gameObjects.length > 0 || passObjects.length > 0) {\r\n\r\n            this.scenes.push({\r\n                name : sceneName,\r\n                gameObjects: gameObjects,\r\n                passObjects: passObjects\r\n            });\r\n        }\r\n    }\r\n\r\n    //Update - check and trigger collisions for all game objects in all scenes\r\n    public update() {\r\n\r\n        //Trigger collisions for each scene. Scenes don't interact with each other.\r\n        this.scenes.forEach(s => {\r\n\r\n            //Get all active game objects with colliders\r\n            const gocs : GameObjectCollider[] = s.gameObjects.filter(go => go.isActive).map(go => {\r\n                return {\r\n                    colliders : go.getColliders(),\r\n                    gameObject : go\r\n                }\r\n            });\r\n\r\n            //Stair loop for collisions\r\n            for(var j = 0; j < gocs.length; j++) {\r\n                for(var i = 0; i < j; i++) {\r\n                    this.compareGOColliders(gocs[i], gocs[j]);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    //Debug Draw\r\n    public draw(ctx : CanvasRenderingContext2D) {\r\n\r\n        ctx.strokeStyle = \"#F00\";\r\n        ctx.lineWidth = 2;\r\n\r\n        this.scenes.forEach(s =>\r\n            s.gameObjects.filter(go => go.isActive).forEach(go =>\r\n                go.getColliders().forEach(c => {\r\n\r\n                    //Color box based on most significant bit\r\n                    ctx.strokeStyle = `hsl(${c.mask.toString(2).length * 48},100%,50%)`\r\n                    ctx.strokeRect(\r\n                        c.min.x * GMULTX + 1,\r\n                        c.min.y * GMULTY - 1,\r\n                        c.max.x * GMULTX - c.min.x * GMULTX,\r\n                        c.max.y * GMULTY - c.min.y * GMULTY\r\n                    )\r\n                })\r\n            )\r\n        );\r\n    }\r\n\r\n    //Get passive colliders that are within the given box\r\n    public collidePassive(min : Point, max : Point) : Collider[] {\r\n\r\n        return this.getPassiveColliders().filter(c => colRectRectCorners(c.min, c.max, min, max))\r\n    }\r\n\r\n    //Get passive colliders (mask == 0)\r\n    private getPassiveColliders() : Collider[] {\r\n\r\n        return this.scenes\r\n            .map(s => s.passObjects)\r\n            .flat()\r\n            .map(go => {\r\n                return go.isActive ? go.getColliders().filter(c => c.mask == 0) : [];\r\n            })\r\n            .flat();\r\n    }\r\n\r\n    //Compare all colliders between two game objects\r\n    private compareGOColliders(goc1 : GameObjectCollider, goc2 : GameObjectCollider) {\r\n        goc1.colliders.forEach(c1 => \r\n        goc2.colliders.forEach(c2 => \r\n            this.compareGOPair(c1, c2, goc1.gameObject, goc2.gameObject)));\r\n    }\r\n\r\n    //Check & resolve collision between two colliders\r\n    private compareGOPair(c1 : Collider, c2 : Collider, g1 : GameObject, g2 : GameObject) {\r\n        if((c1.mask & c2.mask) && this.compareColliders(c1, c2)) {\r\n            g1.resolveCollision(c1.mask & c2.mask);\r\n            g2.resolveCollision(c1.mask & c2.mask);\r\n        }\r\n    }\r\n\r\n    //Compare two colliders, check if they overlap\r\n    private compareColliders(c1 : Collider, c2 : Collider) : boolean {\r\n        return colRectRectCorners(c1.min, c1.max, c2.min, c2.max)\r\n    }\r\n\r\n    //Remove scene reference from colliders\r\n    public clear(sceneNames: string[]) {\r\n        this.scenes = this.scenes.filter(sg => !sceneNames.some(sn => sg.name == sn));\r\n    }\r\n}\r\n"],
  "mappings": "AAEA;AAFA;AAAA;AAyBY,kBAA4B;AAAA;AAAA,EAE7B,QAAQ;AAEX,wBAAmC;AACnC,wBAAmC;AAGnC,iBAAa,QAAQ;AAEjB,wBAAkB,GAAG;AAErB,kBAAY,KAAK;AAEjB,UAAG,UAAU,KAAK,OAAK,EAAE,QAAQ;AAC7B,oBAAY,KAAK;AAAA;AAAA;AAKzB,QAAG,YAAY,SAAS,KAAK,YAAY,SAAS;AAE9C,WAAK,OAAO,KAAK;AAAA,QACb,MAAO;AAAA,QACP;AAAA,QACA;AAAA;AAAA;AAAA;AAAA,EAML;AAGH,SAAK,OAAO,QAAQ;AAGhB,mBAAoC,EAAE,YAAY,OAAO,QAAM,GAAG,UAAU,IAAI;AAC5E,eAAO;AAAA,UACH,WAAY,GAAG;AAAA,UACf,YAAa;AAAA;AAAA;AAKrB,mBAAY,GAAG,IAAI,KAAK,QAAQ;AAC5B,qBAAY,GAAG,IAAI,GAAG;AAClB,eAAK,mBAAmB,KAAK,IAAI,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA,EAO/C;AAEH,QAAI,cAAc;AAClB,QAAI,YAAY;AAEhB,SAAK,OAAO,QAAQ,OAChB,EAAE,YAAY,OAAO,QAAM,GAAG,UAAU,QAAQ,QAC5C,GAAG,eAAe,QAAQ;AAGtB,UAAI,cAAc,OAAO,EAAE,KAAK,SAAS,GAAG,SAAS;AACrD,UAAI,WACA,EAAE,IAAI,IAAI,SAAS,GACnB,EAAE,IAAI,IAAI,SAAS,GACnB,EAAE,IAAI,IAAI,SAAS,EAAE,IAAI,IAAI,QAC7B,EAAE,IAAI,IAAI,SAAS,EAAE,IAAI,IAAI;AAAA;AAAA;AAAA,EAQ1C;AAEH,WAAO,KAAK,sBAAsB,OAAO,OAAK,mBAAmB,EAAE,KAAK,EAAE,KAAK,KAAK;AAAA;AAAA,EAIhF;AAEJ,WAAO,KAAK,OACP,IAAI,OAAK,EAAE,aACX,OACA,IAAI;AACD,aAAO,GAAG,WAAW,GAAG,eAAe,OAAO,OAAK,EAAE,QAAQ,KAAK;AAAA,OAErE;AAAA;AAAA,EAID;AACJ,SAAK,UAAU,QAAQ,QACvB,KAAK,UAAU,QAAQ,QACnB,KAAK,cAAc,IAAI,IAAI,KAAK,YAAY,KAAK;AAAA;AAAA,EAIjD;AACJ,QAAI,GAAG,OAAO,GAAG,QAAS,KAAK,iBAAiB,IAAI;AAChD,SAAG,iBAAiB,GAAG,OAAO,GAAG;AACjC,SAAG,iBAAiB,GAAG,OAAO,GAAG;AAAA;AAAA;AAAA,EAKjC;AACJ,WAAO,mBAAmB,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG;AAAA;AAAA,EAIlD;AACH,SAAK,SAAS,KAAK,OAAO,OAAO,QAAM,CAAC,WAAW,KAAK,QAAM,GAAG,QAAQ;AAAA;AAAA;",
  "names": []
}
