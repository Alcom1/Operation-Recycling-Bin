{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\engine\\modules\\collision.ts"],
  "sourcesContent": ["import GameObject from \"engine/gameobjects/gameobject\";\r\nimport Scene from \"engine/scene/scene\";\r\nimport { colRectRectCorners } from \"engine/utilities/math\";\r\nimport { Point } from \"engine/utilities/vect\";\r\n\r\nexport interface Collider {\r\n    mask : number,\r\n    min : Point,\r\n    max : Point\r\n}\r\n\r\ninterface GameObjectCollider {\r\n    colliders : Collider[],\r\n    gameObject : GameObject\r\n}\r\n\r\ninterface CollidersScene {\r\n    name: string;\r\n    maskMax : number;\r\n    gameObjects: GameObject[];\r\n}\r\n\r\n/** Module that handles tags and game objects grouped by tag. */\r\nexport default class CollisionModule {\r\n\r\n    private scenes : CollidersScene[] = [];\r\n\r\n    public pushGOs(sceneName : string, gameObjects : GameObject[]) {\r\n\r\n        var max = 0;\r\n        const collidables = gameObjects.filter(g => {\r\n            const curr = g.getColliders();\r\n            curr.forEach(c => max = Math.max(max, c.mask));\r\n            return curr.length > 0;\r\n        });\r\n\r\n        this.scenes.push({\r\n            name : sceneName,\r\n            maskMax : max.toString(2).length,\r\n            gameObjects: collidables\r\n        });\r\n    }\r\n\r\n    public update() {\r\n\r\n        this.scenes.forEach(s => {\r\n\r\n            const gocs : GameObjectCollider[] = s.gameObjects.map(go => {\r\n                return {\r\n                    colliders : go.getColliders(),\r\n                    gameObject : go\r\n                }\r\n            });\r\n\r\n            const length = gocs.length;\r\n\r\n            for(var j = 0; j < length; j++) {\r\n                for(var i = 0; i < j; i++) {\r\n                    this.compareGOColliders(gocs[i], gocs[j]);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private compareGOColliders(goc1 : GameObjectCollider, goc2 : GameObjectCollider) {\r\n        goc1.colliders.forEach(c1 => \r\n        goc2.colliders.forEach(c2 => \r\n            this.compareGOPair(c1, c2, goc1.gameObject, goc2.gameObject)));\r\n    }\r\n\r\n    private compareGOPair(c1 : Collider, c2 : Collider, g1 : GameObject, g2 : GameObject) {\r\n        if((c1.mask & c2.mask) && this.compareColliders(c1, c2)) {\r\n            g1.resolveCollision(g2);\r\n            g2.resolveCollision(g1);\r\n        }\r\n    }\r\n\r\n    private compareColliders(c1 : Collider, c2 : Collider) : boolean {\r\n        return colRectRectCorners(c1.min, c1.max, c2.min, c2.max)\r\n    }\r\n\r\n    public clear(sceneNames: string[]) {\r\n        this.scenes = this.scenes.filter(sg => !sceneNames.some(sn => sg.name == sn));\r\n    }\r\n}\r\n"],
  "mappings": "AAEA;AAFA;AAAA;AAyBY,kBAA4B;AAAA;AAAA,EAE7B,QAAQ;AAEX,cAAU;AACV,wBAAoB,YAAY,OAAO;AACnC,mBAAa,EAAE;AACf,WAAK,QAAQ,OAAK,MAAM,KAAK,IAAI,KAAK,EAAE;AACxC,aAAO,KAAK,SAAS;AAAA;AAGzB,SAAK,OAAO,KAAK;AAAA,MACb,MAAO;AAAA,MACP,SAAU,IAAI,SAAS,GAAG;AAAA,MAC1B,aAAa;AAAA;AAAA;AAAA,EAId;AAEH,SAAK,OAAO,QAAQ;AAEhB,mBAAoC,EAAE,YAAY,IAAI;AAClD,eAAO;AAAA,UACH,WAAY,GAAG;AAAA,UACf,YAAa;AAAA;AAAA;AAIrB,qBAAe,KAAK;AAEpB,mBAAY,GAAG,IAAI,QAAQ;AACvB,qBAAY,GAAG,IAAI,GAAG;AAClB,eAAK,mBAAmB,KAAK,IAAI,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA,EAM9C;AACJ,SAAK,UAAU,QAAQ,QACvB,KAAK,UAAU,QAAQ,QACnB,KAAK,cAAc,IAAI,IAAI,KAAK,YAAY,KAAK;AAAA;AAAA,EAGjD;AACJ,QAAI,GAAG,OAAO,GAAG,QAAS,KAAK,iBAAiB,IAAI;AAChD,SAAG,iBAAiB;AACpB,SAAG,iBAAiB;AAAA;AAAA;AAAA,EAIpB;AACJ,WAAO,mBAAmB,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG;AAAA;AAAA,EAGlD;AACH,SAAK,SAAS,KAAK,OAAO,OAAO,QAAM,CAAC,WAAW,KAAK,QAAM,GAAG,QAAQ;AAAA;AAAA;",
  "names": []
}
