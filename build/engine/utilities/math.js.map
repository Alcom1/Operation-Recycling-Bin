{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\engine\\utilities\\math.ts"],
  "sourcesContent": ["// Constants\r\n/** Path to image assets */\r\nexport const PATH_IMG = \"assets/img/\";\r\n/** Horizontal multiplier for grid positions */\r\nexport const GMULTX = 30;\r\n/** Vertical multiplier for grid positions */\r\nexport const GMULTY = 36;\r\n/** Z-index to place objects beneath the cursor */\r\nexport const UNDER_CURSOR_Z_INDEX = 100;\r\n/** Distance to draw depth */\r\nexport const Z_DEPTH = 22;\r\n/** Width of the sidepanel UI */\r\nexport const WIDTH_SIDEPANEL = 234;\r\n/** Array of unit and negative unit for opposed functions */\r\nexport const OPPOSITE_DIRS = [-1, 1] as (-1 | 1)[];\r\n\r\n/** Environment boundary */\r\nexport const BOUNDARY = Object.freeze({\r\n    /** Minimum X-position */\r\n    minx: 0,\r\n    /** Minimum Y-position */\r\n    miny: 2,\r\n    /** Maximum X-position */\r\n    maxx: 35,\r\n    /** Maximum Y-position */\r\n    maxy: 24\r\n});\r\n\r\n/** Handles file extension - image */\r\nexport function pathImg(fileName : string, extension?: string) {\r\n\r\n    return `${PATH_IMG}${fileName}.${extension ?? \"png\"}`;    //Default to png\r\n}\r\n\r\n/** Constrain value between min and max (inclusive) */\r\nexport function clamp(val: number, min: number, max: number): number {\r\n\r\n    return Math.max(min, Math.min(max, val));\r\n}\r\n\r\n/** Round a value to the nearest target */\r\nexport function round(val: number, target: number): number {\r\n    return Math.round(val / target) * target;\r\n}\r\n\r\n/** Collision between a bar and a bounding box but with grid coordinates */\r\nexport function colBorderBoxGrid(x: number, y: number, w: number): boolean {\r\n    return (\r\n        x <          BOUNDARY.minx ||   // Lower horizontal bound\r\n        y <          BOUNDARY.miny ||   // Lower vertical bound\r\n        x + w - 1 >= BOUNDARY.maxx ||   // Upper horiziontal bound with width\r\n        y >=         BOUNDARY.maxy      // Upper vertical bound\r\n    );\r\n}\r\n\r\n/** Point-rectangle collision */\r\nexport function colPointRect(px: number, py: number, rx: number, ry: number, rw: number, rh: number): boolean {\r\n    return (\r\n        px >= rx      &&    // Lower horizontal bound\r\n        py >= ry      &&    // Lower vertical bound\r\n        px <  rx + rw &&    // Upper horizontal bound\r\n        py <  ry + rh       // Upper vertical bound\r\n    );\r\n}\r\n\r\n/** Point-rectangle collision but with grid coordinates */\r\nexport function colPointRectGrid(px: number, py: number, rx: number, ry: number, rw: number): boolean {\r\n    return colPointRect(\r\n        px,            // Point-X\r\n        py,            // Point-y\r\n        rx * GMULTX,   // Rect-x\r\n        ry * GMULTY,   // Rect-y\r\n        rw * GMULTX,   // Rect-width\r\n        GMULTY         // Assume height = 1\r\n    );\r\n}\r\n\r\n/** Point-parallelogram (Horizontal) collision */\r\nexport function colPointParH(px: number, py: number, rx: number, ry: number, rw: number, rh: number): boolean {\r\n    return (\r\n        px >= rx      - py + ry &&  //Horizontal tilt\r\n        py >= ry                &&\r\n        px <  rx + rw - py + ry &&  //Horizontal tilt\r\n        py <  ry + rh\r\n    );\r\n}\r\n\r\n/** Point-parallelogram (Horizontal) collision but with grid coordinates */\r\nexport function colPointParHGrid(px: number, py: number, rx: number, ry: number, rw: number): boolean {\r\n    return colPointParH(\r\n        px,                     //Point-X\r\n        py,                     //Point-y\r\n        rx * GMULTX + Z_DEPTH,  //Para-x\r\n        ry * GMULTY - Z_DEPTH,  //Para-y\r\n        rw * GMULTX,            //Para-width\r\n        Z_DEPTH                 //Para-height\r\n    );\r\n}\r\n\r\n/** Point-parallelogram (Vertical) collision */\r\nexport function colPointParV(px: number, py: number, rx: number, ry: number, rw: number, rh: number): boolean {\r\n    return (\r\n        px >= rx                &&\r\n        py >= ry      - px + rx &&  // Vertical tilt\r\n        px <  rx + rw           &&\r\n        py <  ry + rh - px + rx     // Vertical tilt\r\n    );\r\n}\r\n\r\n/** Point-parallelogram (Vertical) collision but with grid coordinates */\r\nexport function colPointParVGrid(px: number, py: number, rx: number, ry: number, rw: number): boolean {\r\n    return colPointParV(\r\n        px,                         // Point-X\r\n        py,                         // Point-y\r\n        rx * GMULTX + rw * GMULTX,  // Para-x\r\n        ry * GMULTY,                // Para-y\r\n        Z_DEPTH,                    // Para-width\r\n        GMULTY                      // Para-height\r\n    );\r\n}\r\n\r\n/** 1-dimensional collision to check vertical overlap */\r\nexport function col1D(a1: number, a2: number, b1: number, b2: number): boolean {\r\n    // Return if A and B objects overlap\r\n    return a2 > b1 && a1 < b2;\r\n}\r\n\r\n/** Translate text colors to custom values */\r\nexport function colorTranslate(color?: string): string {\r\n    switch (color){\r\n        case undefined: return '#999999'    // No color translates to grey\r\n        case 'white':   return '#EEEEEE'\r\n        case 'blue' :   return '#0033FF'\r\n        case 'yellow':  return '#FFCC00'\r\n        case 'red':     return '#CC0000'\r\n        case 'black':   return '#333344'\r\n        case 'grey':    return '#808080'\r\n        case 'green':   return '#008000'\r\n        default:\r\n            if (color.startsWith('#')) return color;\r\n            else throw new Error(`No color definition available for color '${color}'`);\r\n    }\r\n}\r\n\r\n/** Multiply by a value all channels in a hex color */\r\nexport function colorMult(color: string, value: number): string {\r\n    return colorChange(\r\n        color,             // Color to be modified\r\n        value,             // Value to apply to this color\r\n        (c, v) => c * v    // Multiplicative function\r\n    );\r\n}\r\n\r\n/** Add a value to all channels in a hex color */\r\nexport function colorAdd(color: string, value: number): string {\r\n\r\n    return colorChange(\r\n        color,             // Color to be modified\r\n        value,             // Value to apply to this color\r\n        (c, v) => c + v    // Additive function\r\n    );\r\n}\r\n\r\n/** Modify a color given a value and modifier function */\r\nexport function colorChange(color: string, value: number, func: (color: number, value: number) => number): string {\r\n    // Array of individual color channels\r\n    let channels = [];\r\n    // There are THREE channels.\r\n    for (let i = 0; i < 3; i++) {\r\n        // For each channel, store its digits in the channels\r\n        channels[i] = parseInt(color.substr(2 * i + 1, 2), 16);\r\n    }\r\n\r\n    // Convert to decimal and apply function\r\n    channels = channels.map(c => clamp(Math.round(func(c, value)), 0, 255));\r\n    // Convert back to 2-digit hex\r\n    channels = channels.map(c => (\"0\" + c.toString(16)).substr(-2));\r\n\r\n    // Return recomposed color\r\n    return \"#\" + channels.join('');\r\n}\r\n"],
  "mappings": "AAEO,aAAM,WAAW;AAEjB,sBAAe;AAEf,sBAAe;AAEf,oCAA6B;AAE7B,uBAAgB;AAEhB,+BAAwB;AAExB,6BAAsB,CAAC,IAAI;AAG3B,wBAAiB,OAAO,OAAO;AAAA,EAElC,MAAM;AAAA,EAEN,MAAM;AAAA,EAEN,MAAM;AAAA,EAEN,MAAM;AAAA;AAIH;AAEH,SAAO,GAAG,WAAW,YAAY,aAAa;AAAA;AAI3C;AAEH,SAAO,KAAK,IAAI,KAAK,KAAK,IAAI,KAAK;AAAA;AAIhC;AACH,SAAO,KAAK,MAAM,MAAM,UAAU;AAAA;AAI/B;AACH,SACI,IAAa,SAAS,QACtB,IAAa,SAAS,QACtB,IAAI,IAAI,KAAK,SAAS,QACtB,KAAa,SAAS;AAAA;AAKvB;AACH,SACI,MAAM,MACN,MAAM,MACN,KAAM,KAAK,MACX,KAAM,KAAK;AAAA;AAKZ;AACH,SAAO,aACH,IACA,IACA,KAAK,QACL,KAAK,QACL,KAAK,QACL;AAAA;AAKD;AACH,SACI,MAAM,KAAU,KAAK,MACrB,MAAM,MACN,KAAM,KAAK,KAAK,KAAK,MACrB,KAAM,KAAK;AAAA;AAKZ;AACH,SAAO,aACH,IACA,IACA,KAAK,SAAS,SACd,KAAK,SAAS,SACd,KAAK,QACL;AAAA;AAKD;AACH,SACI,MAAM,MACN,MAAM,KAAU,KAAK,MACrB,KAAM,KAAK,MACX,KAAM,KAAK,KAAK,KAAK;AAAA;AAKtB;AACH,SAAO,aACH,IACA,IACA,KAAK,SAAS,KAAK,QACnB,KAAK,QACL,SACA;AAAA;AAKD;AAEH,SAAO,KAAK,MAAM,KAAK;AAAA;AAIpB;AACH,UAAQ;AAAA,SACC;AAAW,aAAO;AAAA,SAClB;AAAW,aAAO;AAAA,SAClB;AAAW,aAAO;AAAA,SAClB;AAAW,aAAO;AAAA,SAClB;AAAW,aAAO;AAAA,SAClB;AAAW,aAAO;AAAA,SAClB;AAAW,aAAO;AAAA,SAClB;AAAW,aAAO;AAAA;AAEnB,UAAI,MAAM,WAAW;AAAM,eAAO;AAAA;AAC7B,cAAM,IAAI,MAAM,4CAA4C;AAAA;AAAA;AAKtE;AACH,SAAO,YACH,OACA,OACA,UAAU,IAAI;AAAA;AAKf;AAEH,SAAO,YACH,OACA,OACA,UAAU,IAAI;AAAA;AAKf;AAEH,iBAAe;AAEf,eAAa,GAAG,IAAI,GAAG;AAEnB,aAAS,KAAK,SAAS,MAAM,OAAO,IAAI,IAAI,GAAG,IAAI;AAAA;AAIvD,aAAW,SAAS,IAAI,OAAK,MAAM,KAAK,MAAM,KAAK,GAAG,SAAS,GAAG;AAElE,aAAW,SAAS,IAAI,OAAM,OAAM,EAAE,SAAS,KAAK,OAAO;AAG3D,SAAO,MAAM,SAAS,KAAK;AAAA;",
  "names": []
}
