{
  "version": 3,
  "sources": ["/home/jonathan/Development/lego/Operation-Recycling-Bin/src/engine/utilities/math.ts"],
  "sourcesContent": ["// Constants\n/** Horizontal multiplier for grid positions */\nexport const GMULTX = 30;\n/** Vertical multiplier for grid positions */\nexport const GMULTY = 36;\n/** Z-index to place objects beneath the cursor */\nexport const UNDER_CURSOR_Z_INDEX = 100;\n/** Thickness of lines */\nexport const LINE_WIDTH = 2;\n/** Radius of studs */\nexport const STUD_RADIUS = 11;\n/** Height of studs */\nexport const STUD_HEIGHT = 6;\n/** Distance to draw depth */\nexport const Z_DEPTH = 22;\n\n/** Environment boundary */\nexport const BOUNDARY = Object.freeze({\n    /** Minimum X-position */\n    minx: 0,\n    /** Minimum Y-position */\n    miny: 2,\n    /** Maximum X-position */\n    maxx: 35,\n    /** Maximum Y-position */\n    maxy: 24\n});\n\n/** Constrain value between min and max (inclusive) */\nexport function clamp(val: number, min: number, max: number): number {\n\n    return Math.max(min, Math.min(max, val));\n}\n\n/** Round a value to the nearest target */\nexport function round(val: number, target: number): number {\n    return Math.round(val / target) * target;\n}\n\n/** Collision between a bar and a bounding box but with grid coordinates */\nexport function colBorderBoxGrid(x: number, y: number, w: number): boolean {\n    return (\n        x <          BOUNDARY.minx ||   // Lower horizontal bound\n        y <          BOUNDARY.miny ||   // Lower vertical bound\n        x + w - 1 >= BOUNDARY.maxx ||   // Upper horiziontal bound with width\n        y >=         BOUNDARY.maxy      // Upper vertical bound\n    );\n}\n\n/** Point-rectangle collision */\nexport function colPointRect(px: number, py: number, rx: number, ry: number, rw: number, rh: number): boolean {\n    return (\n        px >= rx      &&    // Lower horizontal bound\n        py >= ry      &&    // Lower vertical bound\n        px <  rx + rw &&    // Upper horizontal bound\n        py <  ry + rh       // Upper vertical bound\n    );\n}\n\n/** Point-rectangle collision but with grid coordinates */\nexport function colPointRectGrid(px: number, py: number, rx: number, ry: number, rw: number): boolean {\n    return colPointRect(\n        px,            // Point-X\n        py,            // Point-y\n        rx * GMULTX,   // Rect-x\n        ry * GMULTY,   // Rect-y\n        rw * GMULTX,   // Rect-width\n        GMULTY         // Assume height = 1\n    );\n}\n\n/** Point-parallelogram (Horizontal) collision */\nexport function colPointParH(px: number, py: number, rx: number, ry: number, rw: number, rh: number): boolean {\n    return (\n        px >= rx      - py + ry &&  //Horizontal tilt\n        py >= ry                &&\n        px <  rx + rw - py + ry &&  //Horizontal tilt\n        py <  ry + rh\n    );\n}\n\n/** Point-parallelogram (Horizontal) collision but with grid coordinates */\nexport function colPointParHGrid(px: number, py: number, rx: number, ry: number, rw: number): boolean {\n    return colPointParH(\n        px,                     //Point-X\n        py,                     //Point-y\n        rx * GMULTX + Z_DEPTH,  //Para-x\n        ry * GMULTY - Z_DEPTH,  //Para-y\n        rw * GMULTX,            //Para-width\n        Z_DEPTH                 //Para-height\n    );\n}\n\n/** Point-parallelogram (Vertical) collision */\nexport function colPointParV(px: number, py: number, rx: number, ry: number, rw: number, rh: number): boolean {\n    return (\n        px >= rx                &&\n        py >= ry      - px + rx &&  // Vertical tilt\n        px <  rx + rw           &&\n        py <  ry + rh - px + rx     // Vertical tilt\n    );\n}\n\n/** Point-parallelogram (Vertical) collision but with grid coordinates */\nexport function colPointParVGrid(px: number, py: number, rx: number, ry: number, rw: number): boolean {\n    return colPointParV(\n        px,                         // Point-X\n        py,                         // Point-y\n        rx * GMULTX + rw * GMULTX,  // Para-x\n        ry * GMULTY,                // Para-y\n        Z_DEPTH,                    // Para-width\n        GMULTY                      // Para-height\n    );\n}\n\n/** 1-dimensional collision to check vertical overlap */\nexport function col1D(a1: number, a2: number, b1: number, b2: number): boolean {\n    // Return if A and B objects overlap\n    return a2 > b1 && a1 < b2;\n}\n\n/** Translate text colors to custom values */\nexport function colorTranslate(color?: string): string {\n    switch (color){\n        case undefined: return '#999999'    // No color translates to grey\n        case 'white':   return '#EEEEEE'\n        case 'blue' :   return '#0033FF'\n        case 'yellow':  return '#FFCC00'\n        case 'red':     return '#CC0000'\n        case 'black':   return '#333344'\n        case 'grey':    return '#808080'\n        default:        return color;       // Color unchanged\n    }\n}\n\n/** Multiply by a value all channels in a hex color */\nexport function colorMult(color: string, value: number): string {\n    return colorChange(\n        color,             // Color to be modified\n        value,             // Value to apply to this color\n        (c, v) => c * v    // Multiplicative function\n    );\n}\n\n/** Add a value to all channels in a hex color */\nexport function colorAdd(color: string, value: number): string {\n\n    return colorChange(\n        color,             // Color to be modified\n        value,             // Value to apply to this color\n        (c, v) => c + v    // Additive function\n    );\n}\n\n/** Modify a color given a value and modifier function */\nexport function colorChange(color: string, value: number, func: (color: number, value: number) => number): string {\n    // Array of individual color channels\n    let channels = [];\n    // There are THREE channels.\n    for (let i = 0; i < 3; i++) {\n        // For each channel, store its digits in the channels\n        channels[i] = parseInt(color.substr(2 * i + 1, 2), 16);\n    }\n\n    // Convert to decimal and apply function\n    channels = channels.map(c => clamp(Math.round(func(c, value)), 0, 255));\n    // Convert back to 2-digit hex\n    channels = channels.map(c => (\"0\" + c.toString(16)).substr(-2));\n\n    // Return recomposed color\n    return \"#\" + channels.join('');\n}\n"],
  "mappings": "AAEO,aAAM,SAAS;AAEf,sBAAe;AAEf,oCAA6B;AAE7B,0BAAmB;AAEnB,2BAAoB;AAEpB,2BAAoB;AAEpB,uBAAgB;AAGhB,wBAAiB,OAAO,OAAO;AAAA,EAElC,MAAM;AAAA,EAEN,MAAM;AAAA,EAEN,MAAM;AAAA,EAEN,MAAM;AAAA;AAIH;AAEH,SAAO,KAAK,IAAI,KAAK,KAAK,IAAI,KAAK;AAAA;AAIhC;AACH,SAAO,KAAK,MAAM,MAAM,UAAU;AAAA;AAI/B;AACH,SACI,IAAa,SAAS,QACtB,IAAa,SAAS,QACtB,IAAI,IAAI,KAAK,SAAS,QACtB,KAAa,SAAS;AAAA;AAKvB;AACH,SACI,MAAM,MACN,MAAM,MACN,KAAM,KAAK,MACX,KAAM,KAAK;AAAA;AAKZ;AACH,SAAO,aACH,IACA,IACA,KAAK,QACL,KAAK,QACL,KAAK,QACL;AAAA;AAKD;AACH,SACI,MAAM,KAAU,KAAK,MACrB,MAAM,MACN,KAAM,KAAK,KAAK,KAAK,MACrB,KAAM,KAAK;AAAA;AAKZ;AACH,SAAO,aACH,IACA,IACA,KAAK,SAAS,SACd,KAAK,SAAS,SACd,KAAK,QACL;AAAA;AAKD;AACH,SACI,MAAM,MACN,MAAM,KAAU,KAAK,MACrB,KAAM,KAAK,MACX,KAAM,KAAK,KAAK,KAAK;AAAA;AAKtB;AACH,SAAO,aACH,IACA,IACA,KAAK,SAAS,KAAK,QACnB,KAAK,QACL,SACA;AAAA;AAKD;AAEH,SAAO,KAAK,MAAM,KAAK;AAAA;AAIpB;AACH,UAAQ;AAAA,SACC;AAAW,aAAO;AAAA,SAClB;AAAW,aAAO;AAAA,SAClB;AAAW,aAAO;AAAA,SAClB;AAAW,aAAO;AAAA,SAClB;AAAW,aAAO;AAAA,SAClB;AAAW,aAAO;AAAA,SAClB;AAAW,aAAO;AAAA;AACP,aAAO;AAAA;AAAA;AAKxB;AACH,SAAO,YACH,OACA,OACA,UAAU,IAAI;AAAA;AAKf;AAEH,SAAO,YACH,OACA,OACA,UAAU,IAAI;AAAA;AAKf;AAEH,iBAAe;AAEf,eAAa,GAAG,IAAI,GAAG;AAEnB,aAAS,KAAK,SAAS,MAAM,OAAO,IAAI,IAAI,GAAG,IAAI;AAAA;AAIvD,aAAW,SAAS,IAAI,OAAK,MAAM,KAAK,MAAM,KAAK,GAAG,SAAS,GAAG;AAElE,aAAW,SAAS,IAAI,OAAM,OAAM,EAAE,SAAS,KAAK,OAAO;AAG3D,SAAO,MAAM,SAAS,KAAK;AAAA;",
  "names": []
}
