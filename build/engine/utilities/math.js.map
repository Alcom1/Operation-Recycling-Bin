{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\engine\\utilities\\math.ts"],
  "sourcesContent": ["// Constants\r\n\r\nimport Vect, { Point } from \"./vect\";\r\n\r\n/** Path to image assets */\r\nexport const PATH_IMG = \"assets/img/\";\r\n/** Horizontal multiplier for grid positions */\r\nexport const GMULTX = 30;\r\n/** Vertical multiplier for grid positions */\r\nexport const GMULTY = 36;\r\n/** Distance to draw depth */\r\nexport const Z_DEPTH = 22;\r\n/** Width of the sidepanel UI */\r\nexport const WIDTH_SIDEPANEL = 234;\r\n/** Array of unit and negative unit for opposed functions */\r\nexport const OPPOSITE_DIRS = [-1, 1] as (-1 | 1)[];\r\n/** Maximum size of a mobile preview */\r\nexport const MOBILE_PREVIEW_MAX = new Vect(6, 3);\r\n\r\n/** Faction reference enum */\r\nexport const enum Faction {\r\n    FRIENDLY,\r\n    NEUTRAL,\r\n    HOSTILE\r\n}\r\n\r\n/** Returns true if factions are not opposing */\r\nexport function MatchFactions(a : Faction, b : Faction) : boolean {\r\n    return Math.abs(b - a) < 2;\r\n}\r\n\r\n/** Environment boundary */\r\nexport const BOUNDARY = Object.freeze({\r\n    /** Minimum X-position */\r\n    minx: 0,\r\n    /** Minimum Y-position */\r\n    miny: 2,\r\n    /** Maximum X-position */\r\n    maxx: 35,\r\n    /** Maximum Y-position */\r\n    maxy: 24\r\n});\r\n\r\nexport const MASKS = Object.freeze({\r\n    block: 0b1,\r\n    scrap: 0b10,\r\n    death: 0b100,\r\n    float: 0b1000,\r\n    super: 0b10000,\r\n    water: 0b100000,\r\n    jumps: 0b1000000,\r\n    press: 0b10000000,\r\n    enemy: 0b100000000,\r\n})\r\n\r\n// 4x4 Collision bitmasks\r\n// 0123\r\n// 4  5\r\n// 6  7\r\n// 89AB\r\nexport const RING_BITSTACK = Object.freeze({\r\n    flor : bitStack(9, 10),\r\n    roof : bitStack(1, 2),\r\n    face : bitStack(5, 7),\r\n    back : bitStack(4, 6),\r\n    land : bitStack(11),\r\n    band : bitStack(8)\r\n});\r\n\r\n// 4x5 Collision bitmask with an extra overhang\r\n// 0123\r\n// 4  5\r\n// 6  7\r\n// 89ABC\r\nexport const RING_BITSTACKB = Object.freeze({\r\n    ...RING_BITSTACK,\r\n    hang : RING_BITSTACK.land + bitStack(12)\r\n});\r\n\r\n/** Handles file extension - image */\r\nexport function pathImg(fileName : string, extension?: string) {\r\n\r\n    return `${PATH_IMG}${fileName}.${extension ?? \"png\"}`;    // Default to png\r\n}\r\n\r\n/** Constrain value between min and max (inclusive) */\r\nexport function clamp(val: number, min: number, max: number): number {\r\n    return Math.max(min, Math.min(max, val));\r\n}\r\n\r\n/** Round a value to the nearest target */\r\nexport function round(val: number, target: number): number {\r\n    return Math.round(val / target) * target;\r\n}\r\n\r\n/** Floor a value to the nearest target */\r\nexport function floor(val: number, target: number): number {\r\n    return Math.floor(val / target) * target;\r\n}\r\n\r\n/** Zipper an integer (0, 1, 2, 3) => (-1, 1, -2, 2) or 0 if negative */\r\nexport function zip(val: number) {\r\n    return val >= 0 ? OPPOSITE_DIRS[val % 2] * Math.ceil((val + 1) / 2) : 0\r\n}\r\n\r\n/** Stack an array of integers into a bitmask */\r\nexport function bitStack(...numbers: number[]): number {\r\n\r\n    var ret = 0;\r\n    numbers.forEach(n => ret += 1 << n);\r\n    return ret;\r\n}\r\n\r\n/** Check if a box is inside a bounding box */\r\nexport function colBoundingBoxGrid(min: Point, max: Point): boolean {\r\n    return (\r\n        min.x <  BOUNDARY.minx     ||   // Lower horizontal bound\r\n        min.y <  BOUNDARY.miny     ||   // Lower vertical bound\r\n        max.x >= BOUNDARY.maxx + 1 ||   // Upper horiziontal bound\r\n        max.y >= BOUNDARY.maxy + 1      // Upper vertical bound\r\n    );\r\n}\r\n\r\n/** Point-rectangle collision */\r\nexport function colPointRect(px: number, py: number, rx: number, ry: number, rw: number, rh: number): boolean {\r\n    return (\r\n        px >= rx      &&    // Lower horizontal bound\r\n        py >= ry      &&    // Lower vertical bound\r\n        px <  rx + rw &&    // Upper horizontal bound\r\n        py <  ry + rh       // Upper vertical bound\r\n    );\r\n}\r\n\r\n/** Rectangle-rectangle collision with two size rectangles */\r\nexport function colRectRectSizes(\r\n    apos : Vect,\r\n    adim : Point,\r\n    bpos : Vect,\r\n    bdim : Point) : boolean {\r\n\r\n    return colRectRectCorners(\r\n        apos,\r\n        apos.getAdd(adim),\r\n        bpos,\r\n        bpos.getAdd(bdim))\r\n}\r\n\r\n/** Rectangle-rectangle collision with a corner and size rectangle */\r\nexport function colRectRectCornerSize(\r\n    amin : Point,\r\n    amax : Point,\r\n    bpos : Vect,\r\n    bdim : Point) : boolean {\r\n\r\n    return colRectRectCorners(\r\n        amin,\r\n        amax,\r\n        bpos,\r\n        bpos.getAdd(bdim))\r\n}\r\n\r\n/** Rectangle-rectangle collision with two corner rectangles */\r\nexport function colRectRectCorners(    \r\n    amin : Point,\r\n    amax : Point,\r\n    bmin : Point,\r\n    bmax : Point) : boolean {\r\n\r\n    return (\r\n        amin.x < bmax.x &&\r\n        amax.x > bmin.x &&\r\n        amin.y < bmax.y &&\r\n        amax.y > bmin.y);\r\n}\r\n\r\n/** Point-rectangle collision but with grid coordinates */\r\nexport function colPointRectGrid(px: number, py: number, rx: number, ry: number, rw: number): boolean {\r\n    return colPointRect(\r\n        px,            // Point-X\r\n        py,            // Point-y\r\n        rx * GMULTX,   // Rect-x\r\n        ry * GMULTY,   // Rect-y\r\n        rw * GMULTX,   // Rect-width\r\n        GMULTY         // Assume height = 1\r\n    );\r\n}\r\n\r\n/** Point-parallelogram (Horizontal) collision */\r\nexport function colPointParH(px: number, py: number, rx: number, ry: number, rw: number, rh: number): boolean {\r\n    return (\r\n        px >= rx      - py + ry &&  // Horizontal tilt\r\n        py >= ry                &&\r\n        px <  rx + rw - py + ry &&  // Horizontal tilt\r\n        py <  ry + rh\r\n    );\r\n}\r\n\r\n/** Point-parallelogram (Horizontal) collision but with grid coordinates */\r\nexport function colPointParHGrid(px: number, py: number, rx: number, ry: number, rw: number): boolean {\r\n    return colPointParH(\r\n        px,                     // Point-X\r\n        py,                     // Point-y\r\n        rx * GMULTX + Z_DEPTH,  // Para-x\r\n        ry * GMULTY - Z_DEPTH,  // Para-y\r\n        rw * GMULTX,            // Para-width\r\n        Z_DEPTH                 // Para-height\r\n    );\r\n}\r\n\r\n/** Point-parallelogram (Vertical) collision */\r\nexport function colPointParV(px: number, py: number, rx: number, ry: number, rw: number, rh: number): boolean {\r\n    return (\r\n        px >= rx                &&\r\n        py >= ry      - px + rx &&  // Vertical tilt\r\n        px <  rx + rw           &&\r\n        py <  ry + rh - px + rx     // Vertical tilt\r\n    );\r\n}\r\n\r\n/** Point-parallelogram (Vertical) collision but with grid coordinates */\r\nexport function colPointParVGrid(px: number, py: number, rx: number, ry: number, rw: number): boolean {\r\n    return colPointParV(\r\n        px,                         // Point-X\r\n        py,                         // Point-y\r\n        rx * GMULTX + rw * GMULTX,  // Para-x\r\n        ry * GMULTY,                // Para-y\r\n        Z_DEPTH,                    // Para-width\r\n        GMULTY                      // Para-height\r\n    );\r\n}\r\n\r\n/** 1-dimensional collision to check vertical overlap */\r\nexport function col1D(a1: number, a2: number, b1: number, b2: number): boolean {\r\n    // Return if A and B objects overlap\r\n    return a2 > b1 && a1 < b2;\r\n}\r\n\r\n/** 1-dimensional check to measure vertical overlap */\r\nexport function gap1D(a1: number, a2: number, b1: number, b2: number): number {\r\n    // Return gap size between two ranges (negative if overlap)\r\n    if(a1 > a2) { [a1, a2] = [a2, a1] };    //Fix order for proper +/-\r\n    if(b1 > b2) { [b1, b2] = [b2, b1] };    //Fix order for proper +/-\r\n    return Math.abs(b1 - a2) < Math.abs(a1 - b2) ? (b1 - a2) : (a1 - b2);\r\n}\r\n\r\n\r\n/** Translate text colors to custom values */\r\nexport function colorTranslate(color?: string): string {\r\n    switch (color){\r\n        case undefined: return '#999999'    // No color translates to grey\r\n        case 'white':   return '#EEEEEE'\r\n        case 'blue' :   return '#0033FF'\r\n        case 'yellow':  return '#FFCC00'\r\n        case 'red':     return '#CC0000'\r\n        case 'black':   return '#333344'\r\n        case 'grey':    return '#808080'\r\n        case 'green':   return '#008000'\r\n        default:\r\n            if (color.startsWith('#')) return color;\r\n            else throw new Error(`No color definition available for color '${color}'`);\r\n    }\r\n}\r\n\r\n/** Multiply by a value all channels in a hex color */\r\nexport function colorMult(color: string, value: number): string {\r\n    return colorChange(\r\n        color,             // Color to be modified\r\n        value,             // Value to apply to this color\r\n        (c, v) => c * v    // Multiplicative function\r\n    );\r\n}\r\n\r\n/** Add a value to all channels in a hex color */\r\nexport function colorAdd(color: string, value: number): string {\r\n\r\n    return colorChange(\r\n        color,             // Color to be modified\r\n        value,             // Value to apply to this color\r\n        (c, v) => c + v    // Additive function\r\n    );\r\n}\r\n\r\n/** Modify a color given a value and modifier function */\r\nexport function colorChange(color: string, value: number, func: (color: number, value: number) => number): string {\r\n    // Array of individual color channels\r\n    let channels = [];\r\n    // There are THREE channels.\r\n    for (let i = 0; i < 3; i++) {\r\n        // For each channel, store its digits in the channels\r\n        channels[i] = parseInt(color.substr(2 * i + 1, 2), 16);\r\n    }\r\n\r\n    // Convert to decimal and apply function\r\n    channels = channels.map(c => clamp(Math.round(func(c, value)), 0, 255));\r\n    // Convert back to 2-digit hex\r\n    channels = channels.map(c => (\"0\" + c.toString(16)).substr(-2));\r\n\r\n    // Return recomposed color\r\n    return \"#\" + channels.join('');\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
