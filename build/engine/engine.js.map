{
  "version": 3,
  "sources": ["/home/jonathan/Development/lego/Operation-Recycling-Bin/src/engine/engine.ts"],
  "sourcesContent": ["import GameObject, {GameObjectParams} from \"./gameobjects/gameobject\";\nimport BakerModule from \"./modules/baker\";\nimport MouseModule from \"./modules/mouse\";\nimport TagModule from \"./modules/tag\";\nimport Scene, {SceneParams} from \"./scene/scene\";\nimport {clamp} from \"./utilities/math\";\n\n/** Engine core */\nexport default class Engine {\n    private canvas: HTMLCanvasElement;\n    private ctx: CanvasRenderingContext2D;\n    \n    /** Timestamp of last frame for calculating dt */\n    private lastTime: number = 0;\n    /** ID index of current frame */\n    private animationID: number = 0;\n    \n    /** Path scenes are located in */\n    private scenePath: string;\n    /** Currently loaded scenes */\n    private scenes: Scene[] = [];\n    /** Names of scenes to be added next frame */\n    private pushSceneNames: string[] = [];\n    /** Names of scenes to be removed next frame */\n    private killSceneNames: string[] = [];\n\n    private gameObjectTypes = new Map<string, typeof GameObject>();\n\n    public baker: BakerModule;\n    public mouse: MouseModule;\n    public tag: TagModule;\n\n    constructor(\n        element: HTMLCanvasElement,\n        scenePathName: string,\n        startScenes: string[],\n        gameObjectTypes: typeof GameObject[],\n        private width: number = 1296,\n        private height: number = 864\n    ) {\n        this.scenePath = scenePathName;\n\n        // Canvas/WebGL Context\n        this.canvas = element;\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.canvas.style.maxWidth = this.canvas.width + \"px\";\n        this.canvas.style.maxHeight = this.canvas.height + \"px\";\n        const ctx = this.canvas.getContext('2d');\n        if (!ctx) throw new Error(\"Unable to acquire WebGL context\");\n        this.ctx = ctx;\n\n        // Set up modules\n        this.baker = new BakerModule(this.canvas);\n        this.mouse = new MouseModule(this.canvas);\n        this.mouse.setResolution(this.canvas.width, this.canvas.height);\n        this.tag = new TagModule();\n\n        // Register available game object types\n        this.registerGameObjects(gameObjectTypes)\n\n        // Load each starting scene\n        startScenes.forEach(s => this.loadScene(s));\n        \n        // Start the game loop\n        this.frame();\n    }\n\n    /** Update loop */\n    private frame() {\n        this.animationID = requestAnimationFrame(() => this.frame());\n        \n        // Setup frame\n        // Calculate time delta since last frame\n        const dt = this.calculateDeltaTime();\n        // Clear the canvas\n        this.ctx.clearRect(0, 0, this.width, this.height);\n\n        // Unload and load scenes\n        this.unloadScenes(this.killSceneNames);\n        // Load each scene name in the push list\n        this.pushSceneNames.forEach(sn => this.loadScene(sn));\n        // Reset push list\n        this.pushSceneNames = [];\n\n        // Scene actions\n        this.initScenes();\n        this.updateScenes(dt);\n        this.drawScenes();\n\n        // Module updates\n        this.mouse.update();\n    }\n\n    /** Initialize all scenes */\n    private initScenes() {\n        this.scenes.forEach(s => s.init(this.ctx, this.scenes));\n    }\n\n    /** Update all scenes */\n    private updateScenes(dt: number) {\n        this.scenes.forEach(s => s.update(dt));\n    }\n\n    /** Draw all scenes */\n    private drawScenes() {\n        this.scenes.forEach(s => s.draw(this.ctx));\n    }\n\n    /** Sort scenes by z-index */\n    private sortScenes() {\n        this.scenes.sort((a, b) => a.zIndex - b.zIndex);\n    }\n\n    /** Load a scene */\n    private async loadScene(sceneName: string) {\n        const sceneResponse = await fetch(`${this.scenePath}${sceneName}.json`);\n        const sceneData: {\n            scene: SceneParams;\n            gameObjects: GameObjectParams[]\n        } = await sceneResponse.json();\n        const scene = new Scene(this, sceneData.scene);\n\n        for (const goData of sceneData.gameObjects) {\n            // Construct the object from its name\n            const GOType = this.gameObjectTypes.get(goData.name);\n            if (!GOType) throw new Error(`GameObject of type ${goData.name} does not exist`);\n            const go = new GOType(this, {...goData, scene});\n            scene.pushGO(go);\n            this.tag.pushGO(go, scene.name);\n        }\n\n        scene.sortGO();\n        this.scenes.push(scene);\n        this.sortScenes();\n    }\n\n    /** Unload scenes pending removal */\n    private unloadScenes(killSceneNames: string[]) {\n        if (killSceneNames.length > 1) {\n            // Clear scene names from core\n            this.scenes = this.scenes.filter(s => !this.killSceneNames.includes(s.name)); \n            this.tag.clear(this.killSceneNames);\n            this.killSceneNames = [];\n        }\n    }\n\n    /** \n     * Set scenes to be loaded\n     * @param fileNames File name(s) of scenes to load\n     */\n    public pushScenes(fileNames: string | string[]) {\n        if (Array.isArray(fileNames)) {\n            fileNames.forEach(s => this.pushScene(s));\n        } else {\n            this.pushScene(fileNames);\n        }\n    }\n\n    /**\n     * Set scenes to be unloaded\n     * @param sceneNames Scene name(s) to be unloaded\n     */\n    public killScenes(sceneNames: string | string[]) {\n        if (Array.isArray(sceneNames)) {\n            sceneNames.forEach(s => this.killScene(s));\n        } else {\n            this.killScene(sceneNames);\n        }\n    }\n\n    /**\n     * Set scene to be loaded\n     * @param fileName Filename of scene to load\n     */\n    private pushScene(fileName: string) {\n        if (!this.pushSceneNames.includes(fileName)) {\n            this.pushSceneNames.push(fileName);\n        }\n    }\n\n    /**\n     * Set scene to be unloaded\n     * @param sceneName Scene name of scene to unload\n     */\n    private killScene(sceneName: string) {\n        if(!this.killSceneNames.includes(sceneName)) {\n            this.killSceneNames.push(sceneName);\n        }\n    }\n\n    /** Unload all current scenes */\n    public killAllScenes() {\n        this.killScenes(this.scenes.map(s => s.name));\n    }\n\n    /**\n     * Get time since last frame\n     * @returns Time since last frame\n     */\n    private calculateDeltaTime() {\n        // Date as milliseconds\n        const now = (+new Date);\n        // Frames per second, limited between 12 and 240\n        const fps = clamp(1000 / (now - this.lastTime), 12, 240);\n        // Record timestamp for next frame\n        this.lastTime = now;\n        // Return delta time, the milliseconds between this frame and the previous frame\n        return 1/fps;\n    }\n\n    private registerGameObjects(gameObjectTypes: typeof GameObject[]): void {\n        for (const GOType of gameObjectTypes) {\n            this.gameObjectTypes.set(GOType.name, GOType);\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
