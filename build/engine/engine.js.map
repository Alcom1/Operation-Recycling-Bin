{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\engine\\engine.ts"],
  "sourcesContent": ["import GameObject, {GameObjectParams} from \"./gameobjects/gameobject\";\r\nimport BakerModule from \"./modules/baker\";\r\nimport CollisionModule from \"./modules/collision\";\r\nimport LibraryModule from \"./modules/library\";\r\nimport MouseModule from \"./modules/mouse\";\r\nimport SyncModule from \"./modules/sync\";\r\nimport TagModule from \"./modules/tag\";\r\nimport Scene, {SceneParams} from \"./scene/scene\";\r\nimport {clamp} from \"./utilities/math\";\r\n\r\n/** Engine core */\r\nexport default class Engine {\r\n\r\n    /** HTML Canvas */\r\n    private canvas: HTMLCanvasElement;\r\n    /** HTML Canvas Context */\r\n    private ctx: CanvasRenderingContext2D;\r\n    /** Timestamp of last frame for calculating dt */\r\n    private lastTime: number = 0;\r\n    /** Path scenes are located in */\r\n    private scenePath: string;\r\n    /** All Scenes */\r\n    private sceneDatas : {\r\n        scene: SceneParams;\r\n        gameObjects: GameObjectParams[]\r\n    }[] = [];\r\n    /** Currently loaded scenes */\r\n    private scenesActive: Scene[] = [];\r\n    /** Loading screen scenes */\r\n    private scenesLoading: Scene[] = [];\r\n    /** Names of scenes to be added next frame */\r\n    private pushSceneNames: string[] = [];\r\n    /** Names of scenes to be removed next frame */\r\n    private killSceneNames: string[] = [];\r\n    /** All possible types of Game Objects */\r\n    private gameObjectTypes = new Map<string, typeof GameObject>();\r\n\r\n    /** If the last frame threw an error */\r\n    private crashed = false;\r\n\r\n    /** Public Modules */\r\n    public baker: BakerModule;\r\n    public collision: CollisionModule;\r\n    public library: LibraryModule;\r\n    public mouse: MouseModule;\r\n    public sync: SyncModule;\r\n    public tag: TagModule;\r\n\r\n    /** Constructor */\r\n    constructor(\r\n        element: HTMLCanvasElement,\r\n        scenePathName: string,\r\n        sceneSource: string,\r\n        startScenes: string[],\r\n        gameObjectTypes: typeof GameObject[],\r\n        private debug: boolean = false,\r\n        private width: number = 1296,\r\n        private height: number = 864,\r\n        private physicsPerSecond = 15,\r\n        private physicsLagUpdateMax = 5\r\n    ) {\r\n        this.scenePath = scenePathName;\r\n\r\n        // Canvas/WebGL Context\r\n        this.canvas = element;\r\n        this.canvas.width = width;\r\n        this.canvas.height = height;\r\n        this.canvas.style.maxWidth = this.canvas.width + \"px\";\r\n        this.canvas.style.maxHeight = this.canvas.height + \"px\";\r\n        const ctx = this.canvas.getContext('2d');\r\n        if (!ctx) throw new Error(\"Unable to acquire WebGL context\");\r\n        this.ctx = ctx;\r\n\r\n        // Set up modules\r\n        this.baker = new BakerModule(this.canvas);\r\n        this.collision = new CollisionModule();\r\n        this.library = new LibraryModule();\r\n        this.mouse = new MouseModule(this.canvas);\r\n        this.mouse.setResolution(this.canvas.width, this.canvas.height);\r\n        this.sync = new SyncModule(this.physicsPerSecond);\r\n        this.tag = new TagModule();\r\n\r\n        // Register available game object types\r\n        this.registerGameObjects(gameObjectTypes);\r\n\r\n        // Establish starting scenes\r\n        this.pushSceneNames = startScenes;\r\n\r\n        // Load each starting & loading scene\r\n        this.loadScenes(sceneSource, this.scenesActive).finally(() => {\r\n            this.physicsFrame();\r\n            this.frame();\r\n        });\r\n    }\r\n\r\n    /** Physics Update loop - Asynchronous */\r\n    private async physicsFrame(): Promise<void> {\r\n\r\n        let t1 = Date.now();                        //Previous time\r\n        let timeCount = 0;                          //Timer for physics\r\n        let timeMin = 1000 / this.physicsPerSecond; //Number of miliseconds between physics updates\r\n\r\n        let physicsLagCount = 0;\r\n\r\n        while (true) {\r\n\r\n            //Add time difference to count\r\n            let t2 = Date.now();\r\n            timeCount += t2 - t1;\r\n            t1 = t2;\r\n\r\n            //If time difference is beyond minimum, do at least one physics update\r\n            while(timeCount >= timeMin) {\r\n\r\n                //If exceeded the maximum number of physics updates for large lag spikes, stop\r\n                if(physicsLagCount >= this.physicsLagUpdateMax) {\r\n                    timeCount = 0;      //Reset timer, no more updates\r\n                    break;              //Stop\r\n                }\r\n\r\n                //Perform updates\r\n                this.collision.update();    //Check collisions\r\n                this.sync.update();         //Resolve statuses\r\n\r\n                physicsLagCount++;      //Count lag\r\n                timeCount -= timeMin;   //Subtract duration from physics timer\r\n            }\r\n            physicsLagCount = 0;        //Reset lag count after physics updates are finished\r\n\r\n            await new Promise(resolve => setTimeout(resolve, 2));\r\n        }\r\n    }\r\n\r\n    /** Update loop */\r\n    private frame(): void {\r\n\r\n        requestAnimationFrame(() => {\r\n            // Don't continue throwing errors repeatedly without hope of recovering\r\n            if (this.crashed) return;\r\n            try {\r\n                this.frame()\r\n            } catch(e) {\r\n                this.crashed = true;\r\n                throw e;\r\n            }\r\n        });\r\n        \r\n        // Setup frame\r\n        // Calculate time delta since last frame\r\n        const dt = this.calculateDeltaTime();\r\n\r\n        // Clear the canvas\r\n        this.ctx.clearRect(0, 0, this.width, this.height);\r\n\r\n        // Unload and load scenes\r\n        this.unloadScenes(this.killSceneNames);\r\n\r\n        // Load each scene name in the push list\r\n        this.pushSceneNames.map(sn => this.loadScene(sn, this.scenesActive));\r\n\r\n        // Reset push list\r\n        this.pushSceneNames = [];\r\n\r\n        // Scene actions\r\n        if (this.library.getLoaded()) {\r\n            this.initScenes();\r\n            this.updateDrawScenes(this.scenesActive, dt);\r\n        }\r\n        else {\r\n            this.updateDrawScenes(this.scenesLoading, dt);\r\n        }\r\n\r\n        // Module updates\r\n        this.mouse.update();\r\n    }\r\n\r\n    /** Initialize all scenes */\r\n    private initScenes(): void {\r\n        this.scenesLoading.forEach(s => s.init(this.ctx));\r\n        this.scenesActive.forEach(s => s.init(this.ctx));\r\n    }\r\n\r\n    /** Perform both an update and draw */\r\n    private updateDrawScenes(scenes : Scene[], dt: number): void {\r\n        scenes.forEach(s => s.update(dt));\r\n        scenes.forEach(s => s.draw(this.ctx));\r\n        scenes.forEach(s => s.superDraw(this.ctx));\r\n\r\n        // Debug views\r\n        if (this.debug) {\r\n            this.collision.draw(this.ctx);\r\n        }\r\n    }\r\n\r\n    /** Load all scene data */\r\n    private async loadScenes(sceneName: string, scenes: Scene[]): Promise<void> {\r\n        const sceneResponse = await fetch(`${this.scenePath}${sceneName}.json`);\r\n\r\n        this.sceneDatas = await sceneResponse.json();\r\n    }\r\n\r\n    /** Load a scene */\r\n    private loadScene(sceneName: string, scenes: Scene[]) {\r\n\r\n        const sceneData = this.sceneDatas.find(s => s.scene.tag == sceneName);\r\n\r\n        if (sceneData) {\r\n\r\n            const scene = new Scene(this, sceneData.scene);\r\n\r\n            for (const goData of sceneData.gameObjects) {\r\n                // Construct the object from its name\r\n                const GOType = this.gameObjectTypes.get(goData.name);\r\n                if (!GOType) throw new Error(`GameObject of type ${goData.name} does not exist`);\r\n                const go = new GOType({...goData, engine : this, scene});\r\n                scene.pushGO(go);\r\n            }\r\n            \r\n            scenes.push(scene);\r\n            scenes.sort((a, b) => a.zIndex - b.zIndex);\r\n        }\r\n        else {\r\n            throw new Error(`Scene with tag ${sceneName} does not exist`);\r\n        }\r\n    }\r\n\r\n    /** Unload scenes pending removal */\r\n    private unloadScenes(killSceneNames: string[]): void {\r\n        if (killSceneNames.length > 1) {\r\n\r\n            // Clear scene names from core\r\n            this.scenesActive = this.scenesActive.filter(s => !this.killSceneNames.includes(s.name)); \r\n            this.tag.clear(this.killSceneNames);\r\n            this.sync.clear(this.killSceneNames);\r\n            this.collision.clear(this.killSceneNames);\r\n            this.killSceneNames = [];\r\n        }\r\n    }\r\n\r\n    /** \r\n     * Set scenes to be loaded\r\n     * @param fileNames File name(s) of scenes to load\r\n    */\r\n    public pushScenes(fileNames: string | string[]): void {\r\n        if (Array.isArray(fileNames)) {\r\n            fileNames.forEach(s => this.pushScene(s));\r\n        } else {\r\n            this.pushScene(fileNames);\r\n        }\r\n    }\r\n\r\n    /** \r\n     * Set scenes to be unloaded\r\n     * @param sceneNames Scene name(s) to be unloaded\r\n    */\r\n    public killScenes(sceneNames: string | string[]): void {\r\n        if (Array.isArray(sceneNames)) {\r\n            sceneNames.forEach(s => this.killScene(s));\r\n        } else {\r\n            this.killScene(sceneNames);\r\n        }\r\n    }\r\n\r\n    /** \r\n     * Set scene to be loaded\r\n     * @param fileName Filename of scene to load\r\n    */\r\n    private pushScene(fileName: string): void {\r\n        if (!this.pushSceneNames.includes(fileName)) {\r\n            this.pushSceneNames.push(fileName);\r\n        }\r\n    }\r\n\r\n    /** \r\n     * Set scene to be unloaded\r\n     * @param sceneName Scene name of scene to unload\r\n    */\r\n    private killScene(sceneName: string): void {\r\n        if (!this.killSceneNames.includes(sceneName)) {\r\n            this.killSceneNames.push(sceneName);\r\n        }\r\n    }\r\n\r\n    /** Unload all current scenes */\r\n    public killAllScenes(): void {\r\n        this.killScenes(this.scenesActive.map(s => s.name));\r\n    }\r\n\r\n    /** \r\n     * Get time since last frame\r\n     * @returns Time since last frame\r\n    */\r\n    private calculateDeltaTime(): number {\r\n        // Date as milliseconds\r\n        const now = (+new Date);\r\n        // Frames per second, limited between 12 and 240\r\n        const fps = clamp(1000 / (now - this.lastTime), 12, 240);\r\n        // Record timestamp for next frame\r\n        this.lastTime = now;\r\n        // Return delta time, the milliseconds between this frame and the previous frame\r\n        return 1/fps;\r\n    }\r\n\r\n    /** Register a game object type */\r\n    private registerGameObjects(gameObjectTypes: typeof GameObject[]): void {\r\n        for (const GOType of gameObjectTypes) {\r\n            this.gameObjectTypes.set(GOType.name, GOType);\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
