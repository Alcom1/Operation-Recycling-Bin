{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\engine\\engine.ts"],
  "sourcesContent": ["import GameObject, {GameObjectParams} from \"./gameobjects/gameobject\";\r\nimport BakerModule from \"./modules/baker\";\r\nimport CollisionModule from \"./modules/collision\";\r\nimport LibraryModule from \"./modules/library\";\r\nimport MouseModule from \"./modules/mouse\";\r\nimport TagModule from \"./modules/tag\";\r\nimport Scene, {SceneParams} from \"./scene/scene\";\r\nimport {clamp} from \"./utilities/math\";\r\n\r\n/** Engine core */\r\nexport default class Engine {\r\n    private canvas: HTMLCanvasElement;\r\n    private ctx: CanvasRenderingContext2D;\r\n    \r\n    /** Timestamp of last frame for calculating dt */\r\n    private lastTime: number = 0;\r\n    /** ID index of current frame */\r\n    private animationID: number = 0;\r\n    \r\n    /** Path scenes are located in */\r\n    private scenePath: string;\r\n    \r\n    /** All Scenes */\r\n    private sceneDatas : {\r\n        scene: SceneParams;\r\n        gameObjects: GameObjectParams[]\r\n    }[] = [];\r\n    /** Currently loaded scenes */\r\n    private scenesActive: Scene[] = [];\r\n    /** Loading screen scenes */\r\n    private scenesLoading: Scene[] = [];\r\n\r\n    /** Names of scenes to be added next frame */\r\n    private pushSceneNames: string[] = [];\r\n    /** Names of scenes to be removed next frame */\r\n    private killSceneNames: string[] = [];\r\n\r\n    /** If the last frame threw an error */\r\n    private crashed = false;\r\n\r\n    private gameObjectTypes = new Map<string, typeof GameObject>();\r\n\r\n    //Modules\r\n    public baker: BakerModule;\r\n    public collision: CollisionModule;\r\n    public library: LibraryModule;\r\n    public mouse: MouseModule;\r\n    public tag: TagModule;\r\n\r\n    constructor(\r\n        element: HTMLCanvasElement,\r\n        scenePathName: string,\r\n        startScenes: string,\r\n        gameObjectTypes: typeof GameObject[],\r\n        private width: number = 1296,\r\n        private height: number = 864\r\n    ) {\r\n        this.scenePath = scenePathName;\r\n\r\n        // Canvas/WebGL Context\r\n        this.canvas = element;\r\n        this.canvas.width = width;\r\n        this.canvas.height = height;\r\n        this.canvas.style.maxWidth = this.canvas.width + \"px\";\r\n        this.canvas.style.maxHeight = this.canvas.height + \"px\";\r\n        const ctx = this.canvas.getContext('2d');\r\n        if (!ctx) throw new Error(\"Unable to acquire WebGL context\");\r\n        this.ctx = ctx;\r\n\r\n        // Set up modules\r\n        this.baker = new BakerModule(this.canvas);\r\n        this.collision = new CollisionModule();\r\n        this.library = new LibraryModule();\r\n        this.mouse = new MouseModule(this.canvas);\r\n        this.mouse.setResolution(this.canvas.width, this.canvas.height);\r\n        this.tag = new TagModule();\r\n\r\n        // Register available game object types\r\n        this.registerGameObjects(gameObjectTypes);\r\n\r\n        this.pushSceneNames = [\"LevelInterface\", \"LEVEL_53\"];\r\n\r\n        // Load each starting & loading scene\r\n        this.loadScenes(startScenes, this.scenesActive).finally(() => { this.frame() });\r\n    }\r\n\r\n    /** Update loop */\r\n    private frame(): void {\r\n\r\n        this.animationID = requestAnimationFrame(() => {\r\n            // Don't continue throwing errors repeatedly without hope of recovering\r\n            if (this.crashed) return;\r\n            try {\r\n                this.frame()\r\n            } catch(e) {\r\n                this.crashed = true;\r\n                throw e;\r\n            }\r\n        });\r\n        \r\n        // Setup frame\r\n        // Calculate time delta since last frame\r\n        const dt = this.calculateDeltaTime();\r\n\r\n        // Clear the canvas\r\n        this.ctx.clearRect(0, 0, this.width, this.height);\r\n\r\n        // Unload and load scenes\r\n        this.unloadScenes(this.killSceneNames);\r\n\r\n        // Load each scene name in the push list\r\n        this.pushSceneNames.map(sn => this.loadScene(sn, this.scenesActive));\r\n\r\n        // Reset push list\r\n        this.pushSceneNames = [];\r\n\r\n        // Scene actions\r\n        if(this.library.getLoaded()) {\r\n            this.initScenes();\r\n            this.updateDrawScenes(this.scenesActive, dt);\r\n        }\r\n        else {\r\n            this.updateDrawScenes(this.scenesLoading, dt);\r\n        }\r\n\r\n        // Module updates\r\n        this.mouse.update();\r\n    }\r\n\r\n    /** Initialize all scenes */\r\n    private initScenes(): void {\r\n        this.collision.update();\r\n        this.scenesLoading.forEach(s => s.init(this.ctx, this.scenesActive));\r\n        this.scenesActive.forEach(s => s.init(this.ctx, this.scenesActive));\r\n    }\r\n\r\n    /** Perform both an update and draw */\r\n    private updateDrawScenes(scenes : Scene[], dt: number): void {\r\n        scenes.forEach(s => s.update(dt));\r\n        scenes.forEach(s => s.draw(this.ctx));\r\n        scenes.forEach(s => s.superDraw(this.ctx));\r\n    }\r\n\r\n    /** Load all scene data */\r\n    private async loadScenes(sceneName: string, scenes: Scene[]): Promise<void> {\r\n        const sceneResponse = await fetch(`${this.scenePath}${sceneName}.json`);\r\n\r\n        this.sceneDatas = await sceneResponse.json();\r\n    }\r\n\r\n    /** Load a scene */\r\n    private loadScene(sceneName: string, scenes: Scene[]) {\r\n\r\n        const sceneData = this.sceneDatas.find(s => s.scene.tag == sceneName);\r\n\r\n        if(sceneData) {\r\n\r\n            const scene = new Scene(this, sceneData.scene);\r\n\r\n            for (const goData of sceneData.gameObjects) {\r\n                // Construct the object from its name\r\n                const GOType = this.gameObjectTypes.get(goData.name);\r\n                if (!GOType) throw new Error(`GameObject of type ${goData.name} does not exist`);\r\n                const go = new GOType(this, {...goData, scene});\r\n                scene.pushGO(go);\r\n                this.tag.pushGO(go, scene.name);\r\n            }\r\n    \r\n            scene.sortGO();\r\n            scenes.push(scene);\r\n            scenes.sort((a, b) => a.zIndex - b.zIndex);\r\n        }\r\n        else {\r\n            throw new Error(`Scene with tag ${sceneName} does not exist`);\r\n        }\r\n    }\r\n\r\n    /** Unload scenes pending removal */\r\n    private unloadScenes(killSceneNames: string[]): void {\r\n        if (killSceneNames.length > 1) {\r\n\r\n            // Clear scene names from core\r\n            this.scenesActive = this.scenesActive.filter(s => !this.killSceneNames.includes(s.name)); \r\n            this.tag.clear(this.killSceneNames);\r\n            this.collision.clear(this.killSceneNames);\r\n            this.killSceneNames = [];\r\n        }\r\n    }\r\n\r\n    /** \r\n     * Set scenes to be loaded\r\n     * @param fileNames File name(s) of scenes to load\r\n     */\r\n    public pushScenes(fileNames: string | string[]): void {\r\n        if (Array.isArray(fileNames)) {\r\n            fileNames.forEach(s => this.pushScene(s));\r\n        } else {\r\n            this.pushScene(fileNames);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set scenes to be unloaded\r\n     * @param sceneNames Scene name(s) to be unloaded\r\n     */\r\n    public killScenes(sceneNames: string | string[]): void {\r\n        if (Array.isArray(sceneNames)) {\r\n            sceneNames.forEach(s => this.killScene(s));\r\n        } else {\r\n            this.killScene(sceneNames);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set scene to be loaded\r\n     * @param fileName Filename of scene to load\r\n     */\r\n    private pushScene(fileName: string): void {\r\n        if (!this.pushSceneNames.includes(fileName)) {\r\n            this.pushSceneNames.push(fileName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set scene to be unloaded\r\n     * @param sceneName Scene name of scene to unload\r\n     */\r\n    private killScene(sceneName: string): void {\r\n        if(!this.killSceneNames.includes(sceneName)) {\r\n            this.killSceneNames.push(sceneName);\r\n        }\r\n    }\r\n\r\n    /** Unload all current scenes */\r\n    public killAllScenes(): void {\r\n        this.killScenes(this.scenesActive.map(s => s.name));\r\n    }\r\n\r\n    /**\r\n     * Get time since last frame\r\n     * @returns Time since last frame\r\n     */\r\n    private calculateDeltaTime(): number {\r\n        // Date as milliseconds\r\n        const now = (+new Date);\r\n        // Frames per second, limited between 12 and 240\r\n        const fps = clamp(1000 / (now - this.lastTime), 12, 240);\r\n        // Record timestamp for next frame\r\n        this.lastTime = now;\r\n        // Return delta time, the milliseconds between this frame and the previous frame\r\n        return 1/fps;\r\n    }\r\n\r\n    private registerGameObjects(gameObjectTypes: typeof GameObject[]): void {\r\n        for (const GOType of gameObjectTypes) {\r\n            this.gameObjectTypes.set(GOType.name, GOType);\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
