{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\animation.ts"],
  "sourcesContent": ["import Engine from \"engine/engine\";\r\nimport GameObject, { GameObjectParams } from \"engine/gameobjects/gameobject\";\r\nimport { floor, getZIndex, GMULTX, GMULTY, OPPOSITE_DIRS } from \"engine/utilities/math\";\r\nimport Vect, { Point } from \"engine/utilities/vect\";\r\n\r\nexport interface OffsetImageExpandedParams {\r\n    name : string;\r\n    extension : string;\r\n    offsetX : number;\r\n}\r\n\r\nexport interface OffsetImageParams {\r\n    name : string;\r\n    extension? : string;\r\n    offsetX : number;\r\n}\r\n\r\nexport interface OffsetImage {\r\n    image : HTMLImageElement;\r\n    offsetX : number;\r\n}\r\n\r\nexport interface AnimationParams extends GameObjectParams {\r\n    images : OffsetImageParams[];\r\n    speed? : number;\r\n    isLoop? : boolean;\r\n    isVert? : boolean;\r\n    framesSize? : number;\r\n    gposOffset? : Point;\r\n    zModifier? : number;\r\n\r\n    frameCount : number;\r\n    animsCount? : number;\r\n    sliceIndex? : number;\r\n}\r\n\r\n/** Animated image gameobject */\r\nexport default class Animat extends GameObject {\r\n\r\n    //Set in constructor\r\n    private gposOffset : Point;                     //Constant offset of the global position\r\n    private zModifier : number;                     //Modifier value added to the zIndex\r\n    private images : OffsetImage[] = [];            //Animation images with a horizontal offset\r\n    private speed : number;                         //Speed of the animation\r\n    public  isLoop : boolean;                       //If this animation is looped\r\n    private isVert : boolean;                       //If this animation is arranged vertically\r\n    private framesSize? : number;                   //The Horizontal/Vertical size of each frame\r\n    private frameCount : number;                    //The Quantity of frames for this animation\r\n    private animsCount : number;                    //The number of animations per image\r\n    private sliceIndex? : number;                   //The index of this animation, if it's been sliced\r\n\r\n    //Set in init\r\n    private fullSize : Point = { x : 0, y : 0 };    //The full dimensions of this animation's images\r\n\r\n    //Set here\r\n    public  zModifierPub : number = 0;              //Public z-modifier\r\n    public  isVisible : boolean = true;             //If this animation is visible\r\n    private timer : number = 0;                     //Timer to track frames\r\n    private imageIndex: number = 0;                 //Index of the current image\r\n    private animsIndex : number = 0;                //Index of the current animation\r\n\r\n    //get\r\n    public get duration() : number { return 1 / this.speed; }\r\n\r\n    constructor(engine : Engine, params : AnimationParams) {\r\n        super(engine, params);\r\n\r\n        this.speed = params.speed ?? 1;\r\n        this.isLoop = params.isLoop ?? true;\r\n        this.isVert = params.isVert ?? false;\r\n        this.framesSize = params.framesSize;\r\n        this.gposOffset = params.gposOffset ?? { x : 0, y : 0 }\r\n        this.zModifier = params.zModifier ?? 300;\r\n\r\n        switch(params.images.length) {\r\n\r\n            //No images (why?)\r\n            case 0:\r\n                break;\r\n\r\n            //Single images\r\n            case 1:\r\n                this.images[0] = this.getImage(params.images[0]);\r\n                break;\r\n            \r\n            //Pair of images with opposing directions\r\n            case 2:\r\n                this.imageIndex = 1;\r\n                OPPOSITE_DIRS.forEach(d => {\r\n                    const index = Math.max(d, 0);\r\n                    if(params.images[index]) {\r\n                        this.images[d] = this.getImage(params.images[index]);\r\n                    }\r\n                });\r\n                break;\r\n\r\n            //Many images\r\n            default:\r\n                this.imageIndex = 1;\r\n                params.images.forEach((x, i) => {\r\n                    this.images[OPPOSITE_DIRS[i % 2] * Math.ceil((i + 1) / 2)] = this.getImage(x);\r\n                });\r\n        }\r\n\r\n        this.frameCount = params.frameCount;\r\n        this.animsCount = params.animsCount ?? 1;\r\n        this.sliceIndex = params.sliceIndex;\r\n    }\r\n\r\n    //Retrieve an image from the library\r\n    private getImage(params : OffsetImageParams) : OffsetImage {\r\n\r\n        return {\r\n            image : this.engine.library.getImage(\r\n                params.name, \r\n                params.extension),\r\n            offsetX : params.offsetX ?? 0\r\n        }\r\n    }\r\n\r\n    //Init is called after images are retrieved. \r\n    public init(ctx : CanvasRenderingContext2D) {\r\n\r\n        this.fullSize = {\r\n            x : this.images[this.imageIndex].image.width,\r\n            y : this.images[this.imageIndex].image.height\r\n        }\r\n    }\r\n\r\n    //Update and track timer for this animation\r\n    public update(dt: number) {\r\n\r\n        //For all moving animations\r\n        if(this.speed > 0) {\r\n\r\n            //Increment timer by delta-time\r\n            this.timer += dt;\r\n    \r\n            if(this.isLoop && this.timer > 1 / this.speed) {\r\n\r\n                this.timer -= 1 / this.speed;   //May cause frame skipping\r\n            }\r\n        }\r\n    }\r\n\r\n    //Reset timer, update position, and switch current animation.\r\n    public reset(gpos? : Vect) {\r\n\r\n        this.timer = 0;\r\n        if(gpos) { this.gpos = gpos.getAdd(this.gposOffset); }\r\n        this.animsIndex = ++this.animsIndex % this.animsCount;\r\n    }\r\n\r\n    //Get z-index for draw sorting\r\n    public getGOZIndex() : number {\r\n\r\n        return getZIndex(\r\n            this.gpos,\r\n            this.zModifier + this.zModifierPub)\r\n    }\r\n\r\n    //Set the image index, swapping the image for this animation.\r\n    public setImageIndex(index : number) {\r\n\r\n        //This animation has many images\r\n        if(this.images[index]) {\r\n            this.imageIndex = index;\r\n        }\r\n        //This animation has 2 images\r\n        else if(this.images[Math.sign(index)]) {\r\n            this.imageIndex = Math.sign(index);\r\n        }\r\n        //This animation has 1 image\r\n        else if(this.images[0]) {\r\n            this.imageIndex = 0;\r\n        }\r\n    }\r\n\r\n    //Draw this animation\r\n    public draw(ctx : CanvasRenderingContext2D) {\r\n\r\n        //Stop if this animation is not visible\r\n        if(!this.isVisible) {\r\n            return;\r\n        }\r\n\r\n        const size = this.framesSize ?? 0;                                  //Size (horizontal or vertical) of this frame\r\n        const image = this.images[this.imageIndex];                         //Current image\r\n        const widthSlice = size * (this.sliceIndex ?? 0);                   //Slice width, or 0 if this animation isn't sliced\r\n        const oppoSize = this.isVert ? this.fullSize.x : this.fullSize.y;   //Full width or height (the non-animated direction)\r\n\r\n        ctx.drawImage(\r\n            //Greater image\r\n            image.image,                    \r\n\r\n            //Slice position & size \r\n            widthSlice +                    //Move segment forward based on which slice this is.\r\n            image.offsetX +                 //Move segment forward based on the X-offset of the current image  \r\n            this.getAnimationOffset(false),\r\n            this.getAnimationOffset(true),  \r\n            this.isVert ? oppoSize : size,  \r\n            this.isVert ? size : oppoSize,    \r\n\r\n            //Greater image position & size\r\n            widthSlice,                     //Move segment forward based on which slice this is. Unused(?) for vertical animations.\r\n            this.isVert ? 0 : GMULTY - this.fullSize.y,\r\n            this.isVert ? oppoSize : size,  \r\n            this.isVert ? size : oppoSize);\r\n\r\n        // ctx.globalAlpha = 0.5;\r\n        // ctx.strokeStyle = \"#F00\"\r\n        // ctx.lineWidth = 4;\r\n        // ctx.strokeRect(\r\n        //     widthSlice, \r\n        //     this.isVert ? 0 : GMULTY, \r\n        //     this.isVert ? oppoSize : size, \r\n        //     this.isVert ? size : -oppoSize);\r\n    }\r\n\r\n    private getAnimationOffset(checkVert : boolean) : number {\r\n\r\n        //If the animation direction matches the checked direction, return an animation offset, 0 otherwise.\r\n        if(checkVert == this.isVert) {\r\n\r\n            const fullSize = this.isVert ? this.fullSize.y : this.fullSize.x;\r\n\r\n            return floor((                  //Move segment forward to the current animation and current frame\r\n                this.animsIndex +           //Move segment forward to the current animation\r\n                Math.min(                   //Get current frame based on the timer and speed of the animation\r\n                    this.timer *        \r\n                    this.speed,         \r\n                    1 - Number.EPSILON)) *  //Subtract epsilon to prevent grabbing the next frame at max value\r\n                fullSize / this.animsCount,             \r\n                fullSize / this.frameCount)\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n}"],
  "mappings": "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",
  "names": []
}
