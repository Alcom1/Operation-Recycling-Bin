{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\brickhandlerdebug.ts"],
  "sourcesContent": ["import { GameObjectParams } from \"engine/gameobjects/gameobject\";\r\nimport { col1D, GMULTX, GMULTY } from \"engine/utilities/math\";\r\nimport { Point } from \"engine/utilities/vect\";\r\nimport Brick from \"./brick\";\r\nimport BrickHandler from \"./brickhandler\";\r\n\r\n/** A point with an opacity for fade effects */\r\ninterface PointDebug extends Point {\r\n    opacity : number;\r\n}\r\n\r\n/** Brickhander extension with debug methods */\r\nexport default class BrickHandlerDebug extends BrickHandler {\r\n    private debugPoints : PointDebug[] = [];\r\n\r\n    /** Constructor */\r\n    constructor(params: GameObjectParams) {\r\n        super(params);\r\n\r\n        this.tags.push(\"BrickHandler\"); // Treat this as a regular brick handler\r\n    }\r\n\r\n    /** Update, fade older debug points */\r\n    public update(dt: number) {\r\n        this.debugPoints.forEach(dp => dp.opacity -= dt * 2);               // Fade debug points\r\n        this.debugPoints = this.debugPoints.filter(dp => dp.opacity > 0);   // Remove debug points after they disappear\r\n    }\r\n\r\n    /** Draw debug points */\r\n    public draw(ctx: CanvasRenderingContext2D) {\r\n\r\n        ctx.fillStyle = \"#0FF\"\r\n\r\n        this.debugPoints.forEach(dp => {\r\n            ctx.globalAlpha = dp.opacity;\r\n            ctx.fillRect(\r\n                GMULTX * dp.x + 4,\r\n                GMULTY * dp.y + 4,\r\n                GMULTX - 8,\r\n                GMULTY - 8\r\n            );\r\n        });\r\n    }\r\n\r\n    /** Check collisons for a vertically-looping range and return a bitmask */\r\n    public checkCollisionRange(pos: Point, dir: number, start: number, final: number, height: number, width: number = 2): number {\r\n\r\n        // Create new debug points from this collision\r\n        for(let i = start; i < final; i++) {\r\n            this.debugPoints.push({\r\n                x : pos.x + Math.floor(i / height) % width  * dir,  // Wrap by width to go back and check ceiling\r\n                y : pos.y + i % height + 1,                         // Wrap by height\r\n                opacity : 1\r\n            });\r\n        }\r\n\r\n        // Perform actual collision check\r\n        return super.checkCollisionRange(pos, dir, start, final, height, width);\r\n    }\r\n\r\n    /** Check collisons for a square ring and return a bitmask */\r\n    public checkCollisionRing(pos: Point, size: number, dir : number = 1, overhang : boolean = true): number {\r\n\r\n        let collisions = 0;     // Collision bitbask\r\n        let count = 0;          // Count gridspaces being checked\r\n        let row : Brick[] = [];\r\n\r\n        // Vertical travel\r\n        for(let j = pos.y; j < pos.y + size; j++) {\r\n\r\n            // Get this row\r\n            row = this.bricks.filter(b => b.gpos.y == j && !b.isSelected) || [];\r\n\r\n            // Horizontal travel, skip to end unless this is the first or last row to create a ring shape\r\n            for(let i = pos.x; i < pos.x + size; i += ((j > pos.y && j < pos.y + size - 1) ? size - 1 : 1)) {\r\n\r\n                // Reverse horizontally if the direction isn't positive.\r\n                let check = dir > 0 ? i : 2 * pos.x - i + size - 1;\r\n\r\n                this.debugPoints.push({ x : check, y : j, opacity : 1});\r\n\r\n                // Check each brick int his row.\r\n                row.forEach(brick => {\r\n\r\n                    if (col1D(\r\n                        brick.gpos.x - 1, \r\n                        brick.gpos.x + brick.width,\r\n                        check,\r\n                        check\r\n                    )) {\r\n                        collisions += 1 << (count);\r\n                    }\r\n                });\r\n\r\n                count++;\r\n            }\r\n        }\r\n\r\n        //Single overhang space\r\n        if(overhang) {\r\n\r\n            //x-pos of new space\r\n            let check = dir > 0 ? pos.x + size : pos.x - 1;\r\n            this.debugPoints.push({ x : check, y : pos.y + size - 1, opacity : 1});\r\n\r\n            // Check each brick in most recent & bottom row.\r\n            row.forEach(brick => {\r\n\r\n                if (col1D(\r\n                    brick.gpos.x - 1, \r\n                    brick.gpos.x + brick.width,\r\n                    check,\r\n                    check\r\n                )) {\r\n                    collisions += 1 << (count);\r\n                }\r\n            });\r\n\r\n            count++;\r\n        }\r\n\r\n        return collisions;\r\n    }\r\n}\r\n"],
  "mappings": "AACA;AAGA;AAJA,+CAY+C;AAAA,EAI3C,YAAY;AACR,UAAM;AAJF,uBAA6B;AAMjC,SAAK,KAAK,KAAK;AAAA;AAAA,EAIZ;AACH,SAAK,YAAY,QAAQ,QAAM,GAAG,WAAW,KAAK;AAClD,SAAK,cAAc,KAAK,YAAY,OAAO,QAAM,GAAG,UAAU;AAAA;AAAA,EAI3D;AAEH,QAAI,YAAY;AAEhB,SAAK,YAAY,QAAQ;AACrB,UAAI,cAAc,GAAG;AACrB,UAAI,SACA,SAAS,GAAG,IAAI,GAChB,SAAS,GAAG,IAAI,GAChB,SAAS,GACT,SAAS;AAAA;AAAA;AAAA,EAMd,4DAA2G;AAG9G,iBAAY,OAAO,IAAI,OAAO;AAC1B,WAAK,YAAY,KAAK;AAAA,QAClB,GAAI,IAAI,IAAI,KAAK,MAAM,IAAI,UAAU,QAAS;AAAA,QAC9C,GAAI,IAAI,IAAI,IAAI,SAAS;AAAA,QACzB,SAAU;AAAA;AAAA;AAKlB,WAAO,MAAM,oBAAoB,KAAK,KAAK,OAAO,OAAO,QAAQ;AAAA;AAAA,EAI9D,oCAA4D,cAAwB;AAEvF,qBAAiB;AACjB,gBAAY;AACZ,cAAoB;AAGpB,iBAAY,IAAI,GAAG,IAAI,IAAI,IAAI,MAAM;AAGjC,YAAM,KAAK,OAAO,OAAO,OAAK,EAAE,KAAK,KAAK,KAAK,CAAC,EAAE,eAAe;AAGjE,mBAAY,IAAI,GAAG,IAAI,IAAI,IAAI,MAAM,KAAO,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI,OAAO,IAAK,OAAO,IAAI;AAGxF,oBAAY,MAAM,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,OAAO;AAEjD,aAAK,YAAY,KAAK,CAAE,GAAI,OAAO,GAAI,GAAG,SAAU;AAGpD,YAAI,QAAQ;AAER,cAAI,MACA,OAAM,KAAK,IAAI,GACf,OAAM,KAAK,IAAI,OAAM,OACrB,OACA;AAEA,0BAAc,KAAM;AAAA;AAAA;AAI5B;AAAA;AAAA;AAKR,QAAG;AAGC,kBAAY,MAAM,IAAI,IAAI,IAAI,OAAO,IAAI,IAAI;AAC7C,WAAK,YAAY,KAAK,CAAE,GAAI,OAAO,GAAI,IAAI,IAAI,OAAO,GAAG,SAAU;AAGnE,UAAI,QAAQ;AAER,YAAI,MACA,OAAM,KAAK,IAAI,GACf,OAAM,KAAK,IAAI,OAAM,OACrB,OACA;AAEA,wBAAc,KAAM;AAAA;AAAA;AAI5B;AAAA;AAGJ,WAAO;AAAA;AAAA;",
  "names": []
}
