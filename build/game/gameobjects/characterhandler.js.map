{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\characterhandler.ts"],
  "sourcesContent": ["import GameObject from \"engine/gameobjects/gameobject\";\r\nimport { Point } from \"engine/utilities/vect\";\r\nimport Character from \"./character\";\r\n\r\n/** Handler for brick selection, movement, etc. */\r\nexport default class CharacterHandler extends GameObject {\r\n\r\n    private characters: Character[] = [];\r\n    private isStart: boolean = false;\r\n\r\n    /** Initalize the brick handler, get related bricks & game objects, manage bricks */\r\n    public init() {\r\n         \r\n        this.characters = this.engine.tag.get(  // Get bricks from scene\r\n            \"Character\", \r\n            \"Level\") as Character[];\r\n    }\r\n\r\n    /** A second layer of initialization, gets characters out of unwanted starting positions */\r\n    public update()\r\n    {\r\n        //If this handler hasn't started yet (after constructor and init)\r\n        if(!this.isStart) {\r\n\r\n            this.isStart = true;    //Started\r\n\r\n            //Map character groups as characters with their specific tag\r\n            let charactersTagged = this.characters;\r\n            \r\n            //Sort characters by their grid x-pos or grid y-pos.\r\n            charactersTagged.sort((a, b) => \r\n                a.gpos.x - b.gpos.x || \r\n                a.gpos.y - b.gpos.y);\r\n\r\n            //Update character states by positional order\r\n            this.handleStepUpdate(charactersTagged, 0, 0, true);\r\n        }\r\n    }\r\n\r\n    /** Get all no-place zones */\r\n    public getNoPlaceZones() : Point[] {\r\n        return this.characters.flatMap(x => x.getNoPlaceZone());\r\n    }\r\n\r\n    /** Perform synchronous updates for all characters */\r\n    public updateSync(counter : number, loopLength : number) {\r\n\r\n        //Map character groups as characters with their specific tag\r\n        let charactersTagged = this.characters;\r\n        \r\n        //Sort characters by their grid x-pos or grid y-pos.\r\n        charactersTagged.sort((a, b) => \r\n            a.gpos.x - b.gpos.x || \r\n            b.gpos.y - a.gpos.y);\r\n        \r\n        //Move characters by positional order\r\n        charactersTagged.forEach(ct => {\r\n\r\n            // The step matches this character's speed, perform an update\r\n            if (counter % (loopLength / ct.speed) == 0) {\r\n\r\n                ct.handleStep();\r\n            }\r\n        });\r\n\r\n        //Handle proximity and step updates for all characters\r\n        this.handleStepUpdate(charactersTagged, counter, loopLength)\r\n    }\r\n\r\n    //Handle proximity and step updates for all characters\r\n    public handleStepUpdate(\r\n        charactersTagged : Character[], \r\n        counter : number, \r\n        loopLength : number, \r\n        isOverride : boolean = false) {\r\n        \r\n        //Update character states by positional order\r\n        charactersTagged.forEach((ct1, i) => {\r\n\r\n            // The step matches this character's speed, perform an update\r\n            if (isOverride || counter % (loopLength / ct1.speed) == 0) {\r\n\r\n                let proxs : Point[] = [];\r\n\r\n                //Proximity check against characters with height 2\r\n                charactersTagged.slice(0, i).filter(ct2 => ct2.height == 2).forEach(ct2 => {\r\n\r\n                    //Distance vector between characters\r\n                    let diff = ct2.gpos.getSub(ct1.gpos);\r\n\r\n                    //In proximity range\r\n                    if (Math.abs(diff.x) <= 3 &&\r\n                        Math.abs(diff.y) <= 3) {\r\n\r\n                        //Get proximity with future-expected position of other character\r\n                        proxs.push(diff.getAdd({\r\n                            x : ct2.move.y == 0 ? ct2.move.x : 0,\r\n                            y : ct2.move.y\r\n                        }));\r\n                    }\r\n\r\n                });\r\n\r\n                //Handle step with proximity results\r\n                ct1.handleStepUpdate(proxs);\r\n            }\r\n        });\r\n    }\r\n}\r\n"],
  "mappings": "AAAA;AAAA,8CAK8C;AAAA,EAL9C;AAAA;AAOY,sBAA0B;AAC1B,mBAAmB;AAAA;AAAA,EAGpB;AAEH,SAAK,aAAa,KAAK,OAAO,IAAI,IAC9B,aACA;AAAA;AAAA,EAID;AAGH,QAAG,CAAC,KAAK;AAEL,WAAK,UAAU;AAGf,UAAI,mBAAmB,KAAK;AAG5B,uBAAiB,KAAK,UAClB,EAAE,KAAK,IAAI,EAAE,KAAK,KAClB,EAAE,KAAK,IAAI,EAAE,KAAK;AAGtB,WAAK,iBAAiB,kBAAkB,GAAG,GAAG;AAAA;AAAA;AAAA,EAK/C;AACH,WAAO,KAAK,WAAW,QAAQ,OAAK,EAAE;AAAA;AAAA,EAInC;AAGH,2BAAuB,KAAK;AAG5B,qBAAiB,KAAK,UAClB,EAAE,KAAK,IAAI,EAAE,KAAK,KAClB,EAAE,KAAK,IAAI,EAAE,KAAK;AAGtB,qBAAiB,QAAQ;AAGrB,UAAI,UAAW,cAAa,GAAG,UAAU;AAErC,WAAG;AAAA;AAAA;AAKX,SAAK,iBAAiB,kBAAkB,SAAS;AAAA;AAAA,EAI9C,qEAIoB;AAGvB,qBAAiB,QAAQ;AAGrB,UAAI,cAAc,UAAW,cAAa,IAAI,UAAU;AAEpD,oBAAsB;AAGtB,yBAAiB,MAAM,GAAG,GAAG,OAAO,SAAO,IAAI,UAAU,GAAG,QAAQ;AAGhE,qBAAW,IAAI,KAAK,OAAO,IAAI;AAG/B,cAAI,KAAK,IAAI,KAAK,MAAM,KACpB,KAAK,IAAI,KAAK,MAAM;AAGpB,kBAAM,KAAK,KAAK,OAAO;AAAA,cACnB,GAAI,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,IAAI;AAAA,cACnC,GAAI,IAAI,KAAK;AAAA;AAAA;AAAA;AAOzB,YAAI,iBAAiB;AAAA;AAAA;AAAA;AAAA;",
  "names": []
}
