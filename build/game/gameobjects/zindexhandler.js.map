{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\zindexhandler.ts"],
  "sourcesContent": ["import GameObject from \"engine/gameobjects/gameobject\";\r\nimport { BOUNDARY, col1D, gap1D, GMULTX, GMULTY } from \"engine/utilities/math\";\r\nimport Vect, { Point } from \"engine/utilities/vect\";\r\n\r\ninterface ZPoint {\r\n    gameObject : GameObject,\r\n    pos : Point,\r\n    size : Point,\r\n    flat : Boolean,\r\n    state : Boolean,\r\n    layer : Number,\r\n    noCompare : Boolean\r\n}\r\n\r\n/** Handler for brick selection, movement, etc. */\r\nexport default class ZIndexHandler extends GameObject {\r\n\r\n    private zPoints : ZPoint[] = [];\r\n    private get zPointsActive() : ZPoint[] { return this.zPoints.filter(z => z.state) }\r\n    private zEdges : ZPoint[][] = [];\r\n    private debug : Boolean = false;\r\n\r\n    /** Initalize the brick handler, get related bricks & game objects, manage bricks */\r\n    public init() {\r\n\r\n        this.engine.tag.get(\r\n            [\"Brick\",\"Character\",\"Stud\",\"Wind\",\"Misc\"],         // Z-sort for these tags...\r\n            \"Level\").filter(x => {\r\n                return x.tags.every(x => x != \"BrickPhantom\");  // But not these tags.\r\n            }).forEach(o => \r\n                this.zPoints.push({\r\n                    gameObject : o,\r\n                    pos : this.getTrueZpos(o.zpos, o.zSize.y == 0),\r\n                    size : this.getTrueZsize(o.zSize),\r\n                    flat : o.zSize.y == 0,\r\n                    state : o.zState,\r\n                    layer : o.zLayer,\r\n                    noCompare : o.zNoCompare\r\n                }));\r\n\r\n        this.processZPoints();\r\n    }\r\n\r\n    /** Update, check and modify tree */\r\n    public update() {\r\n        this.processZPoints();\r\n    }\r\n\r\n    /** Process all zPoints */\r\n    private processZPoints() {\r\n\r\n        this.zEdges = [];\r\n        \r\n        //Setup zpoints for current state\r\n        this.zPoints.forEach(z => {\r\n            z.pos = this.getTrueZpos(z.gameObject.zpos, z.flat);\r\n            z.state = z.gameObject.zState;\r\n            z.layer = z.gameObject.zLayer;\r\n            z.size = this.getTrueZsize(z.gameObject.zSize);\r\n        });\r\n        \r\n        //Compare z-points and get the edges between them\r\n        this.zEdges = this.zPointsActive.flatMap(z => this.processZPoint(z).map(b => [z, b]));\r\n\r\n        //Set z-indicies based on sorted array indicies\r\n        this.topologicalSort().forEach((z, i) => {\r\n            z.gameObject.zIndex = i;\r\n        });\r\n    }\r\n\r\n    /** Get the true z-position of a zpoint*/\r\n    private getTrueZpos(zpos : Vect, flat : Boolean) : Vect {\r\n\r\n        return new Vect(zpos.x, zpos.y * 2 - (flat ? 0 : 1));\r\n    }\r\n\r\n    /** Get the true z-position of a zpoint*/\r\n    private getTrueZsize(zsize : Point) : Vect {\r\n\r\n        return new Vect(zsize.x, Math.max(zsize.y * 2, 1));\r\n    }\r\n\r\n    /** Process a single zPoint */\r\n    private processZPoint(c : ZPoint) : ZPoint[] {\r\n\r\n        let ret = [] as ZPoint[];\r\n\r\n        //Game Objects above\r\n        ret = ret.concat(this.zPointsActive.filter(o => {\r\n\r\n            //If the comparison is invalid, skip\r\n            if(!this.checkValidComparison(c, o)) {\r\n                return false;\r\n            }\r\n\r\n            let isAbove = c.pos.y > o.pos.y;\r\n\r\n            let isAlign = col1D(\r\n                c.pos.x,\r\n                c.pos.x + c.size.x,\r\n                o.pos.x,\r\n                o.pos.x + o.size.x);\r\n\r\n            let distance = gap1D(\r\n                o.pos.y,\r\n                o.pos.y + o.size.y,\r\n                c.pos.y,\r\n                c.pos.y + c.size.y);\r\n\r\n            return (\r\n                isAbove &&                  //Other object is above \r\n                isAlign &&                  //Other object is horizontally aligned \r\n                distance <= 1);             //Other object is close\r\n        }));\r\n\r\n        //Game Objects in front\r\n        ret = ret.concat(this.zPointsActive.filter(o => {\r\n\r\n            //If the comparison is invalid, skip\r\n            if(!this.checkValidComparison(c, o)) {\r\n                return false;\r\n            }\r\n\r\n            let isAhead = c.pos.x < o.pos.x;\r\n\r\n            let isAlign = col1D(\r\n                c.pos.y,\r\n                c.pos.y + c.size.y,\r\n                o.pos.y,\r\n                o.pos.y + o.size.y);\r\n\r\n            let distance = gap1D(\r\n                c.pos.x,\r\n                c.pos.x + c.size.x,\r\n                o.pos.x,\r\n                o.pos.x + o.size.x);\r\n\r\n            return (\r\n                isAhead &&                  //Other object is ahead\r\n                isAlign &&                  //Other object is vertically aligned\r\n                distance <= 1 &&            //Other object is close\r\n                !(o.flat && distance < 0)); //Overlapping with flat objects does not mean they're in front.\r\n        }));\r\n\r\n        return ret;\r\n    }\r\n\r\n    /** returns true if a comparison is valid */\r\n    public checkValidComparison(a : ZPoint, b : ZPoint) : Boolean {\r\n        \r\n        //Never sort with self\r\n        if(a === b) {\r\n            return false;\r\n        }\r\n        \r\n        //Never sort two objects marked NOCOMPARE\r\n        if(a.noCompare && b.noCompare) {\r\n            return false;\r\n        }\r\n\r\n        //Never sort two objects on different layers\r\n        if(a.layer != b.layer) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** Debug Draw */\r\n    public superDraw(ctx : CanvasRenderingContext2D) {\r\n\r\n        if (!this.debug) {\r\n            return;\r\n        }\r\n        \r\n        ctx.save();\r\n\r\n        //Position\r\n        ctx.translate(\r\n            1 * GMULTX, \r\n            2 * GMULTY\r\n        );\r\n\r\n        //Scale\r\n        let scale = 10;\r\n\r\n        //Draw background\r\n        ctx.globalAlpha = 0.5;\r\n        ctx.fillStyle = \"#000\";\r\n        ctx.fillRect(\r\n            0,\r\n            0,\r\n            BOUNDARY.maxx * scale,\r\n            BOUNDARY.maxy * scale * 2);\r\n\r\n        //Draw z-boxes\r\n        ctx.globalAlpha = 0.75;\r\n        this.zPointsActive.forEach(p => {\r\n\r\n            let border = p.size.y > 2 ? 3 : 1;\r\n\r\n            ctx.fillStyle = \r\n                p.flat       ? \"#38F\" : \r\n                p.size.y > 2 ? \"#F33\" : \"#FF3\";\r\n            ctx.fillRect(\r\n                scale * p.pos.x + border,\r\n                scale * p.pos.y + border,\r\n                scale * p.size.x - border * 2,\r\n                scale * p.size.y - border * 2);\r\n        });\r\n        \r\n        ctx.restore();\r\n    }\r\n\r\n    /** Kahn's algorithm! */\r\n    private topologicalSort() : ZPoint[] {\r\n\r\n        const sorted : ZPoint[] = [];   //Final sorted\r\n        const starts : ZPoint[] = [];   //Starting & curret set of points\r\n\r\n        //Creat map of points an their quantity of back edges\r\n        const leads = new Map(this.zPoints.map(z => [z, this.zEdges.filter(e => e[1] === z).length]));\r\n        leads.forEach((q, p) => {\r\n            if(q === 0) {\r\n                starts.push(p);\r\n            }\r\n        })\r\n\r\n        //While there are points with zero back edges\r\n        while(starts.length > 0) {\r\n\r\n            //Add current point\r\n            let curr = starts.shift()!;\r\n            sorted.push(curr);\r\n\r\n            //Subtract all back edges from the points in front\r\n            this.zEdges.filter(e => e[0] === curr).forEach(e => {\r\n                leads.set(e[1], leads.get(e[1])! - 1)\r\n\r\n                //If point has no more back edges, add it.\r\n                if(leads.get(e[1]) == 0) {\r\n                    starts.push(e[1]);\r\n                }\r\n            })\r\n        }\r\n\r\n        if(sorted.length != this.zPoints.length) {\r\n\r\n            console.log(`WARNING, LOOP in Z-SORTING, Sorted : ${sorted.length}, Expected : ${this.zPoints.length}}`);\r\n        }\r\n      \r\n        return sorted;\r\n    }\r\n}\r\n\r\n"],
  "mappings": "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",
  "names": []
}
