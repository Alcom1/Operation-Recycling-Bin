{
  "version": 3,
  "sources": ["/home/jonathan/Development/lego/Operation-Recycling-Bin/src/game/gameobjects/brickhandler.ts"],
  "sourcesContent": ["import GameObject from \"engine/gameobjects/gameobject\";\nimport Scene from \"engine/scene/scene\";\nimport {colBorderBoxGrid, col1D, GMULTX, GMULTY, colPointRectGrid, colPointParHGrid, colPointParVGrid} from \"engine/utilities/math\";\nimport Vect from \"engine/utilities/vect\";\nimport Brick from \"./brick\";\n\nexport enum BrickHandlerState {\n    /** Empty */\n    NONE,\n    /** Indeterminate */\n    INDY,\n    /** Downward */\n    DOWN,\n    /** Upward */\n    UP,\n    /** Unchanged */\n    SAME\n}\n\ninterface BrickRow {\n    /** Row (y) position */\n    row: number;\n    bricks: Brick[];\n}\n\nexport default class BrickHandler extends GameObject {\n    /** Rows of bricks */\n    private rows: BrickRow[] = [];\n    /** All bricks */\n    private bricks: Brick[] = [];\n    /** Current selected bricks */\n    public selectedBrick: Brick | null = null;\n    /** All selected bricks */\n    private selections: (Brick[] | null)[] = [];\n\n    public init(ctx: CanvasRenderingContext2D, scenes: Scene[]) {\n        // Get bricks from scene\n        this.bricks = this.engine.tag.get(\"Brick\", \"Level\") as Brick[];\n\n        // Add bricks into rows\n        this.bricks.forEach(b => this.addBrickToRows(b));\n\n        // Sort rows/bricks within rows\n        this.sortRows();\n\n        // For each brick, do a recursive check in each direction.\n        // If both directions are blocked, it's static.\n        for (const b of this.bricks) {\n            // Recurse in both directions. If both results are null, set brick to static\n            const dirs = [-1, 1] as const;\n            b.isStatic = dirs.reduce<boolean>((a, c) => a && !this.recurseBrick(b, [c], true), true);\n            // Clear recursion states after each recursive static check\n            this.bricks.forEach(b => b.clearRecursion());\n        }\n\n        // Initial stud culling\n        this.cullBrickStuds();\n    }\n\n    /** Grey bricks */\n    private get bricksGrey(): Brick[] {\n        return this.bricks.filter(b => b.isGrey == true);\n    }\n\n    /** Check selection collision, return true if this is a valid position **/\n    public checkSelectionCollision(): boolean {\n        // Adjacency states, contains if we're attaching in the indexed direction.\n        const adjacents = [];\n\n        for (const brick1 of this.bricks.filter(b => b.isSelected)) {\n            // Force update so the brick position matches this frame and not the previous\n            brick1.setToCursor();\n\n            // Combine grid positions and sub positions for true positions\n            var tposx = brick1.gpos.x + Math.round(brick1.spos.x / GMULTX);\n            var tposy = brick1.gpos.y + Math.round(brick1.spos.y / GMULTY);\n\n            // Check if this brick is inside the boundary\n            if (colBorderBoxGrid(tposx, tposy, brick1.width)) {\n                // Fail if outside boundary\n                return false;\n            }\n\n            // Check collision between current selected brick and every brick in its potential new row.\n            // For each brick in the current row\n            for (const brick2 of this.rows.find(r => r.row == tposy)?.bricks || []) {\n                // If the brick-in-row is colliding with this brick\n                if (!brick2.isSelected && col1D(\n                    tposx, tposx + brick1.width,\n                    brick2.gpos.x, brick2.gpos.x + brick2.width)\n                ) {\n                    // Fail for any collision\n                    return false;\n                }\n            }\n\n            // Check collision between current selected brick and every brick in its potential adjacent rows.\n            // For each direction\n            for (var dir of [-1, 1]) {\n                // If row in the direction (above/below) has bricks, check each brick\n                // For each brick in the row in that direction\n                for (var brick2 of this.rows.find(r => r.row == tposy + dir)?.bricks || []) {\n                    // If the brick-in-row is colliding with this brick\n                    if (!brick2.isSelected && col1D(\n                        tposx, tposx + brick1.width,\n                        brick2.gpos.x, brick2.gpos.x + brick2.width)\n                    ) {\n                        // Set adjacency state for this direction.\n                        adjacents[dir] = true;\n                        // Check other direction.\n                        break;\n                    }\n                }\n            }\n        }\n\n        // We need to attach in one direction but not both. Return true if we are attaching in a single direction.\n        // If adjacency states are different, return true\n        return adjacents[-1] != adjacents[1];\n    }\n\n    /** Disable studs that are covered */\n    cullBrickStuds(): void {\n        // For each stud in unselected bricks\n        for (const stud of this.bricks.filter(b => !b.isSelected).flatMap(b => b.studs)) {\n            stud.isVisible = true;\n\n            // For each brick in this stud's row\n            for (const brick of this.rows.find(r => r.row == stud.gpos.y)?.bricks || []) {\n                if (\n                    // Don't cull selected bricks\n                    !brick.isSelected\n                    // Don't cull pressed bricks\n                    && !brick.isPressed\n                    // Only cull bricks overlapping with this stud\n                    && col1D(\n                        brick.gpos.x - 1, \n                        brick.gpos.x + brick.width, \n                        stud.gpos.x, \n                        stud.gpos.x\n                    )\n                ) {\n                    stud.isVisible = false;\n                    // Stop all checks once the stud is hidden\n                    break;\n                }\n            }\n        }\n\n        // Always show studs for selected bricks\n        this.bricks.filter(b => b.isSelected).flatMap(b => b.studs).forEach(s => s.isVisible = true);\n    }\n\n    /** Set the minimum and maximum position for selected bricks */\n    public setSelectedMinMax(): void {\n        const selected = this.bricks.filter(b => b.isSelected);\n\n        // Minimum brick position among selected bricks\n        const boundaryMin = new Vect(\n            Math.min(...selected.map(b => b.gpos.x)),\n            Math.min(...selected.map(b => b.gpos.y))\n        );\n        \n        //Maximum brick position among selected bricks\n        const boundaryMax = new Vect(\n            // Width included for proper boundary\n            Math.max(...selected.map(b => b.gpos.x + b.width)),\n            // Height included for proper boundary\n            Math.max(...selected.map(b => b.gpos.y + 1))\n        );\n\n        // Set min-max for all selected bricks based on boundary\n        selected.forEach(b => b.setMinMax(boundaryMin, boundaryMax));\n    }\n\n    /** Set snapped state of selected bricks */\n    public setSnappedBricks(state: boolean): void {\n        // For each selected brick, set its snap to the given state\n        this.bricks.filter(b => b.isSelected).forEach(b => b.snap(state));\n    }\n\n    /** Deselect all bricks */\n    public deselectBricks(): void {\n        this.selectedBrick = null;\n        this.selections = [];\n        this.bricks.forEach(b => b.deselect());\n\n        //Move bricks to the new row\n        this.rows.forEach(r => {                                //For each row\n            var move = r.bricks.filter(b => b.gpos.y != r.row); //Get move-bricks that are no longer in this row\n            r.bricks = r.bricks.filter(b => b.gpos.y == r.row); //Remove bricks that are no longer in this row\n            move.forEach(b => this.addBrickToRows(b));          //For each move-brick, add it to its new row\n        });\n\n        //Sort\n        this.sortRows();\n    }\n\n    /** Add a brick to a row, and create that row if it doesn't exist. */\n    private addBrickToRows(brick: Brick): void {\n        const currRow = this.rows.find(r => r.row == brick.gpos.y);\n\n        // Create a new row or add a brick to the existing row\n        if(currRow == null) {\n            this.rows.push({\n                // Set new row position to its first brick's position\n                row : brick.gpos.y,\n                bricks : [brick]\n            });\n        } else {\n            currRow.bricks.push(brick);\n        }\n    }\n\n    /** Sort bricks */\n    private sortRows(): void {\n        // Sort rows by row value\n        this.rows.sort((a, b) => a.row > b.row ? 1 : 0);\n\n        // Sort bricks in each row by x-position\n        this.rows.forEach(r => r.bricks.sort((a, b) => a.gpos.x > b.gpos.x ? 1 : 0));\n    }\n\n    /** Check all bricks for hover, return hover state */\n    public hoverBricks(pos: Vect): BrickHandlerState {\n        // Check all bricks and return if the first successful check is not static\n        return this.checkBricks(pos, (b, p) => this.hoverBrick(b, p)) || BrickHandlerState.NONE;\n    }\n\n    /** Check all bricks for a mouse position and return the result of a function against that brick and position */\n    private checkBricks<T>(pos: Vect, func: (brick: Brick, pos: Vect) => T): T | null {\n        // Front face check\n        for (const brick of this.bricks) {\n            //Front face - if position is over this face\n            if (colPointRectGrid(\n                pos.x,\n                pos.y,\n                brick.gpos.x,\n                brick.gpos.y,\n                brick.width\n            )) {\n                return func(brick, pos);\n            }\n        }\n\n        // Top and side face check\n        for (var brick of this.bricks) {\n            if (\n                // Top Face - if position is over this face\n                colPointParHGrid(\n                    pos.x,\n                    pos.y,\n                    brick.gpos.x,\n                    brick.gpos.y,\n                    brick.width\n                )\n                // Side Face - if position is over this face\n                || colPointParVGrid(\n                    pos.x,\n                    pos.y,\n                    brick.gpos.x,\n                    brick.gpos.y,\n                    brick.width\n                )\n            ) {\n                return func(brick, pos);\n            }\n        }\n\n        // There is no brick under this position.\n        return null;    \n    }\n\n    /** Press a single brick */\n    private hoverBrick(brick: Brick, pos: Vect): BrickHandlerState {\n        // Do nothing if the two bricks are the same\n        if (this.selectedBrick != null && this.selectedBrick.compare(brick)) {\n            return BrickHandlerState.SAME;\n        }\n\n        // Set current selected brick for later use\n        this.selectedBrick = brick;\n        // Reset selections\n        this.selections = [];\n\n        // Check both directions if they're valid (valid == not null)\n        const dirs = [-1, 1] as const;\n        for (const dir of dirs) {\n            // Recurse in that direction. Assign result to valid directions.\n            this.selections[dir] = this.recurseBrick(brick, [dir], true);\n        }\n        // Clear recursion states after both recursive direction checks\n        this.bricks.forEach(b => b.clearRecursion());\n\n        return this.selections[-1] && \n            // If both selections are valid, return indeterminate state\n            this.selections[1]  ? BrickHandlerState.INDY :\n            // If upward selection is valid, return up state\n            this.selections[-1] ? BrickHandlerState.UP :\n            // If downward selection is valid, return down state\n            this.selections[1]  ? BrickHandlerState.DOWN :\n            // No direction is valid. Return no state\n            BrickHandlerState.NONE;\n    }\n\n    /**\n     * Check all bricks for press, return press state (none, processed, indeterminate)\n     * This entire function is bananas.\n     */\n    public pressBricks(pos: Vect): boolean {\n        // Build an normal array of selections that are not null (invalid)\n        // Filter to remove null (invalid) selections\n        const validSelections = [\n            this.selections[-1], \n            this.selections[1]\n        ].filter(s => s);\n\n        // If there is a single valid selection, use and auto-process it\n        if (validSelections.length == 1) {\n            // Process this selection using bricks in truthy direction, and the position.\n            return this.processSelection(validSelections[0], pos);\n        }\n\n        // For the indeterminate state, just press this brick\n        if (this.selectedBrick) {\n            this.selectedBrick.press();\n        }\n\n        // Return falsy for indeterminate state\n        return false;\n    }\n\n    /** Set bricks to selected based on a provided cursor position */\n    public initSelection(pos: Vect, dir: -1 | 1) {\n        return this.processSelection(this.selections[dir], pos);\n    }\n    \n    /**\n     * Process a selection, set all its bricks to a selected state,\n     * search for floating bricks, return if bricks were selected\n     */\n    private processSelection(selection: Brick[] | null, pos: Vect) {\n        // Select bricks\n        selection?.forEach(b => b.select(pos));\n\n        // Mark all bricks that lead to a grey brick as grounded (not floating).\n        if (selection != null) {\n            for (const brick of this.bricksGrey) {\n                // If the grey brick isn't checked (Reduces redundancy)\n                if (!brick.isChecked) {\n                    this.recurseBrick(brick, [-1, 1], false)?.forEach(c => c.isGrounded = true);\n                }\n            }\n\n            // Select floating bricks and clear recursion states\n            for (const brick of this.bricks) {\n                if (!brick.isGrounded && !brick.isSelected) {\n                    brick.select(pos);\n                }\n                brick.clearRecursion();\n            }\n        }\n\n        return !!selection;\n    }\n\n    /** Recursively select bricks. */\n    private recurseBrick(brick1: Brick, dirs: (-1 | 1)[], checkGrey: boolean) {\n        // Return nothing for grey bricks\n        if (checkGrey && brick1.isGrey) {\n            return null;\n        }\n\n        brick1.isChecked = true;\n\n        // Current brick is a new brick in the selection\n        let selection = [brick1];\n\n        // For all directions, check adjacent bricks in that direction and recurse for each brick\n        for (const dir of dirs) {\n            // If adjacent row in the direction (above/below) has bricks, check and recurse for each brick\n            for (const brick2 of this.rows.find(r => r.row == brick1.gpos.y + dir)?.bricks || []) {\n                if (!brick2.isChecked && col1D(\n                    brick1.gpos.x, brick1.gpos.x + brick1.width, \n                    brick2.gpos.x, brick2.gpos.x + brick2.width\n                )) {\n                    // Recursively check the new brick and add the results to the current selection\n                    const result = this.recurseBrick(brick2, dirs, checkGrey);\n\n                    if (result) {\n                        selection = selection.concat(result);\n                    } else {\n                        return null;\n                    }\n                }\n            }\n        }\n\n        return selection;\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
