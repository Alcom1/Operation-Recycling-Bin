{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\brickhandler.ts"],
  "sourcesContent": ["import GameObject from \"engine/gameobjects/gameobject\";\r\nimport {col1D, GMULTX, GMULTY, colBoundingBoxGrid, colPointRectGrid, colPointParHGrid, colPointParVGrid, OPPOSITE_DIRS, colRectRectCornerSize, MatchFactions, Faction} from \"engine/utilities/math\";\r\nimport Vect, { Point } from \"engine/utilities/vect\";\r\nimport Brick from \"./bricknormal\";\r\nimport CharacterHandler from \"./characterhandler\";\r\nimport Counter from \"./counter\";\r\nimport MobileIndicator from \"./mobileindicator\";\r\n\r\n/** States for the brick handler's selection */\r\nexport enum BrickHandlerState {\r\n    /** Empty */\r\n    NONE,\r\n    /** Indeterminate */\r\n    INDY,\r\n    /** Downward */\r\n    DOWN,\r\n    /** Upward */\r\n    UP,\r\n    /** Unchanged */\r\n    SAME\r\n}\r\n\r\n/** A row of bricks */\r\ninterface BrickRow {\r\n    /** Row (y) position */\r\n    row: number;\r\n    bricks: Brick[];\r\n}\r\n\r\n/** Handler for brick selection, movement, etc. */\r\nexport default class BrickHandler extends GameObject {\r\n\r\n    /** */\r\n    private counter!: Counter;\r\n\r\n    /** All bricks */\r\n    protected bricks: Brick[] = [];\r\n\r\n    /** */\r\n    private characterHandler : CharacterHandler | null = null;\r\n\r\n    /** */\r\n    private mobileIndicator : MobileIndicator | null = null;\r\n\r\n    /** Current selected bricks */\r\n    public selectedBrick: Brick | null = null;\r\n\r\n    /** All selected bricks */\r\n    private selections: (Brick[] | null)[] = [];\r\n\r\n    /** Active bricks */\r\n    private get bricksActive() { return this.bricks.filter(b => b.isActive && !b.isSelected); }\r\n\r\n    /** Grey bricks */\r\n    private get bricksGrey(): Brick[] { return this.bricks.filter(b => b.isActive && b.isGrey && !b.isBlock); }\r\n\r\n    /** Initalize the brick handler, get related bricks & game objects, manage bricks */\r\n    public init(ctx: CanvasRenderingContext2D) {\r\n        \r\n        this.characterHandler = this.engine.tag.get(        // Get character handler from scene\r\n            \"CharacterHandler\", \r\n            \"LevelInterface\")[0] as CharacterHandler;\r\n        this.mobileIndicator = this.engine.tag.get(         // Get mobile indicator from scene\r\n            \"MobileIndicator\", \r\n            \"LevelInterface\")[0] as MobileIndicator;\r\n        this.counter = this.engine.tag.get(                 // Get counter from scene\r\n            \"Counter\", \r\n            \"LevelInterface\")[0] as Counter;       \r\n        this.bricks = this.engine.tag.get(                  // Get bricks from scene\r\n            \"Brick\", \r\n            \"Level\") as Brick[];\r\n\r\n        // Check for and log overlapping bricks\r\n        this.bricks.forEach((b1, j) => {\r\n\r\n            for(let i = j + 1; i < this.bricks.length; i++) {\r\n                let b2 = this.bricks[i];\r\n\r\n                // If this brick overlaps with the previous, log it.\r\n                if (b1.gpos.y == b2.gpos.y && col1D(\r\n                    b1.gpos.x, b1.gpos.x + b1.width, \r\n                    b2.gpos.x, b2.gpos.x + b2.width)) {\r\n                    console.log(`OVERLAPPING BRICK AT {\"x\" : ${b1.gpos.x}, \"y\" : ${b1.gpos.y}}`);\r\n                }\r\n            }\r\n        })\r\n\r\n        // For each brick, do a recursive check in each direction.\r\n        // If both directions are blocked, it's static.\r\n        for (const b of this.bricks) {\r\n\r\n            // Recurse in both directions. If both results are null, set brick to static\r\n            b.isStatic = (OPPOSITE_DIRS).reduce<boolean>((a, c) => a && !this.recurseBrick(b, [c], true), true);\r\n\r\n            // Clear recursion states after each recursive static check\r\n            this.bricks.forEach(b => b.clearRecursion());\r\n        }\r\n\r\n        this.cullBrickStuds();  // Initial stud culling\r\n    }\r\n\r\n    /** Check selection collision, return true if this is a valid position **/\r\n    public checkCollisionSelection(): boolean {\r\n\r\n        const adjacents = [];       // Adjacency states, contains if we're attaching in the indexed direction.\r\n\r\n        const min : Point = {x : Number.MAX_VALUE, y : Number.MAX_VALUE}\r\n        const max : Point = {x : 0, y : 0}\r\n\r\n        let noPlaceZones = this.characterHandler?.getNoPlaceZones();\r\n\r\n        let isBlocked = false;  //If the selection is blocked by a blocking brick\r\n\r\n        brickLoop : for (const brick1 of this.bricks.filter(b => b.isSelected)) {\r\n            \r\n            brick1.setToCursor();   // Force update so the brick position matches this frame and not the previous\r\n\r\n            // Combine grid positions and sub positions for true positions\r\n            var tposx = brick1.gpos.x + Math.round(brick1.spos.x / GMULTX);\r\n            var tposy = brick1.gpos.y + Math.round(brick1.spos.y / GMULTY);\r\n\r\n            //Do not place bricks in no-place zones (gliding bricks/characters are handled by this, instead)\r\n            if (noPlaceZones?.some(p => \r\n                p.y == tposy &&\r\n                p.x >= tposx &&\r\n                p.x <  tposx + brick1.width)) {\r\n\r\n                return false;\r\n            }\r\n\r\n            // Store minimum and maximum positions for a bounding box\r\n            min.x = Math.min(min.x, tposx);\r\n            min.y = Math.min(min.y, tposy);\r\n            max.x = Math.max(max.x, tposx + brick1.width);\r\n            max.y = Math.max(max.y, tposy + 1);\r\n\r\n            // Check collision between current selected brick and every brick in its potential new row.\r\n            for (const brick2 of this.bricksActive.filter(b => !b.isGlide && b.gpos.y == tposy)) { // For each non-gliding brick in the current row\r\n                \r\n                if (!brick2.isSelected && col1D(        // If the brick-in-row is colliding with this brick\r\n                    tposx, tposx + brick1.width,\r\n                    brick2.gpos.x, brick2.gpos.x + brick2.width)) {\r\n                        \r\n                    return false;                       // Fail for any collision\r\n                }\r\n            }\r\n\r\n            // Check collision between current selected brick and every brick in its potential adjacent rows.\r\n            for (var dir of OPPOSITE_DIRS) {            // For each direction\r\n\r\n                // If row in the direction (above/below) has bricks, check each brick\r\n                // For each brick in the row in that direction\r\n                for (var brick2 of this.bricksActive.filter(b => !b.isGlide && b.gpos.y == tposy + dir)) {\r\n                    \r\n                    if (!brick2.isSelected && col1D(    // If the brick-in-row is colliding with this brick\r\n                        tposx, tposx + brick1.width,\r\n                        brick2.gpos.x, brick2.gpos.x + brick2.width)) {\r\n\r\n                        adjacents[dir] = true;          // Set adjacency state for this direction.\r\n                        \r\n                        //There is a blocking brick, set state and break out of the loop\r\n                        if (brick2.isBlock) {\r\n                            isBlocked = true;\r\n                            break brickLoop;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //Selection is blocked, return false\r\n        if(isBlocked) {\r\n            return false;\r\n        }\r\n\r\n        // LEVEL BOUNDARY CHECK - Check if this brick is inside the boundary\r\n        if (colBoundingBoxGrid(min, max)) {\r\n            return false;       // Fail if outside boundary\r\n        }\r\n\r\n        // We need to attach in one direction but not both. Return true if we are attaching in a single direction.\r\n        // If adjacency states are different, return true\r\n        return adjacents[-1] != adjacents[1];\r\n    }\r\n\r\n    /** Check collisons for a vertically-looping range and return a bitmask */\r\n    public checkCollisionRange(\r\n        pos: Point, \r\n        dir: number, \r\n        start: number, \r\n        final: number, \r\n        height: number, \r\n        width: number = 2,\r\n        faction: Faction = Faction.NEUTRAL): number {\r\n\r\n        let collisions = 0; // Collision bitbask\r\n\r\n        for(let i = start; i < final; i++) {\r\n\r\n            let y = i % height;                     // Wrap by height\r\n            let x = Math.floor(i / height) % width; // Wrap by width to go back and check ceiling\r\n\r\n            for (const brick of this.bricksActive.filter(\r\n                b => b.gpos.y == pos.y + y + 1 && \r\n                MatchFactions(b.faction, faction))) {\r\n\r\n                if (col1D(\r\n                    brick.gpos.x - 1, \r\n                    brick.gpos.x + brick.width, \r\n                    pos.x + x * dir,\r\n                    pos.x + x * dir\r\n                )) {\r\n                    collisions += 1 << (i - start);\r\n                }\r\n            }\r\n        }\r\n\r\n        return collisions;\r\n    }\r\n\r\n    /** Check collisons for a square ring and return a bitmask */\r\n    public checkCollisionRing(pos: Point, size: number, dir : number = 1, overhang : boolean = true) {\r\n\r\n        let collisions = 0; // Collision bitbask\r\n        let count = 0;      // Count gridspaces being checked\r\n        let row : Brick[] = [];\r\n\r\n        // Vertical travel\r\n        for(let j = pos.y; j < pos.y + size; j++) {\r\n\r\n            // Get this row\r\n            row = this.bricksActive.filter(b => b.gpos.y == j && !b.isSelected);\r\n\r\n            // Horizontal travel, skip to end unless this is the first or last row to create a ring shape\r\n            for(let i = pos.x; i < pos.x + size; i += ((j > pos.y && j < pos.y + size - 1) ? size - 1 : 1)) {\r\n\r\n                // Reverse horizontally if the direction isn't positive.\r\n                let check = dir > 0 ? i : 2 * pos.x - i + size - 1;\r\n\r\n                // Check each brick int his row.\r\n                row.forEach(brick => {\r\n\r\n                    if (col1D(\r\n                        brick.gpos.x - 1, \r\n                        brick.gpos.x + brick.width,\r\n                        check,\r\n                        check\r\n                    )) {\r\n                        collisions += 1 << (count);\r\n                    }\r\n                });\r\n\r\n                count++;\r\n            }\r\n        }\r\n\r\n        //Single overhang space\r\n        if(overhang) {\r\n\r\n            //x-pos of new space\r\n            let check = dir > 0 ? pos.x + size : pos.x - 1;\r\n\r\n            // Check each brick int his row.\r\n            row.forEach(brick => {\r\n\r\n                if (col1D(\r\n                    brick.gpos.x - 1, \r\n                    brick.gpos.x + brick.width,\r\n                    check,\r\n                    check\r\n                )) {\r\n                    collisions += 1 << (count);\r\n                }\r\n            });\r\n\r\n            count++;\r\n        }\r\n\r\n        return collisions;\r\n    }\r\n\r\n    /** Check collisions for a row and return the colliding bricks */\r\n    public checkCollisionRow(pos: Vect, width: number): Brick[] {\r\n\r\n        let bricks : Brick[] = [];\r\n\r\n        for (const brick of this.bricks.filter(b => b.gpos.y == pos.y && !b.isSelected) || []) {\r\n\r\n            if (col1D(\r\n                brick.gpos.x, \r\n                brick.gpos.x + brick.width, \r\n                pos.x,\r\n                pos.x + width\r\n            )) {\r\n\r\n                bricks.push(brick);\r\n            }\r\n        }\r\n\r\n        return bricks;\r\n    }\r\n\r\n    /** Disable studs that are covered */\r\n    public cullBrickStuds(): void {\r\n\r\n        this.bricks.filter(b => !b.isSelected && b.hasTag(\"BrickNormal\")).forEach(b1 => {\r\n\r\n            // Hide studs based on above row\r\n            b1.hideStuds(this.bricks.filter(b2 => b2.gpos.y == b1.gpos.y - 1 && b2.hasTag(\"BrickNormal\")))\r\n        });\r\n\r\n        // Always show studs for selected bricks\r\n        this.bricks.filter(b => b.isSelected && b.hasTag(\"BrickNormal\")).forEach(b => b.showStuds());\r\n    }\r\n\r\n    /** Set the minimum and maximum position for selected bricks */\r\n    public setSelectedMinMax(spos: Vect): void {\r\n        const selected = this.bricks.filter(b => b.isSelected);\r\n\r\n        // Minimum brick position among selected bricks\r\n        const boundaryMin = new Vect(\r\n            Math.min(...selected.map(b => b.gpos.x)),\r\n            Math.min(...selected.map(b => b.gpos.y))\r\n        );\r\n        \r\n        // Maximum brick position among selected bricks\r\n        const boundaryMax = new Vect(\r\n            Math.max(...selected.map(b => b.gpos.x + b.width)), // Width included for proper boundary\r\n            Math.max(...selected.map(b => b.gpos.y + 1))        // Height included for proper boundary\r\n        );\r\n\r\n        // Set min-max for all selected bricks based on boundary\r\n        selected.forEach(b => b.setMinMax(boundaryMin, boundaryMax));\r\n        this.mobileIndicator?.setMinMax(boundaryMin, boundaryMax);\r\n    }\r\n\r\n    /** Set snapped state of selected bricks */\r\n    public setSnappedBricks(state: boolean): void {\r\n\r\n        // For each selected brick, set its snap to the given state\r\n        this.bricks.filter(b => b.isSelected).forEach(b => b.snap(state));\r\n        this.mobileIndicator?.snap(state);\r\n    }\r\n\r\n    /** Deselect all bricks */\r\n    public deselectBricks(): void {\r\n\r\n        this.selectedBrick = null;\r\n        this.selections = [];\r\n        this.bricks.forEach(b => b.deselect());\r\n\r\n        // Disable mobile indicator\r\n        this.mobileIndicator!.isActive = false;\r\n    }\r\n\r\n    /** Check all bricks for hover, return hover state */\r\n    public hoverBricks(pos: Vect): BrickHandlerState {\r\n\r\n        // Check all bricks and return if the first successful check is not static\r\n        return this.checkBricks(pos, (b, p) => this.hoverBrick(b, p)) || BrickHandlerState.NONE;\r\n    }\r\n\r\n    /** Check all bricks for a mouse position and return the result of a function against that brick and position */\r\n    private checkBricks<T>(pos: Vect, func: (brick: Brick, pos: Vect) => T): T | null {\r\n\r\n        // Front face check\r\n        for (const brick of this.bricksActive) {\r\n\r\n            // Front face - if position is over this face\r\n            if (colPointRectGrid(\r\n                pos.x,\r\n                pos.y,\r\n                brick.gpos.x,\r\n                brick.gpos.y,\r\n                brick.width\r\n            )) {\r\n                return func(brick, pos);\r\n            }\r\n        }\r\n\r\n        // Top and side face check\r\n        for (var brick of this.bricksActive) {\r\n            if (// Top Face - if position is over this face\r\n                colPointParHGrid(\r\n                    pos.x,\r\n                    pos.y,\r\n                    brick.gpos.x,\r\n                    brick.gpos.y,\r\n                    brick.width\r\n                ) ||\r\n                // Side Face - if position is over this face\r\n                colPointParVGrid(\r\n                    pos.x,\r\n                    pos.y,\r\n                    brick.gpos.x,\r\n                    brick.gpos.y,\r\n                    brick.width\r\n                )) {\r\n\r\n                return func(brick, pos);\r\n            }\r\n        }\r\n\r\n        // There is no brick under this position.\r\n        return null;    \r\n    }\r\n\r\n    /** Press a single brick */\r\n    private hoverBrick(brick: Brick, pos: Vect): BrickHandlerState {\r\n\r\n        this.selectedBrick = brick; // Set current selected brick for later use\r\n        this.selections = [];       // Reset selections\r\n\r\n        //Dp not proceed if the currently selected brick is blocked\r\n        if(this.checkBrickIsBlocked(this.selectedBrick)) {\r\n\r\n            return BrickHandlerState.NONE;\r\n        }\r\n\r\n        // Check both directions if they're valid (valid == not null)\r\n        for (const dir of OPPOSITE_DIRS) {\r\n\r\n            let selectionNew = this.recurseBrick(brick, [dir], true) ?? [];\r\n\r\n            // If there are bricks to select\r\n            if (selectionNew!.length > 0) {\r\n\r\n                //Add floating bricks to selection\r\n                selectionNew = selectionNew.concat(this.getFloatingBricks());\r\n\r\n                //Validate that none of the selected bricks are blocked\r\n                let isAnyBlocked = selectionNew.some(b => this.checkBrickIsBlocked(b));\r\n\r\n                //Add floating bricks to direction's selection\r\n                this.selections[dir] = !isAnyBlocked ? selectionNew : null;\r\n            }\r\n\r\n            // Clear recursion states after each recursive direction check\r\n            this.bricksActive.forEach(b => b.clearRecursion());\r\n        }\r\n\r\n        return this.selections[-1] && \r\n            this.selections[1]  ? BrickHandlerState.INDY :  // If both selections are valid, return indeterminate state\r\n            this.selections[-1] ? BrickHandlerState.UP :    // If upward selection is valid, return up state\r\n            this.selections[1]  ? BrickHandlerState.DOWN :  // If downward selection is valid, return down state\r\n            BrickHandlerState.NONE;                         // No direction is valid. Return no state\r\n    }\r\n\r\n    /** Check if a single brick is being blocked by a character */\r\n    private checkBrickIsBlocked(brick : Brick) : boolean {\r\n\r\n        //Row above for brick being evaluated\r\n        for (const brick2 of this.bricksActive.filter(b => b.gpos.y == brick.gpos.y - 1)) {\r\n\r\n            if (brick2.isBlock &&   // If a brick in the other row is blocking\r\n                col1D(              // And it overlaps with the current brick\r\n                    brick.gpos.x, brick.gpos.x + brick.width, \r\n                    brick2.gpos.x, brick2.gpos.x + brick2.width)) {\r\n                \r\n                return true;        // Return true\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Return floating bricks after a selection */\r\n    private getFloatingBricks(): Brick[] {\r\n        \r\n        var ret : Brick[] = [];\r\n\r\n        // Recursively check from all grey bricks and mark connected bricks as grounded\r\n        for (const brick of this.bricksGrey) {\r\n\r\n            // If the grey brick isn't checked (Reduces redundancy)\r\n            if (!brick.isChecked) {\r\n                this.recurseBrick(brick, OPPOSITE_DIRS, false)?.forEach(c => c.isGrounded = true);\r\n            }\r\n        }\r\n\r\n        // Select active floating bricks and clear recursion states\r\n        // Stop trying to move the selected check! You know why it's there! (I've forgotten why it's there.)\r\n        for (const brick of this.bricksActive) {\r\n\r\n            //If the brick isn't grounded or selected, it's floating! Add it.\r\n            if (!brick.isGrounded && !brick.isSelected && !brick.isBlock) {\r\n                ret.push(brick);\r\n            }\r\n\r\n            //Clear stored recursive results in brick\r\n            brick.clearRecursion();\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /** \r\n     * Check all bricks for press, return press state (none, processed, indeterminate)\r\n     * This entire function is bananas.\r\n    */\r\n    public pressBricks(pos: Vect): boolean {\r\n\r\n        // Build an array of selections that are not null (invalid)\r\n        // Filter to remove null (invalid) selections\r\n        const validSelections = OPPOSITE_DIRS.map(d => this.selections[d]).filter(s => s);\r\n\r\n        // If there is a single valid selection, use and auto-process it\r\n        if (validSelections.length == 1) {\r\n            // Process this selection using bricks in truthy direction, and the position.\r\n            return this.processSelection(validSelections[0], pos);\r\n        }\r\n\r\n        // For the indeterminate state, just press the currently selected brick\r\n        if (this.selectedBrick) {\r\n            this.selectedBrick.press();\r\n        }\r\n\r\n        // Return falsy for indeterminate state\r\n        return false;\r\n    }\r\n\r\n    /** Set bricks to selected based on a provided cursor position */\r\n    public initSelection(pos: Vect, dir: -1 | 1) {\r\n        \r\n        return this.processSelection(this.selections[dir], pos);\r\n    }\r\n    \r\n    /** \r\n     * Process a selection, set all its bricks to a selected state,\r\n     * search for floating bricks, return if bricks were selected\r\n    */\r\n    private processSelection(selection: Brick[] | null, pos: Vect) {\r\n\r\n        // Select bricks\r\n        selection?.forEach(b => b.select(pos));\r\n\r\n        this.mobileIndicator!.cursorPosition = pos;\r\n\r\n        this.counter.incrementCount();\r\n\r\n        return !!selection;\r\n    }\r\n\r\n    /** Recursively select bricks. */\r\n    private recurseBrick(brick1: Brick, dirs: (-1 | 1)[], checkGrey: boolean) {\r\n\r\n        // Return nothing for grey bricks\r\n        if (checkGrey && brick1.isGrey) {\r\n            return null;\r\n        }\r\n\r\n        brick1.isChecked = true;\r\n\r\n        // Current brick is a new brick in the selection\r\n        let selection = [brick1];\r\n\r\n        // Recursion should not progress past blocking bricks\r\n        if (brick1.isBlock) {\r\n            return selection;\r\n        }\r\n\r\n        // For all directions, check adjacent bricks in that direction and recurse for each brick\r\n        for (const dir of dirs) {\r\n\r\n            // If adjacent row in the direction (above/below) has bricks, check and recurse for each brick\r\n            // Also, skip blocking bricks, so characters do not interfere (Does this break something?)\r\n            for (const brick2 of this.bricksActive.filter(b => !b.isBlock && b.gpos.y == brick1.gpos.y + dir)) {\r\n\r\n                if (!brick2.isChecked && col1D(\r\n                    brick1.gpos.x, brick1.gpos.x + brick1.width, \r\n                    brick2.gpos.x, brick2.gpos.x + brick2.width)) {\r\n                    \r\n                    // Recursively check the new brick and add the results to the current selection\r\n                    const result = this.recurseBrick(brick2, dirs, checkGrey);\r\n\r\n                    if (result) {\r\n                        selection = selection.concat(result);\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return selection;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
