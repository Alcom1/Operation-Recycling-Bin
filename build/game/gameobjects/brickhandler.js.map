{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\brickhandler.ts"],
  "sourcesContent": ["import GameObject from \"engine/gameobjects/gameobject\";\r\nimport {colBorderBoxGrid, col1D, GMULTX, GMULTY, colPointRectGrid, colPointParHGrid, colPointParVGrid, OPPOSITE_DIRS} from \"engine/utilities/math\";\r\nimport Vect from \"engine/utilities/vect\";\r\nimport Brick from \"./brick\";\r\n\r\nexport enum BrickHandlerState {\r\n    /** Empty */\r\n    NONE,\r\n    /** Indeterminate */\r\n    INDY,\r\n    /** Downward */\r\n    DOWN,\r\n    /** Upward */\r\n    UP,\r\n    /** Unchanged */\r\n    SAME\r\n}\r\n\r\ninterface BrickRow {\r\n    /** Row (y) position */\r\n    row: number;\r\n    bricks: Brick[];\r\n}\r\n\r\nexport default class BrickHandler extends GameObject {\r\n    /** Rows of bricks */\r\n    private rows: BrickRow[] = [];\r\n    /** All bricks */\r\n    private bricks: Brick[] = [];\r\n    /** Current selected bricks */\r\n    public selectedBrick: Brick | null = null;\r\n    /** All selected bricks */\r\n    private selections: (Brick[] | null)[] = [];\r\n    /** Grey bricks */\r\n    private get bricksGrey(): Brick[] {\r\n        return this.bricks.filter(b => b.isGrey == true);\r\n    }\r\n    /** If a brick has been stepped on or off */\r\n    public isPressured = true;\r\n\r\n    public init(ctx: CanvasRenderingContext2D) {\r\n        \r\n        this.bricks = this.engine.tag.get(\"Brick\", \"Level\") as Brick[]; // Get bricks from scene\r\n        this.bricks.forEach(b => this.addBrickToRows(b));               // Add bricks into rows\r\n        this.sortRows();                                                // Sort rows/bricks within rows\r\n\r\n        //Check for and log overlapping bricks\r\n        this.rows.forEach(r => r.bricks.forEach((b1, i) => {\r\n            \r\n            var b2 = r.bricks[i - 1];\r\n\r\n            // If this brick overlaps with the previous, log it.\r\n            if(i > 0 && col1D(\r\n                b1.gpos.x, b1.gpos.x + b1.width, \r\n                b2.gpos.x, b2.gpos.x + b2.width)) {\r\n                console.log(`OVERLAPPING BRICK AT {\"x\" : ${b1.gpos.x}, \"y\" : ${r.row}}`);\r\n            }\r\n        }));\r\n\r\n        // For each brick, do a recursive check in each direction.\r\n        // If both directions are blocked, it's static.\r\n        for (const b of this.bricks) {\r\n\r\n            // Recurse in both directions. If both results are null, set brick to static\r\n            b.isStatic = (OPPOSITE_DIRS).reduce<boolean>((a, c) => a && !this.recurseBrick(b, [c], true), true);\r\n\r\n            // Clear recursion states after each recursive static check\r\n            this.bricks.forEach(b => b.clearRecursion());\r\n        }\r\n\r\n        this.cullBrickStuds();  // Initial stud culling\r\n    }\r\n\r\n    /** Check a batch of grid-spaces for collision and return a bitmask of those spaces **/\r\n    public checkCollisionSelection(): boolean {\r\n\r\n        const adjacents = [];       // Adjacency states, contains if we're attaching in the indexed direction.\r\n\r\n        for (const brick1 of this.bricks.filter(b => b.isSelected)) {\r\n            \r\n            brick1.setToCursor();   // Force update so the brick position matches this frame and not the previous\r\n\r\n            // Combine grid positions and sub positions for true positions\r\n            var tposx = brick1.gpos.x + Math.round(brick1.spos.x / GMULTX);\r\n            var tposy = brick1.gpos.y + Math.round(brick1.spos.y / GMULTY);\r\n\r\n            // Check if this brick is inside the boundary\r\n            if (colBorderBoxGrid(tposx, tposy, brick1.width)) {\r\n                return false;       // Fail if outside boundary\r\n            }\r\n\r\n            // Check collision between current selected brick and every brick in its potential new row.\r\n            for (const brick2 of this.rows.find(r => r.row == tposy)?.bricks || []) { // For each brick in the current row\r\n                \r\n                if (!brick2.isSelected && col1D(        // If the brick-in-row is colliding with this brick\r\n                    tposx, tposx + brick1.width,\r\n                    brick2.gpos.x, brick2.gpos.x + brick2.width)) {\r\n                        \r\n                    return false;                       // Fail for any collision\r\n                }\r\n            }\r\n\r\n            // Check collision between current selected brick and every brick in its potential adjacent rows.\r\n            for (var dir of OPPOSITE_DIRS) {             // For each direction\r\n\r\n                // If row in the direction (above/below) has bricks, check each brick\r\n                // For each brick in the row in that direction\r\n                for (var brick2 of this.rows.find(r => r.row == tposy + dir)?.bricks || []) {\r\n                    \r\n                    if (!brick2.isSelected && col1D(    // If the brick-in-row is colliding with this brick\r\n                        tposx, tposx + brick1.width,\r\n                        brick2.gpos.x, brick2.gpos.x + brick2.width)) {\r\n\r\n                        adjacents[dir] = true;          // Set adjacency state for this direction.\r\n                        break;                          // Check other direction.\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // We need to attach in one direction but not both. Return true if we are attaching in a single direction.\r\n        // If adjacency states are different, return true\r\n        return adjacents[-1] != adjacents[1];\r\n    }\r\n\r\n    /** Check collisons for a vertically-looping range and return a bitmask */\r\n    public checkCollisionSuper(pos: Vect, start: number, final: number, height: number, dir: number): number {\r\n\r\n        let collisions = 0;\r\n\r\n        for(let i = start; i < final; i++) {\r\n\r\n            let y = i % height;\r\n            let x = Math.floor(i / height);\r\n\r\n            for (const brick of this.rows.find(r => r.row == pos.y + y + 1)?.bricks.filter(b => !b.isSelected) || []) {\r\n\r\n                if(col1D(\r\n                    brick.gpos.x - 1, \r\n                    brick.gpos.x + brick.width, \r\n                    pos.x + x * dir,\r\n                    pos.x + x * dir\r\n                )) {\r\n                    collisions += 1 << (i - start);\r\n                }\r\n            }\r\n        }\r\n\r\n        return collisions;\r\n    }\r\n\r\n    /** Check collisions for a row and return the colliding bricks */\r\n    public checkCollisionRow(pos: Vect, width: number): Brick[] {\r\n\r\n        let bricks : Brick[] = [];\r\n\r\n        for (const brick of this.rows.find(r => r.row == pos.y)?.bricks.filter(b => !b.isSelected) || []) {\r\n\r\n            if(col1D(\r\n                brick.gpos.x, \r\n                brick.gpos.x + brick.width, \r\n                pos.x,\r\n                pos.x + width\r\n            )) {\r\n                bricks.push(brick);\r\n            }\r\n        }\r\n\r\n        return bricks;\r\n    }\r\n\r\n    /** Disable studs that are covered */\r\n    cullBrickStuds(): void {\r\n        \r\n        // For each stud in unselected bricks\r\n        for (const stud of this.bricks.filter(b => !b.isSelected).flatMap(b => b.studs)) {\r\n\r\n            stud.isVisible = true;          // Unhide stud before rechecking its hidden status\r\n\r\n            // For each brick in this stud's row\r\n            for (const brick of this.rows.find(r => r.row == stud.gpos.y)?.bricks || []) {\r\n\r\n                if (!brick.isSelected &&    // Don't cull selected bricks\r\n                    !brick.isPressed &&     // Don't cull pressed bricks\r\n                    col1D(                  // Only cull bricks overlapping with this stud\r\n                        brick.gpos.x - 1, \r\n                        brick.gpos.x + brick.width, \r\n                        stud.gpos.x, \r\n                        stud.gpos.x\r\n                    )) {\r\n\r\n                    stud.isVisible = false;\r\n                    break;                  // Stop all checks once the stud is hidden\r\n                }\r\n            }\r\n        }\r\n\r\n        // Always show studs for selected bricks\r\n        this.bricks.filter(b => b.isSelected).flatMap(b => b.studs).forEach(s => s.isVisible = true);\r\n    }\r\n\r\n    /** Set the minimum and maximum position for selected bricks */\r\n    public setSelectedMinMax(): void {\r\n        const selected = this.bricks.filter(b => b.isSelected);\r\n\r\n        // Minimum brick position among selected bricks\r\n        const boundaryMin = new Vect(\r\n            Math.min(...selected.map(b => b.gpos.x)),\r\n            Math.min(...selected.map(b => b.gpos.y))\r\n        );\r\n        \r\n        //Maximum brick position among selected bricks\r\n        const boundaryMax = new Vect(\r\n            Math.max(...selected.map(b => b.gpos.x + b.width)), // Width included for proper boundary\r\n            Math.max(...selected.map(b => b.gpos.y + 1))        // Height included for proper boundary\r\n        );\r\n\r\n        // Set min-max for all selected bricks based on boundary\r\n        selected.forEach(b => b.setMinMax(boundaryMin, boundaryMax));\r\n    }\r\n\r\n    /** Set snapped state of selected bricks */\r\n    public setSnappedBricks(state: boolean): void {\r\n\r\n        // For each selected brick, set its snap to the given state\r\n        this.bricks.filter(b => b.isSelected).forEach(b => b.snap(state));\r\n    }\r\n\r\n    /** Deselect all bricks */\r\n    public deselectBricks(): void {\r\n\r\n        this.selectedBrick = null;\r\n        this.selections = [];\r\n        this.bricks.forEach(b => b.deselect());\r\n\r\n        //Move bricks to the new row\r\n        this.rows.forEach(r => {                                //For each row\r\n            var move = r.bricks.filter(b => b.gpos.y != r.row); //Get move-bricks that are no longer in this row\r\n            r.bricks = r.bricks.filter(b => b.gpos.y == r.row); //Remove bricks that are no longer in this row\r\n            move.forEach(b => this.addBrickToRows(b));          //For each move-brick, add it to its new row\r\n        });\r\n\r\n        //Sort\r\n        this.sortRows();\r\n    }\r\n\r\n    /** Add a brick to a row, and create that row if it doesn't exist. */\r\n    private addBrickToRows(brick: Brick): void {\r\n        const currRow = this.rows.find(r => r.row == brick.gpos.y);\r\n\r\n        // Create a new row or add a brick to the existing row\r\n        if(currRow == null) {\r\n            this.rows.push({\r\n                row : brick.gpos.y, // Assign its first brick's position to the new row\r\n                bricks : [brick]\r\n            });\r\n        } else {\r\n            currRow.bricks.push(brick);\r\n        }\r\n    }\r\n\r\n    /** Sort bricks */\r\n    private sortRows(): void {\r\n\r\n        // Sort rows by row value\r\n        this.rows.sort((a, b) => a.row > b.row ? 1 : 0);\r\n\r\n        // Sort bricks in each row by x-position\r\n        this.rows.forEach(r => r.bricks.sort((a, b) => a.gpos.x > b.gpos.x ? 1 : 0));\r\n    }\r\n\r\n    /** Check all bricks for hover, return hover state */\r\n    public hoverBricks(pos: Vect): BrickHandlerState {\r\n\r\n        // Check all bricks and return if the first successful check is not static\r\n        return this.checkBricks(pos, (b, p) => this.hoverBrick(b, p)) || BrickHandlerState.NONE;\r\n    }\r\n\r\n    /** Check all bricks for a mouse position and return the result of a function against that brick and position */\r\n    private checkBricks<T>(pos: Vect, func: (brick: Brick, pos: Vect) => T): T | null {\r\n\r\n        // Front face check\r\n        for (const brick of this.bricks) {\r\n\r\n            //Front face - if position is over this face\r\n            if (colPointRectGrid(\r\n                pos.x,\r\n                pos.y,\r\n                brick.gpos.x,\r\n                brick.gpos.y,\r\n                brick.width\r\n            )) {\r\n                return func(brick, pos);\r\n            }\r\n        }\r\n\r\n        // Top and side face check\r\n        for (var brick of this.bricks) {\r\n            if (\r\n                // Top Face - if position is over this face\r\n                colPointParHGrid(\r\n                    pos.x,\r\n                    pos.y,\r\n                    brick.gpos.x,\r\n                    brick.gpos.y,\r\n                    brick.width\r\n                ) ||\r\n                // Side Face - if position is over this face\r\n                colPointParVGrid(\r\n                    pos.x,\r\n                    pos.y,\r\n                    brick.gpos.x,\r\n                    brick.gpos.y,\r\n                    brick.width\r\n                )) {\r\n\r\n                return func(brick, pos);\r\n            }\r\n        }\r\n\r\n        // There is no brick under this position.\r\n        return null;    \r\n    }\r\n\r\n    /** Press a single brick */\r\n    private hoverBrick(brick: Brick, pos: Vect): BrickHandlerState {\r\n\r\n        // Do nothing if the two bricks are the same\r\n        if (this.selectedBrick != null && this.selectedBrick.compare(brick) && !this.isPressured) {\r\n            return BrickHandlerState.SAME;\r\n        }\r\n\r\n        this.isPressured = false;   // Reset pressured state\r\n        this.selectedBrick = brick; // Set current selected brick for later use\r\n        this.selections = [];       // Reset selections\r\n\r\n        // Check both directions if they're valid (valid == not null)\r\n        for (const dir of OPPOSITE_DIRS) {\r\n\r\n            let selectionNew = this.recurseBrick(brick, [dir], true) ?? [];\r\n\r\n            //If there are bricks to select\r\n            if(selectionNew!.length > 0) {\r\n\r\n                let floats = this.getFloatingBricks();\r\n\r\n                //If every floating brick\r\n                if(floats.every(b => b.pressure == 0)) {\r\n\r\n                    this.selections[dir] = selectionNew.concat(floats);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Clear recursion states after both recursive direction checks\r\n        this.bricks.forEach(b => b.clearRecursion());\r\n\r\n        return this.selections[-1] && \r\n            this.selections[1]  ? BrickHandlerState.INDY :  // If both selections are valid, return indeterminate state\r\n            this.selections[-1] ? BrickHandlerState.UP :    // If upward selection is valid, return up state\r\n            this.selections[1]  ? BrickHandlerState.DOWN :  // If downward selection is valid, return down state\r\n            BrickHandlerState.NONE;                         // No direction is valid. Return no state\r\n    }\r\n\r\n    /** Return floating bricks after a selection */\r\n    private getFloatingBricks(): Brick[] {\r\n        \r\n        var ret : Brick[] = [];\r\n\r\n        // Recursively check from all grey bricks and mark connected bricks as grounded\r\n        for (const brick of this.bricksGrey) {\r\n            // If the grey brick isn't checked (Reduces redundancy)\r\n            if (!brick.isChecked) {\r\n                this.recurseBrick(brick, OPPOSITE_DIRS, false)?.forEach(c => c.isGrounded = true);\r\n            }\r\n        }\r\n\r\n        // Select floating bricks and clear recursion states\r\n        //Stop trying to move the selected check! You know why it's there! \r\n        for (const brick of this.bricks) {\r\n            if (!brick.isGrounded && !brick.isSelected) {\r\n                ret.push(brick);\r\n            }\r\n            brick.clearRecursion();\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Check all bricks for press, return press state (none, processed, indeterminate)\r\n     * This entire function is bananas.\r\n     */\r\n    public pressBricks(pos: Vect): boolean {\r\n\r\n        // Build an array of selections that are not null (invalid)\r\n        // Filter to remove null (invalid) selections\r\n        const validSelections = OPPOSITE_DIRS.map(d => this.selections[d]).filter(s => s);\r\n\r\n        // If there is a single valid selection, use and auto-process it\r\n        if (validSelections.length == 1) {\r\n            // Process this selection using bricks in truthy direction, and the position.\r\n            return this.processSelection(validSelections[0], pos);\r\n        }\r\n\r\n        // For the indeterminate state, just press the currently selected brick\r\n        if (this.selectedBrick) {\r\n            this.selectedBrick.press();\r\n        }\r\n\r\n        // Return falsy for indeterminate state\r\n        return false;\r\n    }\r\n\r\n    /** Set bricks to selected based on a provided cursor position */\r\n    public initSelection(pos: Vect, dir: -1 | 1) {\r\n        \r\n        return this.processSelection(this.selections[dir], pos);\r\n    }\r\n    \r\n    /**\r\n     * Process a selection, set all its bricks to a selected state,\r\n     * search for floating bricks, return if bricks were selected\r\n     */\r\n    private processSelection(selection: Brick[] | null, pos: Vect) {\r\n        \r\n        // Select bricks\r\n        selection?.forEach(b => b.select(pos));\r\n\r\n        return !!selection;\r\n    }\r\n\r\n    /** Recursively select bricks. */\r\n    private recurseBrick(brick1: Brick, dirs: (-1 | 1)[], checkGrey: boolean) {\r\n\r\n        // Return nothing for grey bricks\r\n        if (checkGrey && (brick1.isGrey || brick1.pressure > 0)) {\r\n            return null;\r\n        }\r\n\r\n        brick1.isChecked = true;\r\n\r\n        // Current brick is a new brick in the selection\r\n        let selection = [brick1];\r\n\r\n        // For all directions, check adjacent bricks in that direction and recurse for each brick\r\n        for (const dir of dirs) {\r\n\r\n            // If adjacent row in the direction (above/below) has bricks, check and recurse for each brick\r\n            for (const brick2 of this.rows.find(r => r.row == brick1.gpos.y + dir)?.bricks || []) {\r\n\r\n                if (!brick2.isChecked && col1D(\r\n                    brick1.gpos.x, brick1.gpos.x + brick1.width, \r\n                    brick2.gpos.x, brick2.gpos.x + brick2.width)) {\r\n                    \r\n                    // Recursively check the new brick and add the results to the current selection\r\n                    const result = this.recurseBrick(brick2, dirs, checkGrey);\r\n\r\n                    if (result) {\r\n                        selection = selection.concat(result);\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return selection;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
