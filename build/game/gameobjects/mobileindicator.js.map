{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\mobileindicator.ts"],
  "sourcesContent": ["import Engine from \"engine/engine\";\r\nimport GameObject, { GameObjectParams } from \"engine/gameobjects/gameobject\";\r\nimport { BOUNDARY, GMULTX, GMULTY, round } from \"engine/utilities/math\";\r\nimport Vect from \"engine/utilities/vect\";\r\n\r\nexport default class MobileIndicator extends GameObject {\r\n\r\n    private mobileOffset: Vect = new Vect(0, 0);\r\n    private isSnapped: Boolean = false;\r\n\r\n    /** Boundary offset for minimum carried position */\r\n    private minBox : Vect = new Vect(0, 0);\r\n\r\n    /** Boundary offset for maximum carried position */\r\n    private box : Vect = new Vect(0, 0);\r\n\r\n    constructor(engine: Engine, params: GameObjectParams) {\r\n        super(engine, params);\r\n\r\n        this.isActive = false;\r\n    }\r\n\r\n    public update(dt: number) {\r\n        this.spos = this.engine.mouse.getPos().getSub(this.mobileOffset).getClamp({\r\n            // Clamp above minimum-x position\r\n            x: (BOUNDARY.minx) * GMULTX,\r\n            // Clamp above minimum-y position\r\n            y: (BOUNDARY.miny) * GMULTY\r\n        }, {  \r\n            // Clamp below maximum-x position\r\n            x: (BOUNDARY.maxx - this.box.x) * GMULTX,\r\n            // Clamp below maximum-y position\r\n            y: (BOUNDARY.maxy - this.box.y) * GMULTY\r\n        });\r\n                \r\n        //Grid positioning\r\n        if (this.isSnapped) {\r\n            this.spos.set({\r\n                x : round(this.spos.x, GMULTX),\r\n                y : round(this.spos.y, GMULTY)\r\n            });\r\n        }\r\n    }\r\n\r\n    public draw(ctx: CanvasRenderingContext2D) {\r\n        \r\n        if(this.engine.mouse.getMouseType() == \"mouse\") {\r\n            return;\r\n        }\r\n\r\n        ctx.fillStyle = \"#EEE\"\r\n        ctx.strokeStyle = \"#666\"\r\n        ctx.lineWidth = 3;\r\n        ctx.translate(GMULTX * this.box.x / 2 + 5, 0);\r\n        ctx.beginPath();\r\n        ctx.moveTo(-20, -100);\r\n        ctx.lineTo(20, -100);\r\n        ctx.lineTo(0, -50);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        ctx.stroke();\r\n    }\r\n\r\n    public setMinMax(min: Vect, max: Vect, spos : Vect): void {\r\n\r\n        //Do not activate if a mouse is being used\r\n        this.isActive = true;\r\n\r\n        //Set box that collides with boundary\r\n        this.box = max.getSub(min);\r\n\r\n        //Set the offset of the indicator\r\n        this.mobileOffset = spos.getSub({\r\n            x : min.x * GMULTX, //(min.x + max.x) * GMULTX / 2, \r\n            y : min.y * GMULTY\r\n        });\r\n    }\r\n\r\n    public snap(state : Boolean) {\r\n        this.isSnapped = state;\r\n    }\r\n}\r\n"],
  "mappings": "AACA;AACA;AACA;AAHA,6CAK6C;AAAA,EAWzC,YAAY;AACR,UAAM,SAAQ;AAVV,wBAAqB,IAAI,KAAK,GAAG;AACjC,qBAAqB;AAGrB,kBAAgB,IAAI,KAAK,GAAG;AAG5B,eAAa,IAAI,KAAK,GAAG;AAK7B,SAAK,WAAW;AAAA;AAAA,EAGb;AACH,SAAK,OAAO,KAAK,OAAO,MAAM,SAAS,OAAO,KAAK,cAAc,SAAS;AAAA,MAEtE,GAAI,SAAS,OAAQ;AAAA,MAErB,GAAI,SAAS,OAAQ;AAAA,OACtB;AAAA,MAEC,GAAI,UAAS,OAAO,KAAK,IAAI,KAAK;AAAA,MAElC,GAAI,UAAS,OAAO,KAAK,IAAI,KAAK;AAAA;AAItC,QAAI,KAAK;AACL,WAAK,KAAK,IAAI;AAAA,QACV,GAAI,MAAM,KAAK,KAAK,GAAG;AAAA,QACvB,GAAI,MAAM,KAAK,KAAK,GAAG;AAAA;AAAA;AAAA;AAAA,EAK5B;AAEH,QAAG,KAAK,OAAO,MAAM,kBAAkB;AACnC;AAAA;AAGJ,QAAI,YAAY;AAChB,QAAI,cAAc;AAClB,QAAI,YAAY;AAChB,QAAI,UAAU,SAAS,KAAK,IAAI,IAAI,IAAI,GAAG;AAC3C,QAAI;AACJ,QAAI,OAAO,KAAK;AAChB,QAAI,OAAO,IAAI;AACf,QAAI,OAAO,GAAG;AACd,QAAI;AACJ,QAAI;AACJ,QAAI;AAAA;AAAA,EAGD;AAGH,SAAK,WAAW;AAGhB,SAAK,MAAM,IAAI,OAAO;AAGtB,SAAK,eAAe,KAAK,OAAO;AAAA,MAC5B,GAAI,IAAI,IAAI;AAAA,MACZ,GAAI,IAAI,IAAI;AAAA;AAAA;AAAA,EAIb;AACH,SAAK,YAAY;AAAA;AAAA;",
  "names": []
}
