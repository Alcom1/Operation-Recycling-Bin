{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\mobileindicator.ts"],
  "sourcesContent": ["import Engine from \"engine/engine\";\r\nimport GameObject, { GameObjectParams } from \"engine/gameobjects/gameobject\";\r\nimport { BOUNDARY, GMULTX, GMULTY, MOBILE_PREVIEW_MAX, round, Z_DEPTH } from \"engine/utilities/math\";\r\nimport Vect, { Point }  from \"engine/utilities/vect\";\r\nimport Brick from \"./bricknormal\";\r\n\r\nexport default class MobileIndicator extends GameObject {\r\n\r\n    private mobileOffset : Vect = new Vect(0, 0);\r\n    private isSnapped : boolean = false;\r\n    private isFlipped : boolean = false;\r\n\r\n    /** Boundary offset for minimum carried position */\r\n    private minBox : Vect = new Vect(0, 0);\r\n\r\n    /** Boundary offset for maximum carried position */\r\n    private box : Vect = new Vect(0, 0);\r\n\r\n    /** Bricks */\r\n    private bricks : Brick[] = [];\r\n\r\n    /** Stored cursor position from moment of selection */\r\n    private _cursorPosition : Vect = new Vect(0, 0);\r\n    public set cursorPosition(value : Vect) {\r\n        this._cursorPosition = value;\r\n    }\r\n\r\n    constructor(params: GameObjectParams) {\r\n        super(params);\r\n\r\n        this.isActive = false;\r\n    }\r\n\r\n    public init(ctx: CanvasRenderingContext2D) {\r\n        \r\n        this.bricks = this.engine.tag.get(  // Get bricks from scene\r\n            \"Brick\", \r\n            \"Level\") as Brick[];\r\n    }    \r\n\r\n    public update(dt: number) {\r\n\r\n        this.spos = this.engine.mouse.getPos().getSub(this.mobileOffset).getClamp({\r\n            // Clamp above minimum-x position\r\n            x: (BOUNDARY.minx) * GMULTX,\r\n            // Clamp above minimum-y position\r\n            y: (BOUNDARY.miny) * GMULTY\r\n        }, {  \r\n            // Clamp below maximum-x position\r\n            x: (BOUNDARY.maxx - this.box.x) * GMULTX,\r\n            // Clamp below maximum-y position\r\n            y: (BOUNDARY.maxy - this.box.y) * GMULTY\r\n        });\r\n                \r\n        //Grid positioning\r\n        if (this.isSnapped) {\r\n            this.spos.set({\r\n                x : round(this.spos.x, GMULTX),\r\n                y : round(this.spos.y, GMULTY)\r\n            });\r\n        }\r\n\r\n        this.isFlipped = this.spos.y < GMULTY * (this.box.y + 5);\r\n        this.bricks.filter(b => b.isSelected).forEach(b => b.flipMobile(this.isFlipped));\r\n    }\r\n\r\n    public draw(ctx: CanvasRenderingContext2D) {\r\n        \r\n        if (this.engine.mouse.getMouseType() == \"mouse\" ||\r\n           !MOBILE_PREVIEW_MAX.getLessOrEqual(this.box)) {\r\n            return;\r\n        }\r\n\r\n        //Offset to rotate about center;\r\n        ctx.translate(\r\n            GMULTX * this.box.x / 2 + 10,\r\n            GMULTY * this.box.y / 2 - 15);\r\n\r\n        //Rotate if cursor is too high\r\n        if(this.isFlipped) {\r\n            ctx.rotate(Math.PI);\r\n        }\r\n\r\n        ctx.fillStyle = \"#EEE\"\r\n        ctx.strokeStyle = \"#666\"\r\n        ctx.lineWidth = 2;\r\n        ctx.shadowColor = \"rgba(0, 0, 0, 0.5)\";\r\n        ctx.shadowBlur = 25;\r\n\r\n        const pos : Point = {                                   //Position of the indicator window\r\n            x: -GMULTX * (this.box.x * 0.5 + 1  ),\r\n            y: -GMULTY * (this.box.y * 1.5 + 4.5) + 5\r\n        };        \r\n        const size : Point = {                                  //Size of the indicator window\r\n            x: GMULTX * (this.box.x + 2),\r\n            y: GMULTY * (this.box.y + 2)\r\n        };\r\n\r\n        ctx.beginPath();\r\n        ctx.moveTo(pos.x,          pos.y);\r\n        ctx.lineTo(pos.x + size.x, pos.y);\r\n        ctx.lineTo(pos.x + size.x, pos.y + size.y);\r\n        //Start arrow\r\n        ctx.lineTo( 20,            pos.y + size.y);\r\n        ctx.lineTo( 0,             pos.y + size.y + 50);\r\n        ctx.lineTo(-20,            pos.y + size.y);\r\n        //End arrow\r\n        ctx.lineTo(pos.x,          pos.y + size.y);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        ctx.shadowColor = \"rgba(0, 0, 0, 0)\";\r\n        ctx.stroke();\r\n    }\r\n\r\n    public setMinMax(min: Vect, max: Vect): void {\r\n\r\n        //Activate\r\n        this.isActive = true;\r\n\r\n        //Set box that collides with boundary\r\n        this.box = max.getSub(min);\r\n\r\n        //Set the offset of the indicator\r\n        this.mobileOffset = this._cursorPosition.getSub({\r\n            x : min.x * GMULTX, //(min.x + max.x) * GMULTX / 2, \r\n            y : min.y * GMULTY\r\n        });\r\n    }\r\n\r\n    public snap(state : boolean) {\r\n\r\n        this.isSnapped = state;\r\n    }\r\n}\r\n"],
  "mappings": "AACA;AACA;AACA;AAHA,6CAM6C;AAAA,EAqBzC,YAAY;AACR,UAAM;AApBF,wBAAsB,IAAI,KAAK,GAAG;AAClC,qBAAsB;AACtB,qBAAsB;AAGtB,kBAAgB,IAAI,KAAK,GAAG;AAG5B,eAAa,IAAI,KAAK,GAAG;AAGzB,kBAAmB;AAGnB,2BAAyB,IAAI,KAAK,GAAG;AAQzC,SAAK,WAAW;AAAA;AAAA,MAPT;AACP,SAAK,kBAAkB;AAAA;AAAA,EASpB;AAEH,SAAK,SAAS,KAAK,OAAO,IAAI,IAC1B,SACA;AAAA;AAAA,EAGD;AAEH,SAAK,OAAO,KAAK,OAAO,MAAM,SAAS,OAAO,KAAK,cAAc,SAAS;AAAA,MAEtE,GAAI,SAAS,OAAQ;AAAA,MAErB,GAAI,SAAS,OAAQ;AAAA,OACtB;AAAA,MAEC,GAAI,UAAS,OAAO,KAAK,IAAI,KAAK;AAAA,MAElC,GAAI,UAAS,OAAO,KAAK,IAAI,KAAK;AAAA;AAItC,QAAI,KAAK;AACL,WAAK,KAAK,IAAI;AAAA,QACV,GAAI,MAAM,KAAK,KAAK,GAAG;AAAA,QACvB,GAAI,MAAM,KAAK,KAAK,GAAG;AAAA;AAAA;AAI/B,SAAK,YAAY,KAAK,KAAK,IAAI,SAAU,MAAK,IAAI,IAAI;AACtD,SAAK,OAAO,OAAO,OAAK,EAAE,YAAY,QAAQ,OAAK,EAAE,WAAW,KAAK;AAAA;AAAA,EAGlE;AAEH,QAAI,KAAK,OAAO,MAAM,kBAAkB,WACrC,CAAC,mBAAmB,eAAe,KAAK;AACvC;AAAA;AAIJ,QAAI,UACA,SAAS,KAAK,IAAI,IAAI,IAAI,IAC1B,SAAS,KAAK,IAAI,IAAI,IAAI;AAG9B,QAAG,KAAK;AACJ,UAAI,OAAO,KAAK;AAAA;AAGpB,QAAI,YAAY;AAChB,QAAI,cAAc;AAClB,QAAI,YAAY;AAChB,QAAI,cAAc;AAClB,QAAI,aAAa;AAEjB,gBAAoB;AAAA,MAChB,GAAG,CAAC,SAAU,MAAK,IAAI,IAAI,MAAM;AAAA,MACjC,GAAG,CAAC,SAAU,MAAK,IAAI,IAAI,MAAM,OAAO;AAAA;AAE5C,iBAAqB;AAAA,MACjB,GAAG,SAAU,MAAK,IAAI,IAAI;AAAA,MAC1B,GAAG,SAAU,MAAK,IAAI,IAAI;AAAA;AAG9B,QAAI;AACJ,QAAI,OAAO,IAAI,GAAY,IAAI;AAC/B,QAAI,OAAO,IAAI,IAAI,KAAK,GAAG,IAAI;AAC/B,QAAI,OAAO,IAAI,IAAI,KAAK,GAAG,IAAI,IAAI,KAAK;AAExC,QAAI,OAAQ,IAAe,IAAI,IAAI,KAAK;AACxC,QAAI,OAAQ,GAAe,IAAI,IAAI,KAAK,IAAI;AAC5C,QAAI,OAAO,KAAgB,IAAI,IAAI,KAAK;AAExC,QAAI,OAAO,IAAI,GAAY,IAAI,IAAI,KAAK;AACxC,QAAI;AACJ,QAAI;AACJ,QAAI,cAAc;AAClB,QAAI;AAAA;AAAA,EAGD;AAGH,SAAK,WAAW;AAGhB,SAAK,MAAM,IAAI,OAAO;AAGtB,SAAK,eAAe,KAAK,gBAAgB,OAAO;AAAA,MAC5C,GAAI,IAAI,IAAI;AAAA,MACZ,GAAI,IAAI,IAAI;AAAA;AAAA;AAAA,EAIb;AAEH,SAAK,YAAY;AAAA;AAAA;",
  "names": []
}
