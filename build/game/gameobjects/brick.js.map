{
  "version": 3,
  "sources": ["/home/jonathan/Development/lego/Operation-Recycling-Bin/src/game/gameobjects/brick.ts"],
  "sourcesContent": ["import GameObject, {GameObjectParams} from \"engine/gameobjects/gameobject\";\nimport Engine from \"engine/engine\";\nimport { colorTranslate, colorMult, colorAdd, GMULTY, Z_DEPTH, GMULTX, BOUNDARY, round, UNDER_CURSOR_Z_INDEX, LINE_WIDTH, STUD_RADIUS } from \"engine/utilities/math\";\nimport Vect, {Point} from \"engine/utilities/vect\";\nimport Scene from \"engine/scene/scene\";\nimport BrickStud from \"./brickstud\";\n\ninterface BrickParams extends GameObjectParams {\n    color?: string;\n    width?: number;\n}\n\nexport default class Brick extends GameObject {\n    /** The color of this brick */\n    private color: string;\n    /** The shaded color of this brick */\n    private colorDark: string;\n    /** The bright color of this brick */\n    private colorBright: string;\n    /** If this is a grey brick */\n    public isGrey: boolean;\n\n    /** Baked image data for this brick */\n    private image = new Image();\n\n    /** If this is a static brick that will never move (grey or blocked by grey bricks), calculated later */\n    public isStatic = false;\n\n    /** Width of this brick */\n    public width: number;\n\n    public isPressed = false;\n    public isSelected = false;\n    /** If this brick is snapped to a position */\n    private isSnapped = false;\n\n    /** Relative selected position */\n    private selectedPos = new Vect(0, 0);\n\n    /** Temporary recursion state */\n    public isGrounded = false;\n    /** Temporary recursion state */\n    public isChecked = false;\n\n    /** The stud objects for this brick */\n    public studs: BrickStud[] = [];\n\n    /** Boundary offset for minimum carried position */\n    private minCarry = new Vect(0, 0);\n    /** Boundary offset for maximum carried position */\n    private maxCarry = new Vect(0, 0);\n\n    constructor(protected engine: Engine, params: BrickParams) {\n        super(engine, params);\n        \n        this.color = colorTranslate(params.color);\n        this.colorDark = colorMult(this.color, 0.625);\n        this.colorBright = colorAdd(this.color, 48);\n        this.isGrey = !params.color;\n\n        this.width = params.width || 1;\n        // Z-sort vertically and then horizontally.\n        this.zIndex =\n            // 2x multiplier for stud overlap\n            (this.gpos.x * 2)\n            // Y-pos has priority over X-pos.\n            - (this.gpos.y * 100)\n            // 2x width added for stud overlap\n            + (this.width * 2);\n\n        // Generate studs across the width of this brick\n        // For each width unit of this brick\n        for (let i = 0; i < this.width; i++) {\n            const stud = new BrickStud(this.engine, {\n                ...params,\n                // Stud has a different position than its parent brick\n                position: {\n                    // Studs go across the brick\n                    x : this.gpos.x + i,\n                    // Studs are above the brick\n                    y : this.gpos.y - 1\n                }\n            });\n            this.studs.push(stud);\n\n            // Add stud game objects to scene\n            this.parent.pushGO(stud);\n        }\n\n        //Bake image of brick\n        this.image.src = this.engine.baker.bake(\n            ctx => this.drawBrick(ctx),\n            // Width to contain the brick, the right face, and the border\n            this.width * GMULTX + Z_DEPTH + 3,\n            // Height to contain the brick, the top face, and the border\n            GMULTY + Z_DEPTH + 3,\n            `BRICK.${this.width}.${this.color}`\n        );\n    }\n\n    public update(dt: number): void {\n        // Follow mouse if selected\n        if (this.isSelected) {\n            this.setToCursor();\n        }\n    }\n\n    public draw(ctx: CanvasRenderingContext2D): void {\n        // Global transparency for selection states\n        ctx.globalAlpha =\n            this.isSnapped ? 0.75 : // Snapped bricks are transparent\n            this.isSelected ? 0.5 : // Selected bricks are more transparent\n            this.isPressed ? 0.75 : // Pressed bricks are less transparent again\n            1.0;                    // Otherwise opaque if not selected or pressed\n        \n        // Draw with vertical offset for top face\n        ctx.drawImage(this.image, 0, -Z_DEPTH - 3);\n    }\n\n    /** Set the brick to match the cursor position, based on its stored selected position */\n    public setToCursor(): void {\n        // Position based difference between stored selected position and new cursor position\n        // Brick position is its position relative to the cursor\n        this.spos = this.engine.mouse.getPos().getSub(this.selectedPos).getClamp({\n            // Clamp above minimum-x position\n            x: (BOUNDARY.minx - this.minCarry.x) * GMULTX,\n            // Clamp above minimum-y position\n            y: (BOUNDARY.miny - this.minCarry.y) * GMULTY\n        }, {  \n            // Clamp below maximum-x position\n            x: (BOUNDARY.maxx - this.maxCarry.x) * GMULTX,\n            // Clamp below maximum-y position\n            y: (BOUNDARY.maxy - this.maxCarry.y) * GMULTY\n        });    \n\n        // Grid positioning\n        if (this.isSnapped) {\n            this.spos.set({\n                x : round(this.spos.x, GMULTX),\n                y : round(this.spos.y, GMULTY)\n            });\n        }\n\n        // Set studs to match the position of this brick while selected.\n        this.resetStuds();\n    }\n\n    // Setup this brick for pressing\n    public press(): void {\n        // Can't press static bricks\n        if (!this.isStatic) {\n            this.isPressed = true;\n            // Press studs for transparency\n            this.studs.forEach(s => s.press());\n        }\n    }\n\n    /** Setup this brick for selecting */\n    public select(pos: Point): void {\n        this.isSelected = true;\n        // Check so this brick is ignored for float checks\n        this.isChecked = true;\n        // Store mouse's current position for relative calculations later\n        this.selectedPos.set(pos);\n        // Set z-index to draw this brick under the cursor\n        this.zIndex = UNDER_CURSOR_Z_INDEX;\n        // Select studs for transparency\n        this.studs.forEach(s => s.select());\n    }\n\n    /** Clear this brick's selection states */\n    public deselect(): void {\n        // Restore grid position for deselection\n        if (this.isSelected) {\n            // Snap sub position to the grid for the new position\n            this.gpos.set(\n                this.gpos.x + Math.round(this.spos.x / GMULTX),\n                this.gpos.y + Math.round(this.spos.y / GMULTY)\n            );\n        }\n\n        // Restore states & values\n        this.isPressed = false;\n        this.isSelected = false;\n        this.isSnapped = false;\n        this.spos.set(0, 0);\n        this.selectedPos.set(0, 0);\n        this.zIndex = this.gpos.x * 2 - this.gpos.y * 100 + this.width * 2;\n        // Reset studs to match the final brick position\n        this.resetStuds();\n        this.studs.forEach(s => s.deselect());\n    }\n\n    // Set this brick's snap state\n    public snap(state: boolean): void {\n        this.studs.forEach(s => s.snap(state));\n\n        // Snap or unsnap based on the given state\n        if (state) {\n            this.isSnapped = true;\n            this.zIndex =\n                // 2x multiplier for stud overlap\n                ((this.gpos.x + Math.round(this.spos.x / GMULTX)) * 2)\n                // Y-pos has priority over X-pos.\n                - ((this.gpos.y + Math.round(this.spos.y / GMULTY)) * 100)\n                // 2x width added for stud overlap\n                + (this.width * 2);\n        } else {\n            this.isSnapped = false;\n            // Set Z-index for dragging\n            this.zIndex = UNDER_CURSOR_Z_INDEX;\n            // Reposition for unsnapped state to fix 1-frame jump on pickup\n            this.setToCursor();\n        }\n    }\n\n    /** Clear this brick's recursion states */\n    public clearRecursion() {\n        this.isGrounded = false;\n        this.isChecked = false;\n    }\n\n    /** Reset studs to match the position of this brick */\n    private resetStuds(): void {\n        for (const [idx, stud] of this.studs.entries()) {\n            // Set stud global pos to match this brick\n            stud.gpos.set(this.gpos.x + idx, this.gpos.y - 1);\n            // Set stud sub pos to match this brick\n            stud.spos.set(this.spos);\n        }\n    }\n\n    /** Set the minimum and maximum carry positions of this brick */\n    public setMinMax(min: Vect, max: Vect): void {\n        this.minCarry = min;\n        this.maxCarry = max;\n    }\n\n    /** Draw this brick */\n    private drawBrick(ctx: CanvasRenderingContext2D): void {\n        // Offset for top face and borders for baked drawing\n        ctx.translate(0, Z_DEPTH + 3);\n\n        // Base rectangle color\n        ctx.fillStyle = this.color;\n\n        // Front face\n        ctx.fillRect(\n            0, 0,                   // Origin\n            this.width * GMULTX,    // Brick width\n            GMULTY                  // Brick height\n        );                    \n\n        // Right face style\n        ctx.fillStyle = this.colorDark;\n\n        // Right face\n        ctx.beginPath();\n        ctx.moveTo(this.width * GMULTX,             GMULTY);             // Lower left corner\n        ctx.lineTo(this.width * GMULTX,             0);                  // Upper left corner\n        ctx.lineTo(this.width * GMULTX + Z_DEPTH,           -Z_DEPTH);   // Upper right corner\n        ctx.lineTo(this.width * GMULTX + Z_DEPTH,   GMULTY - Z_DEPTH);   // Lower right corner\n        ctx.fill();\n\n        // Top face style\n        ctx.fillStyle = this.colorBright;\n\n        // Top face\n        ctx.beginPath();\n        ctx.moveTo(0,                              0);          // Lower left corner\n        ctx.lineTo(                      Z_DEPTH,  -Z_DEPTH);   // Upper left corner\n        ctx.lineTo(this.width * GMULTX + Z_DEPTH,  -Z_DEPTH);   // Upper right corner\n        ctx.lineTo(this.width * GMULTX,            0);          // Lower right corner\n        ctx.fill();\n\n        // Border style\n        ctx.strokeStyle = this.color;\n        ctx.lineWidth = LINE_WIDTH;\n        ctx.lineCap = \"square\";\n        \n        // Depth Border\n        ctx.beginPath(); \n        ctx.moveTo(Z_DEPTH,          -Z_DEPTH);   //Upper left corner (back)\n        ctx.lineTo(LINE_WIDTH / 2,   0);          //Upper left corner\n        ctx.stroke();\n\n        // Border style\n        ctx.strokeStyle = this.colorDark;\n\n        // Border\n        ctx.beginPath();\n        ctx.moveTo(LINE_WIDTH / 2,      LINE_WIDTH / 2);             // Upper left corner\n        ctx.lineTo(LINE_WIDTH / 2,      GMULTY - LINE_WIDTH / 2);    // Lower left corner\n        ctx.lineTo(this.width * GMULTX, GMULTY - LINE_WIDTH / 2);    // Lower right corner\n        ctx.stroke();\n\n        // Grey holes\n        if (this.isGrey) {\n            // All holes share the same Y-offset\n            const yoff = Math.ceil(GMULTY * 0.4);\n\n            // Hole styles\n            ctx.fillStyle = this.colorDark;\n\n            // Draw hole for each brick width, except for the last one\n            for (let j = 1; j < this.width; j++) {\n                // X-offset increases for each hole\n                const xoff = GMULTX * j;\n\n                // Hole border\n                ctx.beginPath();\n                ctx.arc(xoff, yoff, STUD_RADIUS, 0, 2 * Math.PI);\n                ctx.stroke();\n\n                // Hole center\n                ctx.beginPath();\n                ctx.arc(xoff, yoff, STUD_RADIUS * 0.64, 0, 2 * Math.PI);\n                ctx.fill();\n            }\n        }\n    }\n}"],
  "mappings": "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",
  "names": []
}
