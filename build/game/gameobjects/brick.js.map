{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\brick.ts"],
  "sourcesContent": ["import GameObject, {GameObjectParams} from \"engine/gameobjects/gameobject\";\r\nimport { colorTranslate, GMULTY, Z_DEPTH, GMULTX, BOUNDARY, round, MOBILE_PREVIEW_MAX } from \"engine/utilities/math\";\r\nimport Vect, {Point} from \"engine/utilities/vect\";\r\n\r\nexport interface BrickParams extends GameObjectParams {\r\n    color?: string;\r\n    width?: number;\r\n    block?: boolean;\r\n    glide?: boolean;\r\n}\r\n\r\n/** Base class for all bricks */\r\nexport default class Brick extends GameObject {\r\n\r\n    /** The color of this brick */\r\n    protected color: string;\r\n\r\n    /** If this is a grey brick */\r\n    private _isGrey: boolean; public get isGrey(): boolean { return this._isGrey; }\r\n\r\n    /** Baked image data for this brick */\r\n    protected image = new Image();\r\n\r\n    /** If this is a static brick that will never move (grey or blocked by grey bricks), calculated later */\r\n    public isStatic = false;\r\n\r\n    /** Width of this brick */\r\n    public width: number;\r\n\r\n    /** If this brick is pressed */\r\n    public isPressed = false;\r\n\r\n    /** If this brick is selected */\r\n    public isSelected = false;\r\n\r\n    /** If this brick is snapped to a position */\r\n    private isSnapped = false;\r\n\r\n    /** Relative selected position */\r\n    private selectedPos = new Vect(0, 0);\r\n\r\n    /** Temporary recursion state */\r\n    public isGrounded = false;\r\n\r\n    /** Temporary recursion state */\r\n    public isChecked = false;\r\n\r\n    /** Boundary offset for minimum carried position */\r\n    private minCarry : Vect = new Vect(0, 0);\r\n\r\n    /** Boundary offset for maximum carried position */\r\n    private maxCarry : Vect = new Vect(0, 0);\r\n\r\n    /** Vertical offset for mobile devices*/\r\n    protected mobilePreviewSize : Vect = new Vect(0, 0);\r\n\r\n    /** If the mobile preview is flipped */\r\n    private isMobileFlipped : Boolean = false;\r\n\r\n    /** If the brick blocks placement */\r\n    protected _isBlock : boolean = false; public get isBlock() : boolean {return this._isBlock};\r\n\r\n    /** If the brick is attatched to a gliding object */\r\n    protected _isGlide : boolean = false; public get isGlide() : boolean {return this._isGlide};\r\n\r\n    /** z-index get/setters */    \r\n    get zIndex() : number { return super.zIndex; }\r\n    set zIndex(value : number) { \r\n        super.zIndex = value + (this.isSelected && !this.isSnapped ? 2000 : 0);\r\n    }\r\n    get zpos() : Vect { \r\n        return (\r\n            this.isSelected ?\r\n            this.gpos.getAdd({\r\n                x : Math.floor(this.spos.x / GMULTX),\r\n                y : Math.floor(this.spos.y / GMULTY),\r\n            }) :\r\n            super.zpos); \r\n    }\r\n    public get zSize() : Point { return {x : this.width, y : 1 }; }\r\n    public get zLayer() : Number { return this.isSelected && !this.isSnapped ? 1 : 0 }\r\n\r\n    /** Constructor */\r\n    constructor(params: BrickParams) {\r\n        super(params);\r\n        \r\n        this.color = colorTranslate(params.color);\r\n        this._isGrey = !params.color;\r\n        this._isBlock = params.block ?? false;\r\n        this._isGlide = params.glide ?? false;\r\n\r\n        this.tags.push(\"Brick\");\r\n\r\n        this.width = params.width || 1;\r\n    }\r\n\r\n    /** Update brick, move it along the cursor if it's selected. */\r\n    public update(dt: number): void {\r\n\r\n        // Follow mouse if selected\r\n        if (this.isSelected) {\r\n            this.setToCursor();\r\n        }\r\n    }\r\n\r\n    /** Draw brick */\r\n    public draw(ctx: CanvasRenderingContext2D): void {\r\n\r\n        // Global transparency for selection states\r\n        ctx.globalAlpha =\r\n            this.isSnapped ? 0.75 : // Snapped bricks are transparent\r\n            this.isSelected ? 0.4 : // Selected bricks are more transparent\r\n            this.isPressed ? 0.75 : // Pressed bricks are less transparent again\r\n            1.0;                    // Otherwise opaque if not selected or pressed\r\n        \r\n        // Draw with vertical offset for top face\r\n        ctx.drawImage(this.image, 0, -Z_DEPTH - 3);\r\n    }\r\n\r\n    /** Draw mobile preview above everything */\r\n    public superDraw(ctx: CanvasRenderingContext2D): void {\r\n\r\n        // Debug Z-index\r\n        // var indexDisplay = \"\" + this.zIndex;\r\n        // let indexPos : Point = { x : 5, y : GMULTY - 15};\r\n        // ctx.strokeStyle = \"#000\";\r\n        // ctx.fillStyle = \"#FFF\"\r\n        // ctx.lineWidth = 2;\r\n        // ctx.font = \" 20px Monospace\"\r\n        // ctx.strokeText(indexDisplay, indexPos.x, indexPos.y);\r\n        // ctx.fillText(indexDisplay, indexPos.x, indexPos.y);\r\n\r\n        // Only draw preview if on browser, this brick is selected, and the selection size is large enough\r\n        if (this.engine.mouse.getMouseType() == \"mouse\" ||\r\n           !this.isSelected || \r\n           !MOBILE_PREVIEW_MAX.getLessOrEqual(this.mobilePreviewSize)) {\r\n            return;\r\n        }\r\n\r\n        // Draw mobile view\r\n        ctx.drawImage(\r\n            this.image, \r\n            0, \r\n            - Z_DEPTH \r\n            - 3 \r\n            - GMULTY * (\r\n                this.isMobileFlipped ? \r\n               -this.mobilePreviewSize.y - 3.2 :\r\n                this.mobilePreviewSize.y + 3.5));\r\n    }\r\n\r\n    /** Setup this brick for pressing */\r\n    public press(): void {\r\n\r\n        // Can't press static bricks\r\n        if (!this.isStatic) {\r\n            this.isPressed = true;\r\n        }\r\n    }\r\n\r\n    /** Setup this brick for selecting */\r\n    public select(pos: Point): void {\r\n\r\n        // This brick is now selected\r\n        this.isSelected = true;\r\n        // Check so this brick is ignored for float checks\r\n        this.isChecked = true;\r\n        // Store mouse's current position for relative calculations later\r\n        this.selectedPos.set(pos);\r\n    }\r\n\r\n    /** Clear this brick's selection states */\r\n    public deselect(): void {\r\n\r\n        // Restore grid position for deselection\r\n        if (this.isSelected) {\r\n            // Snap sub position to the grid for the new position\r\n            this.gpos.set(\r\n                this.gpos.x + Math.round(this.spos.x / GMULTX),\r\n                this.gpos.y + Math.round(this.spos.y / GMULTY)\r\n            );\r\n        }\r\n\r\n        // Restore states & values\r\n        this.isPressed = false;\r\n        this.isSelected = false;\r\n        this.isSnapped = false;\r\n        this.isChecked = false; // Fixed bug where selections dragged offscreen wouldn't clear correctly.\r\n        this.spos.set(0, 0);\r\n        this.selectedPos.set(0, 0);\r\n        // Reset studs to match the final brick position\r\n    }\r\n\r\n    /** Set the brick to match the cursor position, based on its stored selected position */\r\n    public setToCursor(): void {\r\n\r\n        // Position based difference between stored selected position and new cursor position\r\n        // Brick position is its position relative to the cursor\r\n        this.spos = this.engine.mouse.getPos().getSub(this.selectedPos).getClamp({\r\n            // Clamp above minimum-x position\r\n            x: (BOUNDARY.minx - this.minCarry.x) * GMULTX,\r\n            // Clamp above minimum-y position\r\n            y: (BOUNDARY.miny - this.minCarry.y) * GMULTY\r\n        }, {  \r\n            // Clamp below maximum-x position\r\n            x: (BOUNDARY.maxx - this.maxCarry.x) * GMULTX,\r\n            // Clamp below maximum-y position\r\n            y: (BOUNDARY.maxy - this.maxCarry.y) * GMULTY\r\n        });    \r\n\r\n        // Grid positioning\r\n        if (this.isSnapped) {\r\n            this.spos.set({\r\n                x : round(this.spos.x, GMULTX),\r\n                y : round(this.spos.y, GMULTY)\r\n            });\r\n        }\r\n    }\r\n\r\n    /** Snap this brick to the grid based on the given state */\r\n    public snap(state: boolean): void {\r\n\r\n        // Snap or unsnap based on the given state\r\n        this.isSnapped = state;\r\n\r\n        // Reposition for unsnapped state to fix 1-frame jump on pickup\r\n        if (!this.isSnapped) {            \r\n            this.setToCursor();\r\n        }\r\n    }\r\n\r\n    /** Clear this brick's recursion states */\r\n    public clearRecursion() {\r\n        this.isGrounded = false;\r\n        this.isChecked = false;\r\n    }\r\n\r\n    /** Set the minimum and maximum carry positions of this brick */\r\n    public setMinMax(min: Vect, max: Vect): void {\r\n\r\n        this.minCarry = min;\r\n        this.maxCarry = max;\r\n\r\n        this.mobilePreviewSize = max.getSub(min); // asdf\r\n    }\r\n\r\n    /** Set the flipped state for the mobile preview */\r\n    public flipMobile(isFlipped : boolean) {\r\n\r\n        this.isMobileFlipped = isFlipped;\r\n    }\r\n}"],
  "mappings": "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",
  "names": []
}
