{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\brick.ts"],
  "sourcesContent": ["import GameObject, {GameObjectParams} from \"engine/gameobjects/gameobject\";\r\nimport Engine from \"engine/engine\";\r\nimport { colorTranslate, colorMult, colorAdd, GMULTY, Z_DEPTH, GMULTX, BOUNDARY, round, UNDER_CURSOR_Z_INDEX, LINE_WIDTH, STUD_RADIUS } from \"engine/utilities/math\";\r\nimport Vect, {Point} from \"engine/utilities/vect\";\r\nimport Scene from \"engine/scene/scene\";\r\nimport BrickStud from \"./brickstud\";\r\n\r\ninterface BrickParams extends GameObjectParams {\r\n    color?: string;\r\n    width?: number;\r\n}\r\n\r\nexport default class Brick extends GameObject {\r\n    /** The color of this brick */\r\n    private color: string;\r\n    /** The shaded color of this brick */\r\n    private colorDark: string;\r\n    /** The bright color of this brick */\r\n    private colorBright: string;\r\n    /** If this is a grey brick */\r\n    public isGrey: boolean;\r\n\r\n    /** Baked image data for this brick */\r\n    private image = new Image();\r\n\r\n    /** If this is a static brick that will never move (grey or blocked by grey bricks), calculated later */\r\n    public isStatic = false;\r\n\r\n    /** Width of this brick */\r\n    public width: number;\r\n\r\n    public isPressed = false;\r\n    public isSelected = false;\r\n    /** If this brick is snapped to a position */\r\n    private isSnapped = false;\r\n\r\n    /** Relative selected position */\r\n    private selectedPos = new Vect(0, 0);\r\n\r\n    /** Temporary recursion state */\r\n    public isGrounded = false;\r\n    /** Temporary recursion state */\r\n    public isChecked = false;\r\n\r\n    /** The stud objects for this brick */\r\n    public studs: BrickStud[] = [];\r\n\r\n    /** Boundary offset for minimum carried position */\r\n    private minCarry = new Vect(0, 0);\r\n    /** Boundary offset for maximum carried position */\r\n    private maxCarry = new Vect(0, 0);\r\n\r\n    constructor(protected engine: Engine, params: BrickParams) {\r\n        super(engine, params);\r\n        \r\n        this.color = colorTranslate(params.color);\r\n        this.colorDark = colorMult(this.color, 0.625);\r\n        this.colorBright = colorAdd(this.color, 48);\r\n        this.isGrey = !params.color;\r\n\r\n        this.width = params.width || 1;\r\n        // Z-sort vertically and then horizontally.\r\n        this.zIndex =\r\n            // 2x multiplier for stud overlap\r\n            (this.gpos.x * 2)\r\n            // Y-pos has priority over X-pos.\r\n            - (this.gpos.y * 100)\r\n            // 2x width added for stud overlap\r\n            + (this.width * 2);\r\n\r\n        // Generate studs across the width of this brick\r\n        // For each width unit of this brick\r\n        for (let i = 0; i < this.width; i++) {\r\n            const stud = new BrickStud(this.engine, {\r\n                ...params,\r\n                // Stud has a different position than its parent brick\r\n                position: {\r\n                    // Studs go across the brick\r\n                    x : this.gpos.x + i,\r\n                    // Studs are above the brick\r\n                    y : this.gpos.y - 1\r\n                }\r\n            });\r\n            this.studs.push(stud);\r\n\r\n            // Add stud game objects to scene\r\n            this.parent.pushGO(stud);\r\n        }\r\n\r\n        //Bake image of brick\r\n        this.image.src = this.engine.baker.bake(\r\n            ctx => this.drawBrick(ctx),\r\n            // Width to contain the brick, the right face, and the border\r\n            this.width * GMULTX + Z_DEPTH + 3,\r\n            // Height to contain the brick, the top face, and the border\r\n            GMULTY + Z_DEPTH + 3,\r\n            `BRICK.${this.width}.${this.color}`\r\n        );\r\n    }\r\n\r\n    public update(dt: number): void {\r\n        // Follow mouse if selected\r\n        if (this.isSelected) {\r\n            this.setToCursor();\r\n        }\r\n    }\r\n\r\n    public draw(ctx: CanvasRenderingContext2D): void {\r\n        // Global transparency for selection states\r\n        ctx.globalAlpha =\r\n            this.isSnapped ? 0.75 : // Snapped bricks are transparent\r\n            this.isSelected ? 0.5 : // Selected bricks are more transparent\r\n            this.isPressed ? 0.75 : // Pressed bricks are less transparent again\r\n            1.0;                    // Otherwise opaque if not selected or pressed\r\n        \r\n        // Draw with vertical offset for top face\r\n        ctx.drawImage(this.image, 0, -Z_DEPTH - 3);\r\n    }\r\n\r\n    /** Set the brick to match the cursor position, based on its stored selected position */\r\n    public setToCursor(): void {\r\n        // Position based difference between stored selected position and new cursor position\r\n        // Brick position is its position relative to the cursor\r\n        this.spos = this.engine.mouse.getPos().getSub(this.selectedPos).getClamp({\r\n            // Clamp above minimum-x position\r\n            x: (BOUNDARY.minx - this.minCarry.x) * GMULTX,\r\n            // Clamp above minimum-y position\r\n            y: (BOUNDARY.miny - this.minCarry.y) * GMULTY\r\n        }, {  \r\n            // Clamp below maximum-x position\r\n            x: (BOUNDARY.maxx - this.maxCarry.x) * GMULTX,\r\n            // Clamp below maximum-y position\r\n            y: (BOUNDARY.maxy - this.maxCarry.y) * GMULTY\r\n        });    \r\n\r\n        // Grid positioning\r\n        if (this.isSnapped) {\r\n            this.spos.set({\r\n                x : round(this.spos.x, GMULTX),\r\n                y : round(this.spos.y, GMULTY)\r\n            });\r\n        }\r\n\r\n        // Set studs to match the position of this brick while selected.\r\n        this.resetStuds();\r\n    }\r\n\r\n    // Setup this brick for pressing\r\n    public press(): void {\r\n        // Can't press static bricks\r\n        if (!this.isStatic) {\r\n            this.isPressed = true;\r\n            // Press studs for transparency\r\n            this.studs.forEach(s => s.press());\r\n        }\r\n    }\r\n\r\n    /** Setup this brick for selecting */\r\n    public select(pos: Point): void {\r\n        this.isSelected = true;\r\n        // Check so this brick is ignored for float checks\r\n        this.isChecked = true;\r\n        // Store mouse's current position for relative calculations later\r\n        this.selectedPos.set(pos);\r\n        // Set z-index to draw this brick under the cursor\r\n        this.zIndex = UNDER_CURSOR_Z_INDEX;\r\n        // Select studs for transparency\r\n        this.studs.forEach(s => s.select());\r\n    }\r\n\r\n    /** Clear this brick's selection states */\r\n    public deselect(): void {\r\n        // Restore grid position for deselection\r\n        if (this.isSelected) {\r\n            // Snap sub position to the grid for the new position\r\n            this.gpos.set(\r\n                this.gpos.x + Math.round(this.spos.x / GMULTX),\r\n                this.gpos.y + Math.round(this.spos.y / GMULTY)\r\n            );\r\n        }\r\n\r\n        // Restore states & values\r\n        this.isPressed = false;\r\n        this.isSelected = false;\r\n        this.isSnapped = false;\r\n        this.spos.set(0, 0);\r\n        this.selectedPos.set(0, 0);\r\n        this.zIndex = this.gpos.x * 2 - this.gpos.y * 100 + this.width * 2;\r\n        // Reset studs to match the final brick position\r\n        this.resetStuds();\r\n        this.studs.forEach(s => s.deselect());\r\n    }\r\n\r\n    // Set this brick's snap state\r\n    public snap(state: boolean): void {\r\n        this.studs.forEach(s => s.snap(state));\r\n\r\n        // Snap or unsnap based on the given state\r\n        if (state) {\r\n            this.isSnapped = true;\r\n            this.zIndex =\r\n                // 2x multiplier for stud overlap\r\n                ((this.gpos.x + Math.round(this.spos.x / GMULTX)) * 2)\r\n                // Y-pos has priority over X-pos.\r\n                - ((this.gpos.y + Math.round(this.spos.y / GMULTY)) * 100)\r\n                // 2x width added for stud overlap\r\n                + (this.width * 2);\r\n        } else {\r\n            this.isSnapped = false;\r\n            // Set Z-index for dragging\r\n            this.zIndex = UNDER_CURSOR_Z_INDEX;\r\n            // Reposition for unsnapped state to fix 1-frame jump on pickup\r\n            this.setToCursor();\r\n        }\r\n    }\r\n\r\n    /** Clear this brick's recursion states */\r\n    public clearRecursion() {\r\n        this.isGrounded = false;\r\n        this.isChecked = false;\r\n    }\r\n\r\n    /** Reset studs to match the position of this brick */\r\n    private resetStuds(): void {\r\n        for (const [idx, stud] of this.studs.entries()) {\r\n            // Set stud global pos to match this brick\r\n            stud.gpos.set(this.gpos.x + idx, this.gpos.y - 1);\r\n            // Set stud sub pos to match this brick\r\n            stud.spos.set(this.spos);\r\n        }\r\n    }\r\n\r\n    /** Set the minimum and maximum carry positions of this brick */\r\n    public setMinMax(min: Vect, max: Vect): void {\r\n        this.minCarry = min;\r\n        this.maxCarry = max;\r\n    }\r\n\r\n    /** Draw this brick */\r\n    private drawBrick(ctx: CanvasRenderingContext2D): void {\r\n        // Offset for top face and borders for baked drawing\r\n        ctx.translate(0, Z_DEPTH + 3);\r\n\r\n        // Base rectangle color\r\n        ctx.fillStyle = this.color;\r\n\r\n        // Front face\r\n        ctx.fillRect(\r\n            0, 0,                   // Origin\r\n            this.width * GMULTX,    // Brick width\r\n            GMULTY                  // Brick height\r\n        );                    \r\n\r\n        // Right face style\r\n        ctx.fillStyle = this.colorDark;\r\n\r\n        // Right face\r\n        ctx.beginPath();\r\n        ctx.moveTo(this.width * GMULTX,             GMULTY);             // Lower left corner\r\n        ctx.lineTo(this.width * GMULTX,             0);                  // Upper left corner\r\n        ctx.lineTo(this.width * GMULTX + Z_DEPTH,           -Z_DEPTH);   // Upper right corner\r\n        ctx.lineTo(this.width * GMULTX + Z_DEPTH,   GMULTY - Z_DEPTH);   // Lower right corner\r\n        ctx.fill();\r\n\r\n        // Top face style\r\n        ctx.fillStyle = this.colorBright;\r\n\r\n        // Top face\r\n        ctx.beginPath();\r\n        ctx.moveTo(0,                              0);          // Lower left corner\r\n        ctx.lineTo(                      Z_DEPTH,  -Z_DEPTH);   // Upper left corner\r\n        ctx.lineTo(this.width * GMULTX + Z_DEPTH,  -Z_DEPTH);   // Upper right corner\r\n        ctx.lineTo(this.width * GMULTX,            0);          // Lower right corner\r\n        ctx.fill();\r\n\r\n        // Border style\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = LINE_WIDTH;\r\n        ctx.lineCap = \"square\";\r\n        \r\n        // Depth Border\r\n        ctx.beginPath(); \r\n        ctx.moveTo(Z_DEPTH,          -Z_DEPTH);   //Upper left corner (back)\r\n        ctx.lineTo(LINE_WIDTH / 2,   0);          //Upper left corner\r\n        ctx.stroke();\r\n\r\n        // Border style\r\n        ctx.strokeStyle = this.colorDark;\r\n\r\n        // Border\r\n        ctx.beginPath();\r\n        ctx.moveTo(LINE_WIDTH / 2,      LINE_WIDTH / 2);             // Upper left corner\r\n        ctx.lineTo(LINE_WIDTH / 2,      GMULTY - LINE_WIDTH / 2);    // Lower left corner\r\n        ctx.lineTo(this.width * GMULTX, GMULTY - LINE_WIDTH / 2);    // Lower right corner\r\n        ctx.stroke();\r\n\r\n        // Grey holes\r\n        if (this.isGrey) {\r\n            // All holes share the same Y-offset\r\n            const yoff = Math.ceil(GMULTY * 0.4);\r\n\r\n            // Hole styles\r\n            ctx.fillStyle = this.colorDark;\r\n\r\n            // Draw hole for each brick width, except for the last one\r\n            for (let j = 1; j < this.width; j++) {\r\n                // X-offset increases for each hole\r\n                const xoff = GMULTX * j;\r\n\r\n                // Hole border\r\n                ctx.beginPath();\r\n                ctx.arc(xoff, yoff, STUD_RADIUS, 0, 2 * Math.PI);\r\n                ctx.stroke();\r\n\r\n                // Hole center\r\n                ctx.beginPath();\r\n                ctx.arc(xoff, yoff, STUD_RADIUS * 0.64, 0, 2 * Math.PI);\r\n                ctx.fill();\r\n            }\r\n        }\r\n    }\r\n}"],
  "mappings": "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",
  "names": []
}
