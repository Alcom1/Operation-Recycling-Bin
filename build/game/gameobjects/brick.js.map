{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\brick.ts"],
  "sourcesContent": ["import GameObject, {GameObjectParams} from \"engine/gameobjects/gameobject\";\r\nimport Engine from \"engine/engine\";\r\nimport { colorTranslate, GMULTY, Z_DEPTH, GMULTX, BOUNDARY, round, UNDER_CURSOR_Z_INDEX, getZIndex, MOBILE_PREVIEW_MAX } from \"engine/utilities/math\";\r\nimport Vect, {Point} from \"engine/utilities/vect\";\r\n\r\nexport interface BrickParams extends GameObjectParams {\r\n    color?: string;\r\n    width?: number;\r\n}\r\n\r\nexport default class Brick extends GameObject {\r\n\r\n    /** The color of this brick */\r\n    protected color: string;\r\n\r\n    /** If this is a grey brick */\r\n    public isGrey: boolean;\r\n\r\n    /** Baked image data for this brick */\r\n    protected image = new Image();\r\n\r\n    /** If this is a static brick that will never move (grey or blocked by grey bricks), calculated later */\r\n    public isStatic = false;\r\n\r\n    /** Width of this brick */\r\n    public width: number;\r\n\r\n    /** If this brick is pressed */\r\n    public isPressed = false;\r\n\r\n    /** If this brick is selected */\r\n    public isSelected = false;\r\n\r\n    /** If this brick is snapped to a position */\r\n    private isSnapped = false;\r\n\r\n    /** Relative selected position */\r\n    private selectedPos = new Vect(0, 0);\r\n\r\n    /** Temporary recursion state */\r\n    public isGrounded = false;\r\n\r\n    /** Temporary recursion state */\r\n    public isChecked = false;\r\n\r\n    /** Number of objects on top of this brick */\r\n    public pressure = 0;\r\n\r\n    /** Boundary offset for minimum carried position */\r\n    private minCarry : Vect = new Vect(0, 0);\r\n\r\n    /** Boundary offset for maximum carried position */\r\n    private maxCarry : Vect = new Vect(0, 0);\r\n\r\n    /** Vertical offset for mobile devices*/\r\n    protected mobilePreviewSize : Vect = new Vect(0, 0);\r\n\r\n    /** If the mobile preview is flipped */\r\n    private isMobileFlipped : Boolean = false;\r\n\r\n    constructor(protected engine: Engine, params: BrickParams) {\r\n        super(engine, params);\r\n        \r\n        this.color = colorTranslate(params.color);\r\n        this.isGrey = !params.color;\r\n\r\n        this.tags.push(\"Brick\");\r\n\r\n        this.width = params.width || 1;\r\n    }\r\n\r\n    public update(dt: number): void {\r\n\r\n        // Follow mouse if selected\r\n        if (this.isSelected) {\r\n            this.setToCursor();\r\n        }\r\n    }\r\n\r\n    public draw(ctx: CanvasRenderingContext2D): void {\r\n\r\n        // Global transparency for selection states\r\n        ctx.globalAlpha =\r\n            this.isSnapped ? 0.75 : // Snapped bricks are transparent\r\n            this.isSelected ? 0.4 : // Selected bricks are more transparent\r\n            this.isPressed ? 0.75 : // Pressed bricks are less transparent again\r\n            1.0;                    // Otherwise opaque if not selected or pressed\r\n        \r\n        // Draw with vertical offset for top face\r\n        ctx.drawImage(this.image, 0, -Z_DEPTH - 3);\r\n    }\r\n\r\n    public superDraw(ctx: CanvasRenderingContext2D): void {\r\n\r\n        if (this.engine.mouse.getMouseType() == \"mouse\" ||\r\n           !this.isSelected || \r\n           !MOBILE_PREVIEW_MAX.getLessOrEqual(this.mobilePreviewSize)) {\r\n            return;\r\n        }\r\n\r\n        //Draw mobile view\r\n        ctx.drawImage(\r\n            this.image, \r\n            0, \r\n            - Z_DEPTH \r\n            - 3 \r\n            - GMULTY * (\r\n                this.isMobileFlipped ? \r\n               -this.mobilePreviewSize.y - 3.2 :\r\n                this.mobilePreviewSize.y + 3.5));\r\n    }\r\n\r\n    /** Get z-index for draw sorting */\r\n    public getGOZIndex() : number {\r\n\r\n        // Set z-index to draw this brick in its snapped position\r\n        if(this.isSnapped) {\r\n            return getZIndex(\r\n                this.gpos.getAdd({\r\n                    x : Math.round(this.spos.x / GMULTX),\r\n                    y : Math.round(this.spos.y / GMULTY)\r\n                }),\r\n                this.width * 10);\r\n        }        \r\n        // Set z-index to draw this brick under the cursor\r\n        if(this.isSelected) {\r\n            return UNDER_CURSOR_Z_INDEX;\r\n        }\r\n        //Normal z-index\r\n        else {\r\n            return getZIndex(this.gpos, this.width * 10);\r\n        }\r\n    }\r\n\r\n    /** Setup this brick for pressing */\r\n    public press(): void {\r\n\r\n        // Can't press static bricks\r\n        if (!this.isStatic) {\r\n            this.isPressed = true;\r\n        }\r\n    }\r\n\r\n    /** Setup this brick for selecting */\r\n    public select(pos: Point): void {\r\n\r\n        // This brick is now selected\r\n        this.isSelected = true;\r\n        // Check so this brick is ignored for float checks\r\n        this.isChecked = true;\r\n        // Store mouse's current position for relative calculations later\r\n        this.selectedPos.set(pos);\r\n    }\r\n\r\n    /** Clear this brick's selection states */\r\n    public deselect(): void {\r\n\r\n        // Restore grid position for deselection\r\n        if (this.isSelected) {\r\n            // Snap sub position to the grid for the new position\r\n            this.gpos.set(\r\n                this.gpos.x + Math.round(this.spos.x / GMULTX),\r\n                this.gpos.y + Math.round(this.spos.y / GMULTY)\r\n            );\r\n        }\r\n\r\n        // Restore states & values\r\n        this.isPressed = false;\r\n        this.isSelected = false;\r\n        this.isSnapped = false;\r\n        this.isChecked = false; //Fixed bug where selections dragged offscreen wouldn't clear correctly.\r\n        this.spos.set(0, 0);\r\n        this.selectedPos.set(0, 0);\r\n        // Reset studs to match the final brick position\r\n    }\r\n\r\n    /** Set the brick to match the cursor position, based on its stored selected position */\r\n    public setToCursor(): void {\r\n\r\n        // Position based difference between stored selected position and new cursor position\r\n        // Brick position is its position relative to the cursor\r\n        this.spos = this.engine.mouse.getPos().getSub(this.selectedPos).getClamp({\r\n            // Clamp above minimum-x position\r\n            x: (BOUNDARY.minx - this.minCarry.x) * GMULTX,\r\n            // Clamp above minimum-y position\r\n            y: (BOUNDARY.miny - this.minCarry.y) * GMULTY\r\n        }, {  \r\n            // Clamp below maximum-x position\r\n            x: (BOUNDARY.maxx - this.maxCarry.x) * GMULTX,\r\n            // Clamp below maximum-y position\r\n            y: (BOUNDARY.maxy - this.maxCarry.y) * GMULTY\r\n        });    \r\n\r\n        // Grid positioning\r\n        if (this.isSnapped) {\r\n            this.spos.set({\r\n                x : round(this.spos.x, GMULTX),\r\n                y : round(this.spos.y, GMULTY)\r\n            });\r\n        }\r\n    }\r\n\r\n    /** Snap this brick to the grid based on the given state */\r\n    public snap(state: boolean): void {\r\n\r\n        // Snap or unsnap based on the given state\r\n        this.isSnapped = state;\r\n\r\n        // Reposition for unsnapped state to fix 1-frame jump on pickup\r\n        if(!this.isSnapped) {            \r\n            this.setToCursor();\r\n        }\r\n    }\r\n\r\n    /** Clear this brick's recursion states */\r\n    public clearRecursion() {\r\n        this.isGrounded = false;\r\n        this.isChecked = false;\r\n    }\r\n\r\n    /** Set the minimum and maximum carry positions of this brick */\r\n    public setMinMax(min: Vect, max: Vect): void {\r\n\r\n        this.minCarry = min;\r\n        this.maxCarry = max;\r\n\r\n        this.mobilePreviewSize = max.getSub(min); //asdf\r\n    }\r\n\r\n    /** Set the flipped state for the mobile preview */\r\n    public flipMobile(isFlipped : boolean) {\r\n\r\n        this.isMobileFlipped = isFlipped;\r\n    }\r\n}"],
  "mappings": "AAAA;AAEA;AACA;AAHA,mCAUmC;AAAA,EAkD/B,YAAsB;AAClB,UAAM,SAAQ;AADI;AAzCZ,iBAAQ,IAAI;AAGf,oBAAW;AAMX,qBAAY;AAGZ,sBAAa;AAGZ,qBAAY;AAGZ,uBAAc,IAAI,KAAK,GAAG;AAG3B,sBAAa;AAGb,qBAAY;AAGZ,oBAAW;AAGV,oBAAkB,IAAI,KAAK,GAAG;AAG9B,oBAAkB,IAAI,KAAK,GAAG;AAG5B,6BAA2B,IAAI,KAAK,GAAG;AAGzC,2BAA4B;AAKhC,SAAK,QAAQ,eAAe,OAAO;AACnC,SAAK,SAAS,CAAC,OAAO;AAEtB,SAAK,KAAK,KAAK;AAEf,SAAK,QAAQ,OAAO,SAAS;AAAA;AAAA,EAG1B;AAGH,QAAI,KAAK;AACL,WAAK;AAAA;AAAA;AAAA,EAIN;AAGH,QAAI,cACA,KAAK,YAAY,OACjB,KAAK,aAAa,MAClB,KAAK,YAAY,OACjB;AAGJ,QAAI,UAAU,KAAK,OAAO,GAAG,CAAC,UAAU;AAAA;AAAA,EAGrC;AAEH,QAAI,KAAK,OAAO,MAAM,kBAAkB,WACrC,CAAC,KAAK,cACN,CAAC,mBAAmB,eAAe,KAAK;AACvC;AAAA;AAIJ,QAAI,UACA,KAAK,OACL,GACA,CAAE,UACA,IACA,SACE,MAAK,kBACN,CAAC,KAAK,kBAAkB,IAAI,MAC3B,KAAK,kBAAkB,IAAI;AAAA;AAAA,EAIhC;AAGH,QAAG,KAAK;AACJ,aAAO,UACH,KAAK,KAAK,OAAO;AAAA,QACb,GAAI,KAAK,MAAM,KAAK,KAAK,IAAI;AAAA,QAC7B,GAAI,KAAK,MAAM,KAAK,KAAK,IAAI;AAAA,UAEjC,KAAK,QAAQ;AAAA;AAGrB,QAAG,KAAK;AACJ,aAAO;AAAA;AAIP,aAAO,UAAU,KAAK,MAAM,KAAK,QAAQ;AAAA;AAAA;AAAA,EAK1C;AAGH,QAAI,CAAC,KAAK;AACN,WAAK,YAAY;AAAA;AAAA;AAAA,EAKlB;AAGH,SAAK,aAAa;AAElB,SAAK,YAAY;AAEjB,SAAK,YAAY,IAAI;AAAA;AAAA,EAIlB;AAGH,QAAI,KAAK;AAEL,WAAK,KAAK,IACN,KAAK,KAAK,IAAI,KAAK,MAAM,KAAK,KAAK,IAAI,SACvC,KAAK,KAAK,IAAI,KAAK,MAAM,KAAK,KAAK,IAAI;AAAA;AAK/C,SAAK,YAAY;AACjB,SAAK,aAAa;AAClB,SAAK,YAAY;AACjB,SAAK,YAAY;AACjB,SAAK,KAAK,IAAI,GAAG;AACjB,SAAK,YAAY,IAAI,GAAG;AAAA;AAAA,EAKrB;AAIH,SAAK,OAAO,KAAK,OAAO,MAAM,SAAS,OAAO,KAAK,aAAa,SAAS;AAAA,MAErE,GAAI,UAAS,OAAO,KAAK,SAAS,KAAK;AAAA,MAEvC,GAAI,UAAS,OAAO,KAAK,SAAS,KAAK;AAAA,OACxC;AAAA,MAEC,GAAI,UAAS,OAAO,KAAK,SAAS,KAAK;AAAA,MAEvC,GAAI,UAAS,OAAO,KAAK,SAAS,KAAK;AAAA;AAI3C,QAAI,KAAK;AACL,WAAK,KAAK,IAAI;AAAA,QACV,GAAI,MAAM,KAAK,KAAK,GAAG;AAAA,QACvB,GAAI,MAAM,KAAK,KAAK,GAAG;AAAA;AAAA;AAAA;AAAA,EAM5B;AAGH,SAAK,YAAY;AAGjB,QAAG,CAAC,KAAK;AACL,WAAK;AAAA;AAAA;AAAA,EAKN;AACH,SAAK,aAAa;AAClB,SAAK,YAAY;AAAA;AAAA,EAId;AAEH,SAAK,WAAW;AAChB,SAAK,WAAW;AAEhB,SAAK,oBAAoB,IAAI,OAAO;AAAA;AAAA,EAIjC;AAEH,SAAK,kBAAkB;AAAA;AAAA;",
  "names": []
}
