{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\brick.ts"],
  "sourcesContent": ["import GameObject, {GameObjectParams} from \"engine/gameobjects/gameobject\";\r\nimport Engine from \"engine/engine\";\r\nimport { colorTranslate, GMULTY, Z_DEPTH, GMULTX, BOUNDARY, round, UNDER_CURSOR_Z_INDEX, getZIndex } from \"engine/utilities/math\";\r\nimport Vect, {Point} from \"engine/utilities/vect\";\r\nimport BrickStud from \"./brickstud\";\r\n\r\ninterface BrickParams extends GameObjectParams {\r\n    color?: string;\r\n    width?: number;\r\n}\r\n\r\nexport default class Brick extends GameObject {\r\n    /** The color of this brick */\r\n    private color: string;\r\n\r\n    /** If this is a grey brick */\r\n    public isGrey: boolean;\r\n\r\n    /** Baked image data for this brick */\r\n    private image = new Image();\r\n\r\n    /** Brick segments (Left, Middle, Right) */\r\n    private brickSprites: Map<string, HTMLImageElement> = new Map<string, HTMLImageElement>();\r\n\r\n    /** Char keys for each brick sprite */\r\n    private brickSpriteKeys: Map<string, Boolean> = new Map<string, Boolean>([\r\n        [\"l\", false],\r\n        [\"m\", false],\r\n        [\"r\", false],\r\n        [\"h\", true]\r\n    ]);\r\n\r\n    /** If this is a static brick that will never move (grey or blocked by grey bricks), calculated later */\r\n    public isStatic = false;\r\n\r\n    /** Width of this brick */\r\n    public width: number;\r\n\r\n    /** If this brick is pressed */\r\n    public isPressed = false;\r\n\r\n    /** If this brick is selected */\r\n    public isSelected = false;\r\n\r\n    /** If this brick is snapped to a position */\r\n    private isSnapped = false;\r\n\r\n    /** Relative selected position */\r\n    private selectedPos = new Vect(0, 0);\r\n\r\n    /** Temporary recursion state */\r\n    public isGrounded = false;\r\n\r\n    /** Temporary recursion state */\r\n    public isChecked = false;\r\n\r\n    /** Number of objects on top of this brick */\r\n    public pressure = 0;\r\n\r\n    /** The stud objects for this brick */\r\n    public studs: BrickStud[] = [];\r\n\r\n    /** Boundary offset for minimum carried position */\r\n    private minCarry = new Vect(0, 0);\r\n\r\n    /** Boundary offset for maximum carried position */\r\n    private maxCarry = new Vect(0, 0);\r\n\r\n    constructor(protected engine: Engine, params: BrickParams) {\r\n        super(engine, params);\r\n        \r\n        this.color = colorTranslate(params.color);\r\n        this.isGrey = !params.color;\r\n\r\n        this.width = params.width || 1;\r\n        // Z-sort vertically and then horizontally.\r\n        this.zIndex = getZIndex(this.gpos, this.width * 10);\r\n\r\n        // Spawn studs across the width of this brick\r\n        // For each width unit of this brick\r\n        for (let i = 0; i < this.width; i++) {\r\n            const stud = new BrickStud(this.engine, {\r\n                ...params,\r\n                // Stud has a different position than its parent brick\r\n                position: {\r\n                    // Studs go across the brick\r\n                    x : this.gpos.x + i,\r\n                    // Studs are above the brick\r\n                    y : this.gpos.y - 1\r\n                }\r\n            });\r\n            this.studs.push(stud);\r\n\r\n            // Add stud game objects to scene\r\n            this.parent.pushGO(stud);\r\n        }\r\n\r\n        //Get image for each brick sprite key\r\n        this.brickSpriteKeys.forEach((needsGrey, spriteKey) => {\r\n            if(!needsGrey || this.isGrey) { //Check if the key is grey-brick exclusive\r\n                this.brickSprites.set(\r\n                    spriteKey, \r\n                    engine.library.getImage(`brick_${spriteKey}_${this.color.replace(\"#\", \"\").toLowerCase()}`));\r\n            }\r\n        });\r\n    }\r\n\r\n    public init() {\r\n\r\n        var imageName = `BRICK.${this.width}.${this.color}`;\r\n\r\n        this.image = this.engine.library.getImageWithSrc(\r\n            imageName,\r\n            this.engine.baker.bake(\r\n                ctx => this.drawBrick(ctx),\r\n                // Width to contain the brick, the right face, and the border\r\n                this.width * GMULTX + Z_DEPTH + 3,\r\n                // Height to contain the brick, the top face, and the border\r\n                GMULTY + Z_DEPTH + 3,\r\n                imageName));\r\n    }\r\n\r\n    public update(dt: number): void {\r\n\r\n        // Follow mouse if selected\r\n        if (this.isSelected) {\r\n            this.setToCursor();\r\n        }\r\n    }\r\n\r\n    public draw(ctx: CanvasRenderingContext2D): void {\r\n\r\n        // Global transparency for selection states\r\n        ctx.globalAlpha =\r\n            this.isSnapped ? 0.75 : // Snapped bricks are transparent\r\n            this.isSelected ? 0.4 : // Selected bricks are more transparent\r\n            this.isPressed ? 0.75 : // Pressed bricks are less transparent again\r\n            1.0;                    // Otherwise opaque if not selected or pressed\r\n        \r\n        // Draw with vertical offset for top face\r\n        ctx.drawImage(this.image, 0, -Z_DEPTH - 3);\r\n\r\n        // Debug - draw pressure\r\n        // if(this.pressure > 0) {\r\n        //     ctx.strokeStyle = \"#F00\";\r\n        //     ctx.lineWidth = 5;\r\n        //     ctx.beginPath();\r\n        //     ctx.moveTo(0                  , 0);\r\n        //     ctx.lineTo(GMULTX * this.width, GMULTY);\r\n        //     ctx.moveTo(GMULTX * this.width, 0);\r\n        //     ctx.lineTo(0                  , GMULTY);\r\n        //     ctx.stroke();\r\n        // }\r\n    }\r\n\r\n    /** Set the brick to match the cursor position, based on its stored selected position */\r\n    public setToCursor(): void {\r\n        // Position based difference between stored selected position and new cursor position\r\n        // Brick position is its position relative to the cursor\r\n        this.spos = this.engine.mouse.getPos().getSub(this.selectedPos).getClamp({\r\n            // Clamp above minimum-x position\r\n            x: (BOUNDARY.minx - this.minCarry.x) * GMULTX,\r\n            // Clamp above minimum-y position\r\n            y: (BOUNDARY.miny - this.minCarry.y) * GMULTY\r\n        }, {  \r\n            // Clamp below maximum-x position\r\n            x: (BOUNDARY.maxx - this.maxCarry.x) * GMULTX,\r\n            // Clamp below maximum-y position\r\n            y: (BOUNDARY.maxy - this.maxCarry.y) * GMULTY\r\n        });    \r\n\r\n        // Grid positioning\r\n        if (this.isSnapped) {\r\n            this.spos.set({\r\n                x : round(this.spos.x, GMULTX),\r\n                y : round(this.spos.y, GMULTY)\r\n            });\r\n        }\r\n\r\n        // Set studs to match the position of this brick while selected.\r\n        this.resetStuds();\r\n    }\r\n\r\n    // Setup this brick for pressing\r\n    public press(): void {\r\n        // Can't press static bricks\r\n        if (!this.isStatic) {\r\n            this.isPressed = true;\r\n            // Press studs for transparency\r\n            this.studs.forEach(s => s.press());\r\n        }\r\n    }\r\n\r\n    /** Setup this brick for selecting */\r\n    public select(pos: Point): void {\r\n        this.isSelected = true;\r\n        // Check so this brick is ignored for float checks\r\n        this.isChecked = true;\r\n        // Store mouse's current position for relative calculations later\r\n        this.selectedPos.set(pos);\r\n        // Set z-index to draw this brick under the cursor\r\n        this.zIndex = UNDER_CURSOR_Z_INDEX;\r\n        // Select studs for transparency\r\n        this.studs.forEach(s => s.select());\r\n    }\r\n\r\n    /** Clear this brick's selection states */\r\n    public deselect(): void {\r\n        // Restore grid position for deselection\r\n        if (this.isSelected) {\r\n            // Snap sub position to the grid for the new position\r\n            this.gpos.set(\r\n                this.gpos.x + Math.round(this.spos.x / GMULTX),\r\n                this.gpos.y + Math.round(this.spos.y / GMULTY)\r\n            );\r\n        }\r\n\r\n        // Restore states & values\r\n        this.isPressed = false;\r\n        this.isSelected = false;\r\n        this.isSnapped = false;\r\n        this.isChecked = false; //Fixed bug where selections dragged offscreen wouldn't clear correctly.\r\n        this.spos.set(0, 0);\r\n        this.selectedPos.set(0, 0);\r\n        this.zIndex = getZIndex(this.gpos, this.width * 10);\r\n        // Reset studs to match the final brick position\r\n        this.resetStuds();\r\n        this.studs.forEach(s => s.deselect());\r\n    }\r\n\r\n    // Set this brick's snap state\r\n    public snap(state: boolean): void {\r\n        this.studs.forEach(s => s.snap(state));\r\n\r\n        // Snap or unsnap based on the given state\r\n        if (state) {\r\n            this.isSnapped = true;\r\n            this.zIndex = getZIndex(this.gpos.getAdd({\r\n                x : Math.round(this.spos.x / GMULTX),\r\n                y : Math.round(this.spos.y / GMULTY)\r\n            }),\r\n            this.width * 10);\r\n        } else {\r\n            this.isSnapped = false;\r\n            // Set Z-index for dragging\r\n            this.zIndex = UNDER_CURSOR_Z_INDEX;\r\n            // Reposition for unsnapped state to fix 1-frame jump on pickup\r\n            this.setToCursor();\r\n        }\r\n    }\r\n\r\n    /** Clear this brick's recursion states */\r\n    public clearRecursion() {\r\n        this.isGrounded = false;\r\n        this.isChecked = false;\r\n    }\r\n\r\n    /** Reset studs to match the position of this brick */\r\n    private resetStuds(): void {\r\n        for (const [idx, stud] of this.studs.entries()) {\r\n            // Set stud global pos to match this brick\r\n            stud.gpos.set(this.gpos.x + idx, this.gpos.y - 1);\r\n            // Set stud sub pos to match this brick\r\n            stud.spos.set(this.spos);\r\n        }\r\n    }\r\n\r\n    /** Set the minimum and maximum carry positions of this brick */\r\n    public setMinMax(min: Vect, max: Vect): void {\r\n        this.minCarry = min;\r\n        this.maxCarry = max;\r\n    }\r\n\r\n    /** Build the sprite for this brick */\r\n    private drawBrick(ctx: CanvasRenderingContext2D): void {\r\n\r\n        ctx.save();\r\n\r\n        //Draw left side\r\n        ctx.drawImage(this.brickSprites.get(\"l\")!!, 0, 0);\r\n        ctx.translate(30, 0);\r\n\r\n        //Draw middle segments\r\n        for (let j = 1; j < this.width; j++) {\r\n            ctx.drawImage(this.brickSprites.get(\"m\")!!, 0, 0);\r\n            ctx.translate(30, 0);\r\n        }\r\n\r\n        //Draw right side\r\n        ctx.drawImage(this.brickSprites.get(\"r\")!!, 0, 0);\r\n        ctx.restore();\r\n\r\n        // Grey holes\r\n        if (this.isGrey) {\r\n\r\n            // Draw hole for each brick width, except for the last one\r\n            for (let j = 1; j < this.width; j++) {\r\n\r\n                ctx.drawImage(this.brickSprites.get(\"h\")!!, 30 * (j - 1), 0);\r\n            }\r\n        }\r\n    }\r\n}"],
  "mappings": "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",
  "names": []
}
