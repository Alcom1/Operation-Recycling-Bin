{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\cursor.ts"],
  "sourcesContent": ["import GameObject from \"engine/gameobjects/gameobject\";\r\nimport { MouseState } from \"engine/modules/mouse\";\r\nimport Scene from \"engine/scene/scene\";\r\nimport Vect from \"engine/utilities/vect\";\r\nimport BrickHandler, { BrickHandlerState } from \"./brickhandler\";\r\nimport CursorIcon, { CursorIconState } from \"./cursoricon\";\r\n\r\nenum CursorState {\r\n    NONE,\r\n    DRAG,\r\n    CARRY,\r\n    HOVER\r\n}\r\n\r\nexport default class Cursor extends GameObject {\r\n    /** Previous pressed position */\r\n    private ppos = new Vect(0, 0);\r\n    /** Distance to enter carry state */\r\n    private pLength = 10;\r\n\r\n    private state = CursorState.NONE;\r\n    private hoverState = BrickHandlerState.NONE;\r\n    private snapState = false;\r\n\r\n    /** Level containing bricks */\r\n    private level!: Scene;\r\n\r\n    private isUpdateForced = false;\r\n\r\n    public brickHandler!: BrickHandler;\r\n\r\n    private cursorIcon!: CursorIcon;\r\n\r\n    public init(ctx: CanvasRenderingContext2D, scenes: Scene[]) {\r\n        \r\n        // Get level containing bricks.\r\n        const level = scenes.find(s => s.name == \"Level\");\r\n        if (!level) throw new Error(\"Can't find level\");\r\n        this.level = level;\r\n\r\n        const brickHandler = this.engine.tag.get(\"BrickHandler\", \"LevelInterface\")[0];\r\n        if (!brickHandler) throw new Error(\"Can't find BrickHandler\");\r\n        this.brickHandler = brickHandler as BrickHandler;\r\n\r\n        const cursorIcon = this.engine.tag.get(\"CursorIcon\", \"LevelInterface\")[0];\r\n        if (!cursorIcon) throw new Error(\"Can't find CursorIcon\");\r\n        this.cursorIcon = cursorIcon as CursorIcon;\r\n    }\r\n\r\n    public update(dt: number): void {\r\n        var tempSpos = this.engine.mouse.getPos();\r\n\r\n        // Handle cursor state\r\n        if (this.isUpdateForced || tempSpos.getDiff(this.spos) || this.brickHandler.isPressured) {\r\n\r\n            // Reset update forcing\r\n            this.isUpdateForced = false;\r\n            \r\n            switch (this.state) {\r\n\r\n                case CursorState.NONE:\r\n                case CursorState.HOVER:\r\n                    this.hoverBricks(tempSpos);\r\n                    break;\r\n\r\n                case CursorState.DRAG:\r\n                    // Get difference between current and previously pressed positions\r\n                    const diff = this.spos.y - this.ppos.y;\r\n                    // If we've dragged a sufficient distance\r\n                    if (Math.abs(diff) > this.pLength) {\r\n                        // Math.sign only ever returns +/-1, +/-0, or NaN. It won't be NaN,\r\n                        // and it can never be 0, because we've ensured it's greater than pLength,\r\n                        // which is never going to be negative anyways\r\n                        const dir = Math.sign(diff) as (-1 | 1);\r\n                        // Select bricks in the direction of the difference\r\n                        this.selectBricks(dir);\r\n                    }\r\n                    break;\r\n\r\n                case CursorState.CARRY:\r\n                    this.snapState = this.brickHandler.checkSelectionCollision();\r\n                    this.brickHandler.setSnappedBricks(this.snapState);\r\n                    this.level.sortGO();\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // Set current position\r\n        this.spos = tempSpos;\r\n\r\n        switch (this.engine.mouse.getMouseState()) {\r\n            case MouseState.WASPRESSED:\r\n                // MOBILE - If a press event occurs in a NONE state/without a press (Only occurs on Mobile)\r\n                if (this.state == CursorState.NONE) {\r\n\r\n                    this.hoverBricks(this.spos);\r\n\r\n                } else if(this.state == CursorState.HOVER) {\r\n\r\n                    // If pressing the brick returns true (Indeterminate state)\r\n                    if (this.brickHandler.pressBricks(this.spos)) {\r\n\r\n                        this.carry();\r\n\r\n                    } else {\r\n                        // No selection occurred - Indeterminate state.\r\n                        // Set pressed position to the current cursor position\r\n                        this.ppos = this.spos;\r\n                        // Enter DRAG state to later determine what direction we're selecting in\r\n                        this.drag();\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case MouseState.WASRELEASED:\r\n                //Reset state upon release\r\n                // If the current state is not carrying or if the bricks are snapped to a valid location\r\n                if (this.state != CursorState.CARRY || this.snapState) {\r\n                    \r\n                    this.brickHandler.deselectBricks();\r\n\r\n                    // If we are deselecting bricks\r\n                    if (this.snapState) {\r\n                        this.brickHandler.cullBrickStuds();\r\n                    }\r\n\r\n                    //Sort for new brick z-indices\r\n                    this.level.sortGO();\r\n\r\n                    this.isUpdateForced = true;\r\n                    this.state = CursorState.NONE;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /** Hover over bricks, change state based on hover state */\r\n    private hoverBricks(pos: Vect): void {\r\n\r\n        const hoverState = this.brickHandler.hoverBricks(pos);\r\n\r\n        switch(hoverState) {\r\n            case BrickHandlerState.NONE:\r\n                this.resetState();\r\n                break;\r\n\r\n            case BrickHandlerState.SAME:\r\n                break;\r\n\r\n            default:\r\n                this.hover(hoverState);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /** Select bricks in a given direction */\r\n    private selectBricks(dir: -1 | 1): void {\r\n\r\n        // Initialize the selection. If doing so caused bricks to be carried, enter carry state\r\n        if(this.brickHandler.initSelection(this.ppos, dir)) {\r\n\r\n            this.carry();\r\n        }  \r\n    }\r\n\r\n    /** Set cursor to no state */\r\n    private resetState(): void {\r\n\r\n        if(this.state != CursorState.NONE) {\r\n\r\n            this.cursorIcon.setCursor(CursorIconState.NONE);\r\n            // Ensure no brick is selected in the NONE state\r\n            this.brickHandler.selectedBrick = null;\r\n            this.state = CursorState.NONE;\r\n        }\r\n    }\r\n\r\n    /** Set cursor to its over state */\r\n    private hover(hoverState: BrickHandlerState): void {\r\n\r\n        if (this.state != CursorState.HOVER || this.hoverState != hoverState) {\r\n\r\n            switch(hoverState) {\r\n\r\n                case BrickHandlerState.INDY:\r\n                    this.cursorIcon.setCursor(CursorIconState.HOVER);\r\n                    break;\r\n\r\n                case BrickHandlerState.UP:\r\n                    this.cursorIcon.setCursor(CursorIconState.HOVERUP);\r\n                    break;\r\n\r\n                case BrickHandlerState.DOWN:\r\n                    this.cursorIcon.setCursor(CursorIconState.HOVERDOWN);\r\n                    break;\r\n            }\r\n\r\n            this.state = CursorState.HOVER;\r\n            this.hoverState = hoverState;\r\n        }\r\n    }\r\n\r\n    /** Set the cursor to its drag state */\r\n    private drag(): void {\r\n\r\n        if(this.state != CursorState.DRAG) {\r\n\r\n            this.cursorIcon.setCursor(CursorIconState.DRAG);\r\n            this.brickHandler.cullBrickStuds();\r\n            this.state = CursorState.DRAG;\r\n        }\r\n    }\r\n\r\n    /** Set the cursor to its carry state */\r\n    carry(): void {\r\n\r\n        if (this.state != CursorState.CARRY) {\r\n\r\n            this.cursorIcon.setCursor(CursorIconState.CARRY);\r\n        \r\n            this.brickHandler.cullBrickStuds();         // Reset culled studs\r\n            this.brickHandler.setSnappedBricks(true);   // Carried bricks should start as snapped\r\n            this.brickHandler.setSelectedMinMax();      // Set minimum and maximum position of carried bricks\r\n\r\n            this.level.sortGO();                        // Sort for new brick z-indices\r\n            this.state = CursorState.CARRY;             // Set state to NONE stateStart carrying if we selected some bricks\r\n        }\r\n    }\r\n}"],
  "mappings": "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",
  "names": []
}
