{
  "version": 3,
  "sources": ["/home/jonathan/Development/lego/Operation-Recycling-Bin/src/game/gameobjects/cursor.ts"],
  "sourcesContent": ["import GameObject from \"engine/gameobjects/gameobject\";\nimport { MouseState } from \"engine/modules/mouse\";\nimport Scene from \"engine/scene/scene\";\nimport Vect from \"engine/utilities/vect\";\nimport BrickHandler, { BrickHandlerState } from \"./brickhandler\";\nimport CursorIcon, { CursorIconState } from \"./cursoricon\";\n\nenum CursorState {\n    NONE,\n    DRAG,\n    CARRY,\n    HOVER\n}\n\nexport default class Cursor extends GameObject {\n    /** Previous pressed position */\n    private ppos = new Vect(0, 0);\n    /** Distance to enter carry state */\n    private pLength = 10;\n\n    private state = CursorState.NONE;\n    private hoverState = BrickHandlerState.NONE;\n    private snapState = false;\n\n    /** Level containing bricks */\n    private level!: Scene;\n\n    private isUpdateForced = false;\n\n    public brickHandler!: BrickHandler;\n    private cursorIcon!: CursorIcon;\n\n    public init(ctx: CanvasRenderingContext2D, scenes: Scene[]) {\n        // Get level containing bricks.\n        const level = scenes.find(s => s.name == \"Level\");\n        if (!level) throw new Error(\"Can't find level\");\n        this.level = level;\n\n        const brickHandler = this.engine.tag.get(\"BrickHandler\", \"LevelInterface\")[0];\n        if (!brickHandler) throw new Error(\"Can't find BrickHandler\");\n        this.brickHandler = brickHandler as BrickHandler;\n\n        const cursorIcon = this.engine.tag.get(\"CursorIcon\", \"LevelInterface\")[0];\n        if (!cursorIcon) throw new Error(\"Can't find CursorIcon\");\n        this.cursorIcon = cursorIcon as CursorIcon;\n    }\n\n    public update(dt: number): void {\n        var tempSpos = this.engine.mouse.getPos();\n\n        // Handle cursor state when the mouse moves\n        if (this.isUpdateForced || tempSpos.getDiff(this.spos)) {\n            // Reset update forcing\n            this.isUpdateForced = false;\n            \n            switch (this.state) {\n                case CursorState.NONE:\n\n                case CursorState.HOVER:\n                    this.hoverBricks(tempSpos);\n                    break;\n\n                case CursorState.DRAG:\n                    // Get difference between current and previously pressed positions\n                    const diff = this.spos.y - this.ppos.y;\n                    // If we've dragged a sufficient distance\n                    if (Math.abs(diff) > this.pLength) {\n                        // Math.sign only ever returns +/-1, +/-0, or NaN. It won't be NaN,\n                        // and it can never be 0, because we've ensured it's greater than pLength,\n                        // which is never going to be negative anyways\n                        const dir = Math.sign(diff) as (-1 | 1);\n                        // Select bricks in the direction of the difference\n                        this.selectBricks(dir);\n                    }\n                    break;\n\n                case CursorState.CARRY:\n                    this.snapState = this.brickHandler.checkSelectionCollision();\n                    this.brickHandler.setSnappedBricks(this.snapState);\n                    this.level.sortGO();\n                    break;\n            }\n        }\n\n        // Set current position\n        this.spos = tempSpos;\n\n        switch (this.engine.mouse.getMouseState()) {\n            case MouseState.WASPRESSED:\n                // MOBILE - If a press event occurs in a NONE state/without a press (Only occurs on Mobile)\n                if (this.state == CursorState.NONE) {\n                    this.hoverBricks(this.spos);\n                } else if(this.state == CursorState.HOVER) {\n                    // If pressing the brick returns true (Indeterminate state)\n                    if (this.brickHandler.pressBricks(this.spos)) {\n                        this.carry();\n                    } else {\n                        // No selection occurred - Indeterminate state.\n                        // Set pressed position to the current cursor position\n                        this.ppos = this.spos;\n                        // Enter DRAG state to later determine what direction we're selecting in\n                        this.drag();\n                    }\n                }\n                break;\n\n            case MouseState.WASRELEASED:\n                //Reset state upon release\n                // If the current state is not carrying or if the bricks are snapped to a valid location\n                if (this.state != CursorState.CARRY || this.snapState) {\n                    this.brickHandler.deselectBricks();\n                    // If we are deselecting bricks\n                    if (this.snapState) {\n                        this.brickHandler.cullBrickStuds();\n                    }\n                    //Sort for new brick z-indices\n                    this.level.sortGO();\n\n                    this.isUpdateForced = true;\n                    this.state = CursorState.NONE;\n                }\n                break;\n        }\n    }\n\n    /** Hover over bricks, change state based on hover state */\n    private hoverBricks(pos: Vect): void {\n        const hoverState = this.brickHandler.hoverBricks(pos);\n        switch(hoverState) {\n            case BrickHandlerState.NONE:\n                this.resetState();\n                break;\n\n            case BrickHandlerState.SAME:\n                break;\n\n            default:\n                this.hover(hoverState);\n                break;\n        }\n    }\n\n    private selectBricks(dir: -1 | 1): void {\n        // Initialize the selection. If doing so caused bricks to be carried, enter carry state\n        if(this.brickHandler.initSelection(this.ppos, dir)) {\n            this.carry();\n        }  \n    }\n\n    /** Set cursor to no state */\n    private resetState(): void {\n        if(this.state != CursorState.NONE) {\n            this.cursorIcon.setCursor(CursorIconState.NONE);\n            // Ensure no brick is selected in the NONE state\n            this.brickHandler.selectedBrick = null;\n            this.state = CursorState.NONE;\n        }\n    }\n\n    /** Set cursor to its over state */\n    private hover(hoverState: BrickHandlerState): void {\n        if (this.state != CursorState.HOVER || this.hoverState != hoverState) {\n            switch(hoverState) {\n                case BrickHandlerState.INDY:\n                    this.cursorIcon.setCursor(CursorIconState.HOVER);\n                    break;\n\n                case BrickHandlerState.UP:\n                    this.cursorIcon.setCursor(CursorIconState.HOVERUP);\n                    break;\n\n                case BrickHandlerState.DOWN:\n                    this.cursorIcon.setCursor(CursorIconState.HOVERDOWN);\n                    break;\n            }\n\n            this.state = CursorState.HOVER;\n            this.hoverState = hoverState;\n        }\n    }\n\n    /** Set the cursor to its drag state */\n    private drag(): void {\n        if(this.state != CursorState.DRAG) {\n            this.cursorIcon.setCursor(CursorIconState.DRAG);\n            this.brickHandler.cullBrickStuds();\n            this.state = CursorState.DRAG;\n        }\n    }\n\n    /** Set the cursor to its carry state */\n    carry(): void {\n        if (this.state != CursorState.CARRY) {\n            this.cursorIcon.setCursor(CursorIconState.CARRY);\n        \n            this.brickHandler.cullBrickStuds();         // Reset culled studs\n            this.brickHandler.setSnappedBricks(true);   // Carried bricks should start as snapped\n            this.brickHandler.setSelectedMinMax();      // Set minimum and maximum position of carried bricks\n\n            this.level.sortGO();                        // Sort for new brick z-indices\n            this.state = CursorState.CARRY;             // Set state to NONE stateStart carrying if we selected some bricks\n        }\n    }\n}"],
  "mappings": "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",
  "names": []
}
