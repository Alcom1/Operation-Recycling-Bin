{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\bricknormal.ts"],
  "sourcesContent": ["import { col1D, GMULTX, GMULTY, Z_DEPTH } from \"engine/utilities/math\";\r\nimport Vect, { Point } from \"engine/utilities/vect\";\r\nimport Brick, { BrickParams } from \"./brick\";\r\nimport Stud from \"./stud\";\r\n\r\n/** Ordinary brick with studs */\r\nexport default class BrickNormal extends Brick {\r\n\r\n    /** The stud objects for this brick */\r\n    private studs: Stud[] = [];\r\n    \r\n    /** Brick segments (Left, Middle, Right) */\r\n    private brickSprites: Map<string, HTMLImageElement> = new Map<string, HTMLImageElement>();\r\n\r\n    /** Char keys for each brick sprite */\r\n    private brickSpriteKeys: Map<string, Boolean> = new Map<string, Boolean>([\r\n        [\"l\", false],\r\n        [\"m\", false],\r\n        [\"r\", false],\r\n        [\"h\", true]\r\n    ]);\r\n\r\n    /** Constructor */\r\n    constructor(params: BrickParams) {\r\n        super(params);\r\n\r\n        // Spawn studs across the width of this brick\r\n        // For each width unit of this brick\r\n        for (let i = 0; i < this.width; i++) {\r\n            const stud = new Stud({\r\n                ...params,\r\n                // Stud has a different position than its parent brick\r\n                position: {\r\n                    // Studs go across the brick\r\n                    x : this.gpos.x + i,\r\n                    // Studs are above the brick\r\n                    y : this.gpos.y - 1\r\n                }\r\n            });\r\n            this.studs.push(stud);\r\n\r\n            // Add stud game objects to scene\r\n            this.parent.pushGO(stud);\r\n        }\r\n        \r\n        // Get image for each brick sprite key\r\n        this.brickSpriteKeys.forEach((needsGrey, spriteKey) => {\r\n            if (!needsGrey || this.isGrey) {    // Check if the key is grey-brick exclusive\r\n                this.brickSprites.set(\r\n                    spriteKey, \r\n                    this.engine.library.getImage(`brick_${spriteKey}_${this.color.replace(\"#\", \"\").toLowerCase()}`));\r\n            }\r\n        });\r\n    }    \r\n\r\n    /** Initialize brick sprite */\r\n    public init() {\r\n\r\n        var imageName = `BRICK.${this.width}.${this.color}`;\r\n\r\n        this.image = this.engine.library.getImageWithSrc(\r\n            imageName,\r\n            this.engine.baker.bake(\r\n                ctx => this.drawBrick(ctx),\r\n                // Width to contain the brick, the right face, and the border\r\n                this.width * GMULTX + Z_DEPTH + 3,\r\n                // Height to contain the brick, the top face, and the border\r\n                GMULTY + Z_DEPTH + 3,\r\n                imageName));\r\n    }\r\n    \r\n    /** Setup this brick for pressing */\r\n    public press(): void {\r\n        super.press();\r\n\r\n        // Can't press static bricks\r\n        if (!this.isStatic) {\r\n            this.studs.forEach(s => s.press());\r\n        }\r\n    }\r\n\r\n    /** Setup this brick for selecting */\r\n    public select(pos: Point): void {\r\n        super.select(pos);\r\n\r\n        // Select studs for transparency\r\n        this.studs.forEach(s => s.select());\r\n    }\r\n\r\n    /** Clear this brick's selection states */\r\n    public deselect(): void {\r\n        super.deselect();\r\n\r\n        this.resetStuds(true);\r\n    }\r\n\r\n    /** Set the brick to match the cursor position, based on its stored selected position */\r\n    public setToCursor(): void {\r\n        super.setToCursor();\r\n\r\n        // Set studs to match the position of this brick while selected.\r\n        this.resetStuds(false);\r\n    }\r\n\r\n    /** Snap this brick to the grid based on the given state */\r\n    public snap(state: boolean): void {\r\n        super.snap(state);\r\n\r\n        // Also snap the studs, of course.\r\n        this.studs.forEach(s => s.snap(state));\r\n    }\r\n\r\n    /** Hide this brick's studs based on a given above row */\r\n    public hideStuds(rowBricks: Brick[]) {\r\n\r\n        // For each stud\r\n        this.studs.forEach(s => {\r\n\r\n            s.isVisible = true;             // Default to visible\r\n\r\n            // For each brick in the above row\r\n            for (const brick of rowBricks) {\r\n                \r\n                if (!brick.isSelected &&    // Don't cull based on selected bricks\r\n                    !brick.isPressed &&     // Don't cull based on pressed bricks\r\n                    col1D(                  // Only cull based on bricks overlapping with this stud\r\n                        brick.gpos.x - 1, \r\n                        brick.gpos.x + brick.width, \r\n                        s.gpos.x, \r\n                        s.gpos.x\r\n                    )) {\r\n\r\n                    s.isVisible = false;    // Hide this stud if it's overlapped\r\n                    break;                  // Stop all checks once the stud is hidden\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Show this brick's studs unconditionally */\r\n    public showStuds() {\r\n        \r\n        this.studs.forEach(s => s.isVisible = true);\r\n    }\r\n \r\n    /** Reset studs to match the position of this brick */\r\n    private resetStuds(isDeselect : boolean): void {\r\n\r\n        // For each stud with index\r\n        for (const [idx, stud] of this.studs.entries()) {\r\n\r\n            // Set stud global pos to match this brick\r\n            stud.gpos.set(this.gpos.x + idx, this.gpos.y - 1);\r\n            // Set stud sub pos to match this brick\r\n            stud.spos.set(this.spos);\r\n            // Deselect this stud\r\n            if (isDeselect) {\r\n                stud.deselect();\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Set the minimum and maximum carry positions of this brick */\r\n    public setMinMax(min: Vect, max: Vect): void {\r\n\r\n        super.setMinMax(min, max);\r\n\r\n        this.studs.forEach(s => s.mobilePreviewSize = this.mobilePreviewSize);\r\n    }\r\n\r\n    /** Set the flipped state for the mobile preview */\r\n    public flipMobile(isFlipped : boolean) {\r\n        \r\n        super.flipMobile(isFlipped);\r\n\r\n        this.studs.forEach(s => s.flipMobile(isFlipped));\r\n    }\r\n\r\n    /** Build the sprite for this brick */\r\n    private drawBrick(ctx: CanvasRenderingContext2D): void {\r\n\r\n        ctx.save();\r\n\r\n        // Draw left side\r\n        ctx.drawImage(this.brickSprites.get(\"l\")!!, 0, 0);\r\n        ctx.translate(30, 0);\r\n\r\n        // Draw middle segments\r\n        for (let j = 1; j < this.width; j++) {\r\n            ctx.drawImage(this.brickSprites.get(\"m\")!!, 0, 0);\r\n            ctx.translate(30, 0);\r\n        }\r\n\r\n        // Draw right side\r\n        ctx.drawImage(this.brickSprites.get(\"r\")!!, 0, 0);\r\n        ctx.restore();\r\n\r\n        // Grey holes\r\n        if (this.isGrey) {\r\n\r\n            // Draw hole for each brick width, except for the last one\r\n            for (let j = 1; j < this.width; j++) {\r\n\r\n                ctx.drawImage(this.brickSprites.get(\"h\")!!, 30 * (j - 1), 0);\r\n            }\r\n        }\r\n    }\r\n}"],
  "mappings": "AAAA;AAEA;AACA;AAHA,yCAMyC;AAAA,EAiBrC,YAAY;AACR,UAAM;AAfF,iBAAgB;AAGhB,wBAA8C,IAAI;AAGlD,2BAAwC,IAAI,IAAqB;AAAA,MACrE,CAAC,KAAK;AAAA,MACN,CAAC,KAAK;AAAA,MACN,CAAC,KAAK;AAAA,MACN,CAAC,KAAK;AAAA;AASN,iBAAa,GAAG,IAAI,KAAK,OAAO;AAC5B,oBAAa,IAAI,KAAK;AAAA,WACf;AAAA,QAEH,UAAU;AAAA,UAEN,GAAI,KAAK,KAAK,IAAI;AAAA,UAElB,GAAI,KAAK,KAAK,IAAI;AAAA;AAAA;AAG1B,WAAK,MAAM,KAAK;AAGhB,WAAK,OAAO,OAAO;AAAA;AAIvB,SAAK,gBAAgB,QAAQ;AACzB,UAAI,CAAC,aAAa,KAAK;AACnB,aAAK,aAAa,IACd,WACA,KAAK,OAAO,QAAQ,SAAS,SAAS,aAAa,KAAK,MAAM,QAAQ,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA,EAMxF;AAEH,oBAAgB,SAAS,KAAK,SAAS,KAAK;AAE5C,SAAK,QAAQ,KAAK,OAAO,QAAQ,gBAC7B,WACA,KAAK,OAAO,MAAM,KACd,SAAO,KAAK,UAAU,MAEtB,KAAK,QAAQ,SAAS,UAAU,GAEhC,SAAS,UAAU,GACnB;AAAA;AAAA,EAIL;AACH,UAAM;AAGN,QAAI,CAAC,KAAK;AACN,WAAK,MAAM,QAAQ,OAAK,EAAE;AAAA;AAAA;AAAA,EAK3B;AACH,UAAM,OAAO;AAGb,SAAK,MAAM,QAAQ,OAAK,EAAE;AAAA;AAAA,EAIvB;AACH,UAAM;AAEN,SAAK,WAAW;AAAA;AAAA,EAIb;AACH,UAAM;AAGN,SAAK,WAAW;AAAA;AAAA,EAIb;AACH,UAAM,KAAK;AAGX,SAAK,MAAM,QAAQ,OAAK,EAAE,KAAK;AAAA;AAAA,EAI5B;AAGH,SAAK,MAAM,QAAQ;AAEf,QAAE,YAAY;AAGd,2BAAoB;AAEhB,YAAI,CAAC,OAAM,cACP,CAAC,OAAM,aACP,MACI,OAAM,KAAK,IAAI,GACf,OAAM,KAAK,IAAI,OAAM,OACrB,EAAE,KAAK,GACP,EAAE,KAAK;AAGX,YAAE,YAAY;AACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAOT;AAEH,SAAK,MAAM,QAAQ,OAAK,EAAE,YAAY;AAAA;AAAA,EAIlC;AAGJ,+BAA0B,KAAK,MAAM;AAGjC,YAAK,KAAK,IAAI,KAAK,KAAK,IAAI,KAAK,KAAK,KAAK,IAAI;AAE/C,YAAK,KAAK,IAAI,KAAK;AAEnB,UAAI;AACA,cAAK;AAAA;AAAA;AAAA;AAAA,EAMV;AAEH,UAAM,UAAU,KAAK;AAErB,SAAK,MAAM,QAAQ,OAAK,EAAE,oBAAoB,KAAK;AAAA;AAAA,EAIhD;AAEH,UAAM,WAAW;AAEjB,SAAK,MAAM,QAAQ,OAAK,EAAE,WAAW;AAAA;AAAA,EAIjC;AAEJ,QAAI;AAGJ,QAAI,UAAU,KAAK,aAAa,IAAI,MAAQ,GAAG;AAC/C,QAAI,UAAU,IAAI;AAGlB,iBAAa,GAAG,IAAI,KAAK,OAAO;AAC5B,UAAI,UAAU,KAAK,aAAa,IAAI,MAAQ,GAAG;AAC/C,UAAI,UAAU,IAAI;AAAA;AAItB,QAAI,UAAU,KAAK,aAAa,IAAI,MAAQ,GAAG;AAC/C,QAAI;AAGJ,QAAI,KAAK;AAGL,mBAAa,GAAG,IAAI,KAAK,OAAO;AAE5B,YAAI,UAAU,KAAK,aAAa,IAAI,MAAQ,KAAM,KAAI,IAAI;AAAA;AAAA;AAAA;AAAA;",
  "names": []
}
