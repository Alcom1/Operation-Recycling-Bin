{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\characterbot.ts"],
  "sourcesContent": ["import Character, { CharacterParams } from \"./character\";\r\nimport { BOUNDARY, bitStack, GMULTY, GMULTX, MASKS} from \"engine/utilities/math\";\r\nimport Animat, { AnimationParams } from \"./animation\";\r\nimport { Collider } from \"engine/modules/collision\";\r\nimport { Point } from \"engine/utilities/vect\";\r\n\r\ninterface CharacterBotParams extends CharacterParams {\r\n    animsMisc : AnimationInputParams[];\r\n}\r\n\r\ninterface AnimationInputParams extends AnimationParams {\r\n    isSliced? : boolean;\r\n}\r\n\r\nenum ArmorState {\r\n    NONE,\r\n    ACTIVE,\r\n    FLASH\r\n}\r\n\r\nenum AirState {\r\n    NONE,\r\n    JUMP,\r\n    UPWARD\r\n}\r\n\r\n//Bot parameters\r\nconst characterBotOverride = Object.freeze({\r\n    //Main parameters\r\n    height: 4,      //Bot is this tall\r\n    speed : 3,      //Bot moves fast\r\n    images : [      //Bot has left & right animations\r\n        { name : \"char_bot_left\", offsetX : 36 },\r\n        { name : \"char_bot_right\", offsetX : 14},\r\n        { name : \"char_bot_left_armor\", offsetX : 36 },\r\n        { name : \"char_bot_right_armor\", offsetX : 14}],\r\n    frameCount : 10,\r\n    animsCount : 2,\r\n\r\n    //Misc animation parameters\r\n    animsMisc : [{ //Bot-bin interaction animation\r\n        images : [{ name : \"char_bot_bin\" }],\r\n        gposOffset : { x : -1, y : 0},\r\n        zModifier : 150,\r\n        frameCount : 12\r\n    },{             //Bot explosion animation\r\n        images : [{ name : \"char_bot_explosion\" }],\r\n        gposOffset : { x : -3, y : 0},\r\n        zModifier : 600,\r\n        frameCount : 16,\r\n        isLoop : false\r\n    },{             //Bot up animation\r\n        images : [  //Flying has left & right animations\r\n            { name : \"char_bot_fly_left\", offsetX : 36 },\r\n            { name : \"char_bot_fly_right\", offsetX : 14 }],\r\n        speed : 2.5,    //Bot moves fast\r\n        gposOffset : { x : -1, y : 0},\r\n        frameCount : 10,\r\n        animsCount : 2,\r\n        isSliced : true\r\n    },{             //Bot armor animation\r\n        images : [  //Flying has left & right animations\r\n            { name : \"char_bot_armor_left\", offsetX : 36 },\r\n            { name : \"char_bot_armor_right\", offsetX : 14 }],\r\n        gposOffset : { x : -1, y : 0},\r\n        frameCount : 12,\r\n        isSliced : true\r\n    }]\r\n});\r\n\r\n//Collision bitmasks for bot-brick collisions\r\nconst gcb = Object.freeze({\r\n    flor : bitStack([0, 7]),\r\n    down : bitStack([1, 8]),\r\n    ceil : bitStack([2, 9]),\r\n    head : bitStack([3]),\r\n    wall : bitStack([4, 5]),\r\n    step : bitStack([6])\r\n});\r\n\r\n//Collision bitmasks for bot-brick collisions in air\r\nconst acb = Object.freeze({\r\n    flor : bitStack([0, 6]),\r\n    head : bitStack([1, 7]),\r\n    face : bitStack([8, 9, 10]),\r\n    shin : bitStack([11]),\r\n    foot : bitStack([12])\r\n});\r\n\r\nexport default class CharacterBot extends Character {\r\n\r\n    private timerSpc : number = 0;                          //Timer to track duration of special movements\r\n    private timerArm : number = 0;                          //Timer to track armor flash\r\n    private ceilSubOffset : number = -6;                    //Offset for up/down movement\r\n    private vertSpeed : number = 500;                       //Speed of air movement\r\n    private horzSpeed : number = 350;                       //Horizontal air speed\r\n    private jumpHeights : number[] = [0, 2, 3, 3, 2, 0];    //Individual heights throughout a jump\r\n    private jumpOrigin : Point = { x : 0, y : 0 }           //Origin of the previous jump\r\n    private airState : AirState = AirState.NONE;            //If currently flying\r\n    private armorDelay : number = 2;                        //Delay where armor remains after taking damage\r\n    private armorFlashRate : number = 8;                    //Rate of the armor flashing effect\r\n    private armorState : ArmorState = ArmorState.NONE;      //Current state of the armor\r\n\r\n    protected get animImageIndex() : number { \r\n        return this.move.x * (\r\n            this.armorState == ArmorState.ACTIVE ? 2 :\r\n            this.armorState == ArmorState.FLASH  ? (1 + Math.floor(this.timerArm * this.armorFlashRate) % 2) : \r\n            1)\r\n    }\r\n\r\n    constructor(params: CharacterBotParams) {\r\n        super(Object.assign(params, characterBotOverride));\r\n\r\n        //Setup miscellaneous animations.\r\n        params.animsMisc.forEach(m => {\r\n\r\n            //Build a new animation, store it here and in the scene\r\n            var newIndex = this.animatGroups.push([]) - 1;\r\n\r\n            //3 slices if sliced, 1 otherwise\r\n            for(let i = -1; i <= (m.isSliced ? 1 : -1); i ++) {\r\n\r\n                this.animatGroups[newIndex].push(new Animat({\r\n                    ...params,\r\n                    speed :      m.speed,\r\n                    images :     m.images,\r\n                    sliceIndex : m.isSliced ? i : null,\r\n                    framesSize : m.isSliced ? GMULTX * 2 : m.framesSize,\r\n                    gposOffset : m.gposOffset,\r\n                    zModifier :  m.isSliced ? (i < 1 ? 300 : 29) : m.zModifier,\r\n                    frameCount : m.frameCount,\r\n                    animsCount : m.animsCount,\r\n                    isLoop :     m.isLoop\r\n                } as AnimationParams));\r\n            }\r\n            this.animatGroups[newIndex].forEach(a => this.parent.pushGO(a));\r\n        });\r\n    }\r\n\r\n    //Unique bot update\r\n    public update(dt : number) {\r\n        super.update(dt);\r\n\r\n        //Update armor flash\r\n        if(this.armorState == ArmorState.FLASH) {\r\n            this.timerArm += dt;\r\n            this.animatGroupCurr.forEach(x => x.setImageIndex(this.animImageIndex));\r\n\r\n            //Remove armor after a duration and reset timer\r\n            if(this.timerArm > this.armorDelay) {\r\n                this.armorState = ArmorState.NONE;\r\n                this.timerArm = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    //Special movement\r\n    protected handleSpecialMovement(dt : number) {\r\n\r\n        this.timerSpc += dt;   //Update special timer\r\n\r\n        //Perform special movement\r\n        switch(this.animatGroupsIndex) {\r\n\r\n            case 1 :\r\n\r\n                this.moveVertical(dt, -1);\r\n                break;\r\n\r\n            //Vertical movement.\r\n            case 3 : \r\n                \r\n                //Bot is jumping\r\n                if (this.airState == AirState.JUMP) {\r\n                    this.moveJump(dt);\r\n                }\r\n                //Bot is moving vertically\r\n                else {\r\n\r\n                    this.moveVertical(dt, this.airState == AirState.UPWARD ?  1 : -1);\r\n                    this.airState = AirState.NONE;  //Unset for next collision check, UPWARD requires constant collision\r\n                }\r\n                break;\r\n            \r\n            //Default is do nothing\r\n            default :\r\n                break;\r\n        }\r\n\r\n        //If the current animation has ended\r\n        if(this.timerSpc > this.animatGroupCurr[0].duration) {\r\n\r\n            //Reset timer\r\n            this.timerSpc = 0;\r\n\r\n            switch(this.animatGroupsIndex) {\r\n\r\n                //Deactivate this character\r\n                case 2 :\r\n                    this.isActive = false;\r\n                    break;\r\n\r\n                //Reset up/down animation\r\n                case 3 :\r\n                    this.animatGroupCurr.forEach(a => a.reset());\r\n                    break;\r\n                \r\n                //End animation\r\n                default :\r\n                    this.setCurrentGroup(0);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    //Move in a jumping arc\r\n    private moveJump(dt: number) {\r\n\r\n        var index = Math.abs(this.gpos.x - this.jumpOrigin.x);  //Index of current jump height\r\n\r\n        //Don't jump past the level boundary\r\n        if ((index > 0 || Math.abs(this.spos.x) > GMULTX / 2) && (\r\n            this.gpos.x - 2 < BOUNDARY.minx || \r\n            this.gpos.x + 2 > BOUNDARY.maxx)) {\r\n\r\n            this.startVertMovement();\r\n            return;\r\n        }\r\n\r\n        //Collision bitmask\r\n        const cbm = this.brickHandler.checkCollisionRange(\r\n            this.gpos.getSub({\r\n                x : this.move.x > 0 ? 1 : 0, \r\n                y : this.height + 1\r\n            }),             //Position\r\n            this.move.x,    //Direction\r\n            5,              //START  n + 1\r\n            18,             //FINAL\r\n            6,              //HEIGHT n + 2\r\n            3);             //Width\r\n        \r\n        //Collide face if we're over half-way past the first step\r\n        if(cbm & acb.face && (index > 0 || Math.abs(this.spos.x) > GMULTX / 2)) {\r\n            this.startVertMovement();\r\n            return;\r\n        }\r\n        //Collide head if not at the peak of the jump\r\n        else if((cbm & acb.head || this.gpos.y <= BOUNDARY.miny + 3) && index < 2) {\r\n            this.startVertMovement();\r\n            return;\r\n        }\r\n        //collide shin after the first step\r\n        else if (cbm & acb.shin && index > 0) {\r\n            this.startVertMovement();\r\n            return;\r\n        }\r\n        //Collide with foot after the arc starts travelling downwards\r\n        else if (cbm & acb.foot && index > 2) {\r\n            this.startVertMovement();\r\n            return;\r\n        }\r\n        //Collide with floor after the first step\r\n        else if (cbm & acb.flor && index > 0) {\r\n            this.endAirMovement();\r\n            return;\r\n        }\r\n\r\n        //End of jump\r\n        if(index > this.jumpHeights.length - 2) {\r\n            this.startVertMovement();\r\n            return;\r\n        }\r\n\r\n        //Update position, travel in an arc based on the jump heights.\r\n        this.spos.x += this.move.x * this.horzSpeed * dt;       //Update horizontal position\r\n        this.spos.y = - GMULTY * (                              //Update vertical position\r\n            this.jumpHeights[index] + \r\n            this.gpos.y - \r\n            this.jumpOrigin.y +\r\n            Math.abs(this.spos.x / GMULTX) * (this.jumpHeights[index + 1] - this.jumpHeights[index]));\r\n\r\n        this.animatGroupCurr.forEach(a => a.spos = this.spos);  //Update animations to match current position\r\n    }\r\n\r\n    //Vertical motion\r\n    private moveVertical(dt: number, dir: number) {\r\n        \r\n        //If the direction has no obstacles\r\n        if (this.getCollisionVertical(dir)) {\r\n\r\n            this.spos.y -= dt * this.vertSpeed * dir;   //Move subposition vertically based on speed\r\n            this.animatGroupCurr.forEach(a => a.spos = this.spos);\r\n        }\r\n        //There is an obstacle, stop based on its direction\r\n        else {\r\n\r\n            //If going upwards, collide with ceiling\r\n            if(dir > 0) {\r\n                this.spos.y = this.ceilSubOffset;\r\n                this.animatGroupCurr.forEach(a => {\r\n                    a.zModifierPub = 0;\r\n                    a.spos.y = this.ceilSubOffset;\r\n                });\r\n            }\r\n            //If going downwards, reset to walking\r\n            else {\r\n                this.endAirMovement();\r\n            }\r\n        }\r\n    }\r\n\r\n    //Quickly shift fight to \r\n    private startVertMovement() {\r\n        this.airState = AirState.UPWARD;\r\n        this.spos.x = 0;\r\n    }\r\n\r\n    //End vertical or jump movement\r\n    private endAirMovement() {\r\n\r\n        this.airState = AirState.NONE;\r\n        this.spos.setToZero();\r\n        this.handleBricks();\r\n\r\n        //Go from air state to walking state.\r\n        if (this.animatGroupsIndex == 3) {\r\n            this.setCurrentGroup(0);\r\n        }\r\n    }\r\n\r\n    //Return true if the given vertical direction is free of bricks\r\n    private getCollisionVertical(dir : number) : boolean {\r\n\r\n        //If moving upward and hit the ceiling, return false\r\n        if(dir > 0 && this.gpos.y <= this.height + 1) {\r\n            return false;\r\n        }\r\n\r\n        //Check for bricks in travelling direction\r\n        return !this.brickHandler.checkCollisionRange(\r\n            this.gpos.getSub({\r\n                x : 1,\r\n                y : dir > 0 ? 1 + this.height : 0\r\n            }), //Position\r\n            1,  //Direction\r\n            0,  //START\r\n            2,  //FINAL\r\n            1); //HEIGHT\r\n            \r\n    }\r\n\r\n    //Check and resolve brick collisions\r\n    protected handleCollision() {\r\n        \r\n        //WALL BOUNDARY\r\n        if (this.gpos.x - 1 < BOUNDARY.minx || \r\n            this.gpos.x + 1 > BOUNDARY.maxx) {\r\n\r\n            this.reverse();\r\n        }\r\n        //Brick collisions\r\n        else {\r\n\r\n            //Collision bitmask\r\n            const cbm = this.brickHandler.checkCollisionRange(\r\n                this.gpos.getSub({\r\n                    x : this.move.x > 0 ? 1 : 0, \r\n                    y : 1 + this.height\r\n                }),             //Position\r\n                this.move.x,    //Direction\r\n                5,              //START :  n + 1\r\n                15,             //FINAL : (n + 3) * 2 + 1\r\n                7);             //HEIGHT:  n + 3\r\n\r\n            //WALL - REVERSE\r\n            if(cbm & gcb.wall) {\r\n                this.reverse();\r\n            }\r\n            //HEAD-WALL - REVERSE\r\n            else if(cbm & gcb.head && cbm & gcb.flor) {\r\n                this.reverse();\r\n            }\r\n            //UP-STEP - GO UP\r\n            else if(cbm & gcb.step) {\r\n\r\n                //BLOCKED BY CEILING\r\n                if(cbm & gcb.ceil || this.gpos.y <= BOUNDARY.miny + 3) {\r\n                    this.reverse();\r\n                }\r\n                else {\r\n                    this.gpos.y -= 1;\r\n                }\r\n            }\r\n            //FLOOR - DO NOTHING\r\n            else if(cbm & gcb.flor) {\r\n\r\n            }\r\n            //DOWN-STEP - GO DOWN\r\n            else if(cbm & gcb.down) {\r\n                this.gpos.y += 1;\r\n            }\r\n            //VOID - REVERSE\r\n            else {\r\n                this.reverse();\r\n            }\r\n        }\r\n    }\r\n\r\n    //Set bot to a flight state\r\n    private setFlightState(state : AirState) {\r\n\r\n        this.airState = state;\r\n        this.jumpOrigin = this.gpos.get();\r\n        this.spos.x = 0;                //Force grid alignment\r\n\r\n        if(this.animatGroupsIndex != 3) {\r\n            this.handleBricks(true);    //Bricks should not be pressured by a floating character\r\n            this.setCurrentGroup(3);    //Play floating animation\r\n        }\r\n    }\r\n\r\n    //Colliders for non-brick collisions\r\n    public getColliders() : Collider[] {\r\n        \r\n        return [{ \r\n            mask : MASKS.scrap | MASKS.death | MASKS.float,\r\n            min : this.gpos.getAdd({ x : -1, y : 1 - this.height}),\r\n            max : this.gpos.getAdd({ x :  1, y : 1}) \r\n        },{ \r\n            mask : 0,       //Passive\r\n            min : this.gpos.getAdd({ x : -1, y : 1 - this.height}),\r\n            max : this.gpos.getAdd({ x :  1, y : 1}) \r\n        },{ \r\n            mask : MASKS.super | MASKS.jumps | MASKS.press,\r\n            min : this.gpos.getAdd({ x : -1 - Math.min(this.move.x, 0), y : 0}),\r\n            max : this.gpos.getAdd({ x :    - Math.min(this.move.x, 0), y : 1}) \r\n        }];\r\n    }\r\n\r\n    //Also reset timer when setting the current group\r\n    public setCurrentGroup(index? : number) {\r\n        this.timerSpc = 0;  //Timer reset incase we cancelled a previous animation\r\n        super.setCurrentGroup(index);\r\n    }\r\n\r\n    //Explode\r\n    public resolveCollision(mask : number) {\r\n\r\n        //Eat\r\n        if (mask & MASKS.scrap) {\r\n            this.setCurrentGroup(1);\r\n        }\r\n        //Hazard\r\n        else if (mask & MASKS.death && this.isNormalMovment) {\r\n\r\n            //Start flashing animation after taking damage\r\n            if(this.armorState == ArmorState.ACTIVE) {\r\n                this.armorState = ArmorState.FLASH\r\n            }\r\n            //If unarmored, die.\r\n            else if(this.armorState == ArmorState.NONE) {\r\n                this.setCurrentGroup(2);\r\n            }\r\n        }\r\n        //Up\r\n        else if (mask & MASKS.float) {\r\n            this.setFlightState(AirState.UPWARD)\r\n        }\r\n        //Armor\r\n        else if (mask & MASKS.super) {\r\n            this.armorState = ArmorState.ACTIVE;\r\n            this.setCurrentGroup(4);\r\n        }\r\n        //Jump\r\n        else if (mask & MASKS.jumps) {\r\n            this.setFlightState(AirState.JUMP)\r\n        }\r\n    }\r\n}"],
  "mappings": "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",
  "names": []
}
