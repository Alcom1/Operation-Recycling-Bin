{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\characterbot.ts"],
  "sourcesContent": ["import Character, { CharacterParams } from \"./character\";\r\nimport { BOUNDARY, bitStack, GMULTY, GMULTX, MASKS, Faction} from \"engine/utilities/math\";\r\nimport { Collider } from \"engine/modules/collision\";\r\nimport { Point } from \"engine/utilities/vect\";\r\nimport { Collision } from \"engine/gameobjects/gameobject\";\r\n\r\n/** Armor states of a bot character */\r\nenum ArmorState {\r\n    NONE,\r\n    ACTIVE,\r\n    FLASH\r\n}\r\n\r\n/** States of a bot character */\r\nenum BotState {\r\n    NORMAL,\r\n    HALTED,\r\n    EATING,\r\n    HAZARD,\r\n    FLYING,\r\n    BOUNCE,\r\n    SHIELD\r\n}\r\n\r\n/** Specifications of THE bot character */\r\nconst characterBotOverride = Object.freeze({\r\n    // Main parameters\r\n    faction: Faction.FRIENDLY,\r\n    height: 4,      // Bot is this tall\r\n    speed : 3,      // Bot moves fast\r\n    stateAnimations : [1, 2, 3, 4, 4, 5],\r\n    animMain : {\r\n        images : [      // Bot has left & right animations\r\n            { name : \"char_bot_left\" },\r\n            { name : \"char_bot_right\" },\r\n            { name : \"char_bot_left_armor\" },\r\n            { name : \"char_bot_right_armor\" }],\r\n        frameCount : 10,\r\n        animsCount : 2\r\n    },\r\n\r\n    // Misc animation parameters\r\n    animsMisc : [{\r\n        images : [      // Bot has left & right animations\r\n            { name : \"char_bot_left\" },\r\n            { name : \"char_bot_right\" },\r\n            { name : \"char_bot_left_armor\" },\r\n            { name : \"char_bot_right_armor\" }],\r\n        speed : 0,\r\n        gposOffset : { x : -3, y : 0},\r\n        frameCount : 10,\r\n        animsCount : 2\r\n    },{ // Bot-bin interaction animation\r\n        images : [{ name : \"char_bot_bin\" }],\r\n        gposOffset : { x : -1, y : 0},\r\n        frameCount : 12\r\n    },{             // Bot explosion animation\r\n        images : [{ name : \"char_bot_explosion\" }],\r\n        gposOffset : { x : -3, y : 0},\r\n        frameCount : 16,\r\n        isLoop : false\r\n    },{             // Bot up animation\r\n        images : [  // Flying has left & right animations\r\n            { name : \"char_bot_fly_left\" },\r\n            { name : \"char_bot_fly_right\" },\r\n            { name : \"char_bot_fly_left_armor\" },\r\n            { name : \"char_bot_fly_right_armor\" }],\r\n        speed : 3,  // Bot moves fast\r\n        gposOffset : { x : -3, y : 0},\r\n        frameCount : 10,\r\n        animsCount : 2\r\n    },{             // Bot armor animation\r\n        images : [\r\n            { name : \"char_bot_armor_left\", offsetX : 36 },\r\n            { name : \"char_bot_armor_right\", offsetX : 14 }],\r\n        gposOffset : { x : -1, y : 0},\r\n        frameCount : 12\r\n    }]\r\n});\r\n\r\n// Collision bitmasks for bot-brick collisions\r\nconst gcb = Object.freeze({\r\n    flor : bitStack(0, 7),\r\n    down : bitStack(1, 8),\r\n    ceil : bitStack(2, 9),\r\n    head : bitStack(3),\r\n    wall : bitStack(4, 5),\r\n    step : bitStack(6)\r\n});\r\n\r\n// Collision bitmasks for bot-brick collisions in air\r\nconst acb = Object.freeze({\r\n    flor : bitStack(0, 6),\r\n    head : bitStack(1, 7),\r\n    face : bitStack(8, 9, 10),\r\n    shin : bitStack(11),\r\n    foot : bitStack(12)\r\n});\r\n\r\n/** The one and only. */\r\nexport default class CharacterBot extends Character {\r\n\r\n    private timerSpc : number = 0;                          // Timer to track duration of special movements\r\n    private timerArm : number = 0;                          // Timer to track armor flash\r\n    private timerStp : number = 0;                          // Timer to track time since previous step\r\n    private ceilSubOffset : number = -6;                    // Offset for up/down movement\r\n    private vertSpeed : number = 360;                       // Speed of air movement\r\n    private vertMult : -1|1 = 1;                            // Up/Down multiplier for air movement\r\n    private vertBlock : boolean = false;                    // If vertically blocked\r\n    private horzSpeed : number = 300;                       // Horizontal air speed\r\n    private jumpHeights : number[] = [0, 2, 3, 3, 2, 0];    // Individual heights throughout a jump\r\n    private jumpOrigin : Point = { x : 0, y : 0 }           // Origin of the previous jump\r\n    private armorDelay : number = 2;                        // Delay where armor remains after taking damage\r\n    private armorFlashRate : number = 8;                    // Rate of the armor flashing effect\r\n    private armorState : ArmorState = ArmorState.NONE;      // Current state of the armor\r\n    \r\n    protected get animationSubindex() : number {               // Adjust animation index for armor flash effect\r\n        return this.move.x * (\r\n            this.armorState == ArmorState.ACTIVE ? 2 :\r\n            this.armorState == ArmorState.FLASH  ? (1 + Math.floor(this.timerArm * this.armorFlashRate) % 2) : \r\n            1)\r\n    }\r\n\r\n    /** Constructor */\r\n    constructor(params: CharacterParams) {\r\n        super(Object.assign(params, characterBotOverride));\r\n    }\r\n\r\n    /** Unique bot update to update armor flash */\r\n    public update(dt : number) {\r\n        super.update(dt);\r\n\r\n        this.timerStp += dt;    //Update step timer\r\n\r\n        // Update armor flash\r\n        if (this.armorState == ArmorState.FLASH) {\r\n            this.timerArm += dt;\r\n            this.animationsCurr.setImageIndex(this.animationSubindex);\r\n\r\n            // Remove armor after a duration and reset timer\r\n            if (this.timerArm > this.armorDelay) {\r\n                this.armorState = ArmorState.NONE;\r\n                this.timerArm = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Special movement */\r\n    protected handleSpecialMovement(dt : number) {\r\n\r\n        this.timerSpc += dt;   // Update special timer\r\n\r\n        // Perform special movement\r\n        switch(this.stateIndex) {\r\n\r\n            // Vertical\r\n            case BotState.EATING :\r\n            case BotState.FLYING : \r\n                this.moveVertical(dt, this.vertMult);\r\n                break;\r\n\r\n            // Bounce\r\n            case BotState.BOUNCE :\r\n                this.moveBounce(dt);\r\n                break;\r\n\r\n            // Default - Do nothing\r\n            default :\r\n                break;\r\n        }\r\n\r\n        // If the current animation has ended\r\n        if (this.timerSpc > this.animationsCurr.duration) {\r\n\r\n            // Reset timer\r\n            this.timerSpc = 0;\r\n\r\n            // Perform ending actions for different states\r\n            switch(this.stateIndex) {\r\n\r\n                // Dead - Deactivate this character\r\n                case BotState.HAZARD :\r\n                    this.deactivate();\r\n                    break;\r\n\r\n                // Vertical - Reset up/down animation\r\n                case BotState.FLYING :\r\n                    this.animationsCurr.reset();\r\n                    break;\r\n\r\n                // Bounce - Do nothing\r\n                case BotState.BOUNCE :\r\n                    break;\r\n                \r\n                // Default - End animation, return to ground movement\r\n                default :\r\n                    this.setStateIndex(BotState.NORMAL);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Vertical motion */\r\n    private moveVertical(dt: number, dir: number) {\r\n\r\n        //Don't update if vertically blocked and moving upward\r\n        if(!this.vertBlock) {\r\n\r\n            this.spos.y -= dt * this.vertSpeed * dir;   // Move subposition vertically based on speed\r\n            this.animationsCurr.spos = this.spos;       // Move animation to match\r\n        }\r\n\r\n        //Update grid position\r\n        if (Math.abs(this.spos.y) > GMULTY) {\r\n            this.moveAll({x : 0, y : Math.sign(this.spos.y)}, false)\r\n            this.spos.y -= Math.sign(this.spos.y) * GMULTY;\r\n        }\r\n        this.handleBrickCollisionVertical();\r\n        this.animationsCurr.reset(this.gpos, false);\r\n        this.animationsCurr.spos = this.spos;\r\n    }\r\n\r\n    /** Move in a jumping arc */\r\n    private moveBounce(dt: number) {\r\n\r\n        var index = Math.abs(this.gpos.x - this.jumpOrigin.x);  //Index of current jump height\r\n\r\n        //Don't jump past the level boundary\r\n        if ((index > 0 || Math.abs(this.spos.x) > GMULTX / 2) && (\r\n            this.gpos.x - 2 < BOUNDARY.minx || \r\n            this.gpos.x + 2 > BOUNDARY.maxx)) {\r\n\r\n            this.startVertMovement();\r\n            return;\r\n        }\r\n\r\n        //Collision bitmask\r\n        const cbm = this.brickHandler.checkCollisionRange(\r\n            this.gpos.getSub({\r\n                x : this.move.x > 0 ? 1 : 0, \r\n                y : this.height + 1\r\n            }),             //Position\r\n            this.move.x,    //Direction\r\n            5,              //START  n + 1\r\n            18,             //FINAL\r\n            6,              //HEIGHT n + 2\r\n            3);             //Width\r\n        \r\n        //Collide face if we're over half-way past the first step\r\n        if(cbm & acb.face && (index > 0 || Math.abs(this.spos.x) > GMULTX / 2)) {\r\n            this.startVertMovement();\r\n            return;\r\n        }\r\n        //Collide head if not at the peak of the jump\r\n        else if((cbm & acb.head || this.gpos.y <= BOUNDARY.miny + 3) && index < 2) {\r\n            this.startVertMovement();\r\n            return;\r\n        }\r\n        //collide shin after the first step\r\n        else if (cbm & acb.shin && index > 0) {\r\n            this.startVertMovement();\r\n            return;\r\n        }\r\n        //Collide with foot after the arc starts travelling downwards\r\n        else if (cbm & acb.foot && index > 2) {\r\n            this.startVertMovement();\r\n            return;\r\n        }\r\n        //Collide with floor after the first step\r\n        else if (cbm & acb.flor && index > 0) {\r\n            this.endVertMovement();\r\n            return;\r\n        }\r\n\r\n        //End of jump\r\n        if(index > this.jumpHeights.length - 2) {\r\n            this.startVertMovement();\r\n            return;\r\n        }\r\n\r\n        //Update position, travel in an arc based on the jump heights.\r\n        this.spos.x += this.move.x * this.horzSpeed * dt;   //Update horizontal position\r\n        this.spos.y = - GMULTY * (                          //Update vertical position\r\n            this.jumpHeights[index] + \r\n            this.gpos.y - \r\n            this.jumpOrigin.y +\r\n            Math.abs(this.spos.x / GMULTX) * (this.jumpHeights[index + 1] - this.jumpHeights[index]));\r\n\r\n        this.animationsCurr.spos = this.spos;               //Update animations to match current position\r\n\r\n        //store sub-position converted to a grid position\r\n        var move = {\r\n            x : Math.abs(this.spos.x) > GMULTX ? Math.sign(this.spos.x) : 0,\r\n            y : Math.abs(this.spos.y) > GMULTY ? Math.sign(this.spos.y) : 0\r\n        };\r\n\r\n        //if sub-position is large enough to move, update position\r\n        if(move.x || move.y) {\r\n    \r\n            this.moveAll(move, false);  //Go up or down to new grid position\r\n            this.spos.sub({             //Reset subposition to match new grid position\r\n                x : move.x * GMULTX,\r\n                y : move.y * GMULTY\r\n            });            \r\n    \r\n            //Update animation to match\r\n            this.animationsCurr.gpos.add(move);\r\n        }\r\n    }\r\n\r\n    /** Quick shift to downward vertical movement */\r\n    private startVertMovement() {\r\n\r\n        // If bot is between studs, move forward instead of backward\r\n        if (Math.abs(this.spos.x) > GMULTX / 2) {\r\n            this.gpos.x += Math.sign(this.spos.x);  // Move forward by one.\r\n        }\r\n\r\n        this.vertMult = -1;                         // Default to downward movement to remove 1-frame hitch.\r\n        this.setStateIndex(BotState.FLYING);        // Vertical movement\r\n    }\r\n\r\n    /** End vertical or jump movement */\r\n    private endVertMovement() {\r\n\r\n        this.spos.setToZero();  // Snap to grid\r\n\r\n        // Go from air state to walking state for flying & bounce states\r\n        if (this.stateIndex == BotState.FLYING ||\r\n            this.stateIndex == BotState.BOUNCE) {\r\n\r\n            this.setStateIndex(BotState.HALTED);\r\n        }\r\n    }\r\n\r\n    /** Return true if the given vertical direction has an obstacle */\r\n    private getCollisionVertical(dir : number) : boolean {\r\n\r\n        // If moving upward and hit the ceiling, return true\r\n        if (dir > 0 && this.gpos.y <= this.height + 1) {\r\n            return true;\r\n        }\r\n\r\n        // Check for bricks in travelling direction\r\n        return !!this.brickHandler.checkCollisionRange(\r\n            this.gpos.getSub({\r\n                x : 1,\r\n                y : dir > 0 ? 1 + this.height : 0\r\n            }), // Position\r\n            1,  // Direction\r\n            0,  // START\r\n            2,  // FINAL\r\n            1); // HEIGHT\r\n    }\r\n\r\n    /** Check and resolve brick collisions - Normal movement */\r\n    public handleBrickCollisionNormal() {\r\n\r\n        // WALL BOUNDARY\r\n        if (this.gpos.x - 2 < BOUNDARY.minx && this.move.x < 0 || \r\n            this.gpos.x + 2 > BOUNDARY.maxx && this.move.x > 0) {\r\n\r\n            this.reverse();\r\n        }\r\n        // Brick collisions\r\n        else {\r\n\r\n            // Collision bitmask\r\n            const cbm = this.brickHandler.checkCollisionRange(\r\n                this.gpos.getSub({\r\n                    x : this.move.x > 0 ? 0 : 1, \r\n                    y : 1 + this.height\r\n                }),             // Position\r\n                this.move.x,    // Direction\r\n                5,              // START :  n + 1\r\n                15,             // FINAL : (n + 3) * 2 + 1\r\n                7,              // HEIGHT:  n + 3\r\n                undefined,\r\n                this.faction);\r\n\r\n            // WALL - REVERSE\r\n            if (cbm & gcb.wall) {\r\n                this.reverse();\r\n            }\r\n            // HEAD-WALL - REVERSE\r\n            else if (cbm & gcb.head && cbm & gcb.flor) {\r\n                this.reverse();\r\n            }\r\n            // UP-STEP - GO UP\r\n            else if (cbm & gcb.step) {\r\n\r\n                // BLOCKED BY CEILING\r\n                if (cbm & gcb.ceil || this.gpos.y <= BOUNDARY.miny + 3) {\r\n                    this.reverse();\r\n                }\r\n                else {\r\n                    this.walkstep(-1);\r\n                }\r\n            }\r\n            // FLOOR - DO NOTHING\r\n            else if (cbm & gcb.flor) {\r\n                this.walkstep(0);\r\n            }\r\n            // DOWN-STEP - GO DOWN\r\n            else if (cbm & gcb.down) {\r\n                this.walkstep(1);\r\n            }\r\n            // VOID - REVERSE\r\n            else {\r\n                this.reverse();\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Shift forward, with a vertical offset to handle steps */\r\n    private walkstep(vOffset : number) {\r\n\r\n        this.moveAll({\r\n            x : this.move.x,\r\n            y : vOffset\r\n        })\r\n    }\r\n\r\n    /** Check and resolve brick collisions - Vertical movement */\r\n    protected handleBrickCollisionVertical() {\r\n\r\n        //Reset vertical block for check\r\n        this.vertBlock = false;\r\n        \r\n        // There is an obstacle, stop based on its direction\r\n        if (this.getCollisionVertical(this.vertMult)) {\r\n\r\n            this.vertBlock = true;                  // Block vertical movement\r\n\r\n            // If going upwards, collide with ceiling\r\n            if (this.vertMult > 0) {\r\n\r\n                this.spos.y = this.ceilSubOffset;   // Set sub-position for block\r\n                this.animationsCurr.spos.y = this.ceilSubOffset;\r\n            }\r\n            // If going downwards, reset to walking\r\n            else {\r\n                this.endVertMovement();\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Colliders for non-brick collisions */\r\n    public getColliders() : Collider[] {\r\n        \r\n        return [{ \r\n            mask : MASKS.death,\r\n            min : this.gpos.getAdd({ x : -1, y : 1 - this.height}),\r\n            max : this.gpos.getAdd({ x :  1, y : 1}) \r\n        },{ \r\n            mask : MASKS.scrap | MASKS.float,\r\n            min : this.gpos.getAdd({ x : -1, y : 1 - this.height}),\r\n            max : this.gpos.getAdd({ x :  1, y : 2}) \r\n        },{ \r\n            mask : MASKS.super | MASKS.jumps | MASKS.press,\r\n            min : this.gpos.getAdd({ x : -1 - Math.min(this.move.x, 0), y : 0}),\r\n            max : this.gpos.getAdd({ x :    - Math.min(this.move.x, 0), y : 1}) \r\n        }];\r\n    }\r\n\r\n    /** Also reset timer when setting the current group */\r\n    public setStateIndex(index? : number) {\r\n\r\n        //Deactivate bricks for bounce and flying states\r\n        let isBricksActive = [BotState.BOUNCE, BotState.FLYING].every(x => x != index);\r\n        this.bricks.forEach(x => x.isActive = isBricksActive);\r\n\r\n        // Only set state if it's different from the current\r\n        if (this.stateIndex != index) {\r\n\r\n            this.timerSpc = 0;          // Timer reset incase we cancelled a previous animation\r\n            super.setStateIndex(index); // Set index\r\n\r\n            //Force walk animation to sync with steps\r\n            if(this.stateIndex == BotState.NORMAL) {\r\n                this.animationsCurr.timer = this.timerStp;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Check and resolve brick collisions */\r\n    public handleStep() {\r\n\r\n        this.timerStp = 0;  //Reset step timer\r\n\r\n        switch(this.stateIndex) {\r\n\r\n            case BotState.HALTED :\r\n                this.setStateIndex(BotState.NORMAL);\r\n                break;\r\n\r\n            case BotState.NORMAL :\r\n                this.handleBrickCollisionNormal();\r\n                break;\r\n\r\n            default :\r\n                break;\r\n        }\r\n    }\r\n\r\n    /** Override collision check  */\r\n    protected resolveCollisions(collisions : Collision[]) {\r\n        super.resolveCollisions(collisions);\r\n        \r\n        //Start going down if flying but there's no float collisions\r\n        if (!collisions.find(c => c.mask & MASKS.float) && this.stateIndex == BotState.FLYING) {\r\n            this.vertMult = -1;         // Go down please\r\n        }\r\n    }\r\n\r\n    /** Collisions */\r\n    public resolveCollision(mask : number) {\r\n        \r\n        // Eat\r\n        if (mask & MASKS.scrap) {\r\n            this.vertMult = -1;         // Default to downward movement\r\n            this.setStateIndex(BotState.EATING);\r\n        }\r\n        // Hazard\r\n        else if (mask & MASKS.death && this.stateIndex != 2) {\r\n\r\n            // Start or continue flash after taking armor damage\r\n            if (this.armorState == ArmorState.ACTIVE) {\r\n                this.armorState = ArmorState.FLASH\r\n            }\r\n            // If unarmored, die.\r\n            else if (this.armorState == ArmorState.NONE) {\r\n                this.setStateIndex(BotState.HAZARD);\r\n            }\r\n        }\r\n        // Vertical\r\n        else if (mask & MASKS.float) {\r\n            this.vertMult = 1;          // Default to upward movement\r\n            this.setStateIndex(BotState.FLYING);\r\n        }\r\n        // Bounce\r\n        else if (mask & MASKS.jumps) {\r\n            this.jumpOrigin = this.gpos.get();\r\n            this.setStateIndex(BotState.BOUNCE);\r\n        }\r\n        // Armor\r\n        else if (mask & MASKS.super) {\r\n            this.armorState = ArmorState.ACTIVE;\r\n            this.setStateIndex(BotState.SHIELD);\r\n        }\r\n    }\r\n}"],
  "mappings": "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",
  "names": []
}
