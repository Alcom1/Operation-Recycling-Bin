{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\characterbot.ts"],
  "sourcesContent": ["import Engine from \"engine/engine\";\r\nimport Character, { CharacterParams } from \"./character\";\r\nimport { BOUNDARY, bitStack, colRectRectSizes, GMULTY, GMULTX} from \"engine/utilities/math\";\r\nimport Scene from \"engine/scene/scene\";\r\nimport Animat, { AnimationParams } from \"./animation\";\r\nimport CharacterBin from \"./characterbin\";\r\nimport { Collider } from \"engine/modules/collision\";\r\n\r\nexport interface CharacterBotParams extends CharacterParams {\r\n    animsMisc : AnimationInputParams[];\r\n}\r\n\r\nexport interface AnimationInputParams extends AnimationParams {\r\n    isSliced? : boolean;\r\n}\r\n\r\n//Bot parameters\r\nconst characterBotOverride = Object.freeze({\r\n    //Main parameters\r\n    height: 4,      //Bot is this tall\r\n    speed : 2.5,    //Bot moves fast\r\n    images : [      //Bot has left & right animations\r\n        { name : \"char_bot_left\", offsetX : 36 },\r\n        { name : \"char_bot_right\", offsetX : 14},\r\n        { name : \"char_bot_left_armor\", offsetX : 36 },\r\n        { name : \"char_bot_right_armor\", offsetX : 14}],\r\n    frameCount : 10,\r\n    animsCount : 2,\r\n\r\n    //Misc animation parameters\r\n    animsMisc : [{ //Bot-bin interaction animation\r\n        images : [{ name : \"char_bot_bin\", offsetX : 0 }],\r\n        framesSize : 126,\r\n        gposOffset : { x : -1, y : 0},\r\n        zModifier : 150,\r\n        frameCount : 12\r\n    },{             //Bot explosion animation\r\n        images : [{ name : \"char_bot_explosion\", offsetX : 0 }],\r\n        framesSize : 200,\r\n        gposOffset : { x : -3, y : 0},\r\n        zModifier : 600,\r\n        frameCount : 16,\r\n        isLoop : false\r\n    },{             //Bot up animation\r\n        images : [  //Flying has left & right animations\r\n            { name : \"char_bot_fly_left\", offsetX : 36 },\r\n            { name : \"char_bot_fly_right\", offsetX : 14 }],\r\n        speed : 2.5,    //Bot moves fast\r\n        gposOffset : { x : -1, y : 0},\r\n        frameCount : 10,\r\n        animsCount : 2,\r\n        isLoop : true,\r\n        isSliced : true\r\n    }]\r\n});\r\n\r\n//Collision bitmasks for bot-brick collisions\r\nconst cbc = Object.freeze({\r\n    flor : bitStack([0, 7]),\r\n    down : bitStack([1, 8]),\r\n    ceil : bitStack([2, 9]),\r\n    head : bitStack([3]),\r\n    wall : bitStack([4, 5]),\r\n    step : bitStack([6])\r\n});\r\n\r\nexport default class CharacterBot extends Character {\r\n\r\n    private timer : number = 0;         //Timer to track duration of special movements\r\n    private ceilSubOffset = -6;         //Offset for up/down movement\r\n    private verticalSpeed = 500;\r\n    private isFlight : boolean = false;\r\n    private isArmor : boolean = false;\r\n\r\n    protected get normalMoveIndex() : number { \r\n        return this.move.x * (this.isArmor ? 2 : 1)\r\n    }\r\n\r\n    constructor(engine: Engine, params: CharacterBotParams) {\r\n        super(engine, Object.assign(params, characterBotOverride));\r\n\r\n        //Setup miscellaneous animations.\r\n        params.animsMisc.forEach(m => {\r\n\r\n            //Build a new animation, store it here and in the scene\r\n            var newIndex = this.animatGroups.push([]) - 1;\r\n\r\n            //3 slices if sliced, 1 otherwise\r\n            for(let i = -1; i <= (m.isSliced ? 1 : -1); i ++) {\r\n\r\n                this.animatGroups[newIndex].push(new Animat(this.engine, {\r\n                    ...params,\r\n                    speed :      m.speed,\r\n                    images :     m.images,\r\n                    sliceIndex : m.isSliced ? i : null,\r\n                    framesSize : m.isSliced ? GMULTX * 2 : m.framesSize,\r\n                    gposOffset : m.gposOffset,\r\n                    zModifier :  m.isSliced ? (i < 1 ? 300 : 29) : m.zModifier,\r\n                    frameCount : m.frameCount,\r\n                    animsCount : m.animsCount,\r\n                    isLoop :     m.isLoop\r\n                } as AnimationParams));\r\n            }\r\n            this.animatGroups[newIndex].forEach(a => this.parent.pushGO(a));\r\n        });\r\n    }\r\n\r\n    //Special movement\r\n    protected handleSpecialMovement(dt : number) {\r\n\r\n        this.timer += dt;   //Update timer\r\n\r\n        //Perform special movement\r\n        switch(this.animatGroupsIndex) {\r\n\r\n            //Vertical movement. flight state will have been set to true by collision\r\n            case 3 : \r\n                this.moveVertical(dt, this.isFlight ? 1 : -1);\r\n                this.isFlight = false;  //Unset for next collision check\r\n                break;\r\n            \r\n            //Default is do nothing\r\n            default :\r\n                break;\r\n        }\r\n\r\n        //If the current animation has ended\r\n        if(this.timer > this.animatGroupCurr[0].length) {\r\n\r\n            switch(this.animatGroupsIndex) {\r\n                \r\n                //End bot-bin animation\r\n                case 1 :\r\n                    this.timer = 0;\r\n                    this.setCurrentGroup(0);\r\n                    break;\r\n\r\n                //Reset up/down animation\r\n                case 3 :\r\n                    this.timer = 0;\r\n                    this.animatGroupCurr.forEach(a => a.reset());\r\n                    break;\r\n\r\n                //Default to deactivating this character\r\n                default :\r\n                    this.isActive = false;\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    //Vertical motion\r\n    private moveVertical(dt: number, dir: number = 1) {\r\n\r\n        //Set subposition to move vertically\r\n        this.spos.y -= dir * dt * this.verticalSpeed;\r\n        \r\n        //If the direction has no obstacles\r\n        if(this.getCollisionVetical(dir)) {\r\n\r\n            //If travelled to a new grid position, reset to it.\r\n            if(dir * this.spos.y < -GMULTY + this.ceilSubOffset) {\r\n\r\n                this.gpos.y -= dir;             //Go up or down to new grid position\r\n                this.spos.y += dir * GMULTY;    //Reset subposition to match new grid position\r\n\r\n                //Update animations to match\r\n                this.animatGroupCurr.forEach(a => {\r\n                    a.gpos.y -= dir;\r\n                    a.zModifierPub = dir > 0 && this.getCollisionVetical(dir) ? 200 : 0; //Z-index fix\r\n                });\r\n            }\r\n\r\n            //Update animations to match\r\n            this.animatGroupCurr.forEach(a => a.spos = this.spos);\r\n        }\r\n        //If there is an obstacle\r\n        else {\r\n\r\n            //If going upwards, continue to collide with ceiling\r\n            if(dir > 0) {\r\n                this.spos.y = this.ceilSubOffset;\r\n                this.animatGroupCurr.forEach(a => {\r\n                    a.zModifierPub = 0;\r\n                    a.spos.y = this.ceilSubOffset;\r\n                });\r\n            }\r\n            //If going downwards, reset to walking\r\n            else {\r\n                this.timer = 0;\r\n                this.handleBricks(); \r\n                this.setCurrentGroup(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    //Return true if the given vertical direction is free of bricks\r\n    private getCollisionVetical(dir : number) : boolean {\r\n\r\n        //If moving upward and hit the ceiling, return false\r\n        if(dir > 0 && this.gpos.y <= this.height + 1) {\r\n            return false;\r\n        }\r\n\r\n        //Check for bricks in travelling direction\r\n        return !this.brickHandler.checkCollisionRange(\r\n            this.gpos.getSub({\r\n                x : 1,\r\n                y : dir > 0 ? 1 + this.height : 0\r\n            }), //Position\r\n            0,  //START\r\n            2,  //FINAL\r\n            1,  //HEIGHT\r\n            1); //Direction\r\n    }\r\n\r\n    //Check and resolve brick collisions\r\n    protected handleCollision() {\r\n\r\n        //Collision bitmask\r\n        const cbm = this.brickHandler.checkCollisionRange(\r\n            this.gpos.getSub({\r\n                x : this.move.x > 0 ? 1 : 0, \r\n                y : 1 + this.height\r\n            }),             //Position\r\n            5,              //START : n + 1\r\n            15,             //FINAL : (n + 3) * 2 + 1\r\n            7,              //HEIGHT: n + 3\r\n            this.move.x);   //Direction\r\n        \r\n        //WALL BOUNDARY\r\n        if(\r\n            this.gpos.x - 1 < BOUNDARY.minx || \r\n            this.gpos.x + 1 > BOUNDARY.maxx) {\r\n\r\n            this.reverse();\r\n        }\r\n        else {\r\n\r\n            //WALL - REVERSE\r\n            if(cbm & cbc.wall) {\r\n                this.reverse();\r\n            }\r\n            //HEAD-WALL - REVERSE\r\n            else if(cbm & cbc.head && cbm & cbc.flor) {\r\n                this.reverse();\r\n            }\r\n            //UP-STEP - GO UP\r\n            else if(cbm & cbc.step) {\r\n\r\n                //BLOCKED BY CEILING\r\n                if(cbm & cbc.ceil || this.gpos.y <= BOUNDARY.miny + 3) {\r\n                    this.reverse();\r\n                }\r\n                else {\r\n                    this.gpos.y -= 1;\r\n                }\r\n            }\r\n            //FLOOR - DO NOTHING\r\n            else if(cbm & cbc.flor) {\r\n\r\n            }\r\n            //DOWN-STEP - GO DOWN\r\n            else if(cbm & cbc.down) {\r\n                this.gpos.y += 1;\r\n            }\r\n            //VOID - REVERSE\r\n            else {\r\n                this.reverse();\r\n            }\r\n        }\r\n    }\r\n\r\n    //Colliders for non-brick collisions\r\n    public getColliders() : Collider[] {\r\n        \r\n        return [{ \r\n            mask : 0b11111, //All collisions\r\n            min : this.gpos.getAdd({ x : -1, y : 1 - this.height}),\r\n            max : this.gpos.getAdd({ x :  1, y : 1}) \r\n        },{ \r\n            mask : 0,       //Passive\r\n            min : this.gpos.getAdd({ x : -1, y : 1 - this.height}),\r\n            max : this.gpos.getAdd({ x :  1, y : 1}) \r\n        }];\r\n    }\r\n\r\n    //Explode\r\n    public resolveCollision(mask : number) {\r\n\r\n        //Eat\r\n        if (mask & 0b010) {\r\n            this.setCurrentGroup(1);\r\n        }\r\n        //Hazard\r\n        else if (mask & 0b100 && this.isNormalMovment && !this.isArmor) {\r\n            this.setCurrentGroup(2);\r\n        }\r\n        //Up\r\n        else if (mask & 0b1000) {\r\n            if(this.animatGroupsIndex != 3) {\r\n                this.handleBricks(true);            //Bricks should not be pressured by a floating character\r\n                this.setCurrentGroup(3);            //Play floating animation\r\n                this.animatGroupCurr.forEach(x =>   //Match facing direction\r\n                    x.setImageIndex(this.move.x));\r\n                this.spos.x = 0;                    //Force grid alignment\r\n            }\r\n            this.isFlight = true;\r\n        }\r\n        //Armor\r\n        else if (mask & 0b10000) {\r\n            this.isArmor = true;\r\n            this.resetImageIndex();\r\n        }\r\n    }\r\n}"],
  "mappings": "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",
  "names": []
}
