{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\character.ts"],
  "sourcesContent": ["import GameObject, { GameObjectParams } from \"engine/gameobjects/gameobject\";\r\nimport { GMULTX, GMULTY } from \"engine/utilities/math\";\r\nimport Vect from \"engine/utilities/vect\";\r\nimport BrickHandler from \"./brickhandler\";\r\nimport Brick from \"./bricknormal\";\r\nimport Animat, { OffsetImageParams, AnimationParams } from \"./animation\";\r\n\r\nexport interface CharacterParams extends GameObjectParams {\r\n    height? : number;\r\n    speed? : number;\r\n    images : OffsetImageParams[];\r\n    frameCount : number;\r\n    animsCount : number;\r\n    isForward? : boolean;\r\n    isGlide? : boolean;\r\n}\r\n\r\nexport default class Character extends GameObject {\r\n\r\n    public get height() { return this._height; }    //Collision height of this character\r\n    protected _height: number;\r\n    protected move: Vect;                           //Movement direction of this character\r\n    protected brickHandler!: BrickHandler;          //Brick handler for brick pressure (bricks under this character)\r\n    protected checkCollision: boolean;              //If collision needs to be checked\r\n    private speed: number;                          //Speed of this character\r\n    private isGlide: boolean;                       //If the character sprite matches the character's subposition\r\n    private underBricks: Brick[] = [];              //Bricks under pressure, under this character\r\n\r\n    protected animatGroupsIndex = 0;\r\n    protected animatGroups: Animat[][] = [[]];\r\n    protected get animatGroupCurr() : Animat[] { return this.animatGroups[this.animatGroupsIndex] }\r\n    protected get isNormalMovment() : boolean { return this.animatGroupsIndex == 0 }\r\n    protected get animImageIndex() : number { return this.move.x }\r\n\r\n    constructor(params: CharacterParams) {\r\n        super(params);\r\n\r\n        this.tags.push(\"Character\");                                //All characters need to share a tag\r\n        \r\n        this.speed = params.speed ?? 1;                             //Default speed\r\n        this.move = new Vect(params.isForward ?? true ? 1 : -1, 0); //Default move direction\r\n        this._height = params.height ?? 2;                          //Default height for a character\r\n        this.isGlide = params.isGlide ?? false;                     //Default glide state\r\n        this.checkCollision = true;                                 //Force initial collision check\r\n\r\n        const mainZIndex =                                          //Z-index of main slices in the character sprite\r\n            this.height * 100 - (\r\n            this.isGlide ? 100 : 0);\r\n\r\n        //Spawn 3 animations, the sprite is sliced vertically into 2x wide segments for proper z-indexing\r\n        for(let i = -1; i <= 1; i ++) {\r\n            \r\n            // Add segment to scene and this character\r\n            this.animatGroupCurr.push(this.parent.pushGO(new Animat({\r\n                    ...params, \r\n                    isLoop : false,                                 //Remove looping to prevent stuttering. Loops are handled manually\r\n                    zModifier : i < 1 ? mainZIndex : 29,            //Z-modifier for different slices\r\n                    sliceIndex : i,                                 //This animation is sliced\r\n                    framesSize : GMULTX * 2,                        //2x wide slices\r\n                    gposOffset : { x : -1, y : 0 }                  //Move back by 1. Animations are centered around this character\r\n                } as AnimationParams)) as Animat);\r\n        }\r\n    }\r\n\r\n    public init() {\r\n\r\n        // Get brickhandler for pressure checks\r\n        this.brickHandler = this.engine.tag.get(\"BrickHandler\", \"LevelInterface\")[0] as BrickHandler;\r\n\r\n        // Set active groups\r\n        this.setCurrentGroup();\r\n    }\r\n\r\n    public update(dt: number) {\r\n\r\n        //Normal or unique movement, shift grid/sub position after movement\r\n        if(this.isNormalMovment) {\r\n            this.handleNormalMovement(dt);\r\n            this.shift(true);\r\n        }\r\n        else {\r\n            this.handleSpecialMovement(dt);\r\n            this.shift(false);\r\n        }\r\n\r\n        //Handle collision, set zIndices for new position\r\n        if(this.checkCollision) {\r\n\r\n            this.handleCollision();\r\n            this.handleBricks();\r\n\r\n            this.animatGroupCurr.forEach(s => s.reset(this.gpos));\r\n\r\n            this.checkCollision = false;\r\n        }\r\n    }\r\n\r\n    //Shift to next grid position of the subposition extends too far\r\n    private shift(isCollideAfterShift : boolean) {\r\n\r\n        var move = {\r\n            x : Math.abs(this.spos.x) > GMULTX ? Math.sign(this.spos.x) : 0,\r\n            y : Math.abs(this.spos.y) > GMULTY ? Math.sign(this.spos.y) : 0\r\n        };\r\n\r\n        if(move.x || move.y) {\r\n    \r\n            this.gpos.add(move);    //Go up or down to new grid position\r\n            this.spos.sub({         //Reset subposition to match new grid position\r\n                x : move.x * GMULTX,\r\n                y : move.y * GMULTY\r\n            });            \r\n    \r\n            //Update animations to match\r\n            this.animatGroupCurr.forEach(a => {\r\n                a.gpos.add(move);\r\n            });\r\n\r\n            this.checkCollision = isCollideAfterShift;\r\n            this.brickHandler.isRecheck = true; //Recheck bricks after every shift\r\n        }\r\n\r\n        if(this.isGlide) {\r\n            this.animatGroupCurr.forEach(a => {\r\n                a.spos = this.spos;\r\n            });\r\n        }\r\n    }\r\n\r\n    //Move forward and set collection check at each step.\r\n    private handleNormalMovement(dt: number) {\r\n\r\n        //Increment position by speed\r\n        this.spos.x += this.move.x * this.speed * GMULTX * dt;\r\n    }\r\n\r\n    //Do nothing - override\r\n    protected handleSpecialMovement(dt: number) {\r\n\r\n    }\r\n\r\n    //Manage bricks underneath this character, set pressure\r\n    protected handleBricks(isClear : boolean = false) {\r\n\r\n        //Reset pressures\r\n        this.underBricks.forEach(b => b.pressure -= 1);\r\n\r\n        //Reset underbricks if we are clearing unconditionally.\r\n        if(isClear) {\r\n            this.underBricks = [];\r\n        }\r\n        //Otherwise, get a new set.\r\n        else {\r\n            //Get new set of bricks for pressures\r\n            this.underBricks = this.brickHandler.checkCollisionRow(\r\n                this.gpos.getAdd({x : -1, y : 1}), \r\n                2);\r\n    \r\n            //Set new pressures\r\n            this.underBricks.forEach(b => b.pressure += 1);\r\n        }\r\n    }\r\n\r\n    //Do nothing - override\r\n    protected handleCollision() {\r\n\r\n    }\r\n\r\n    //Reverse the direction of this character\r\n    protected reverse() {\r\n\r\n        this.move.x *= -1;                                                          //Reverse direction\r\n        this.animatGroups[0].forEach(x => x.setImageIndex(this.animImageIndex));    //Establish sprites for new direction\r\n        \r\n        //If gliding force-reset the sprite to match its current position\r\n        if(this.isGlide) {\r\n            this.animatGroupCurr.forEach(a => a.reset(this.gpos));\r\n        }\r\n        //Otherwise move the sprite over in its movement direction\r\n        if(!this.isGlide) {\r\n            this.gpos.x += this.move.x;\r\n        }\r\n    }\r\n\r\n    //Set current & active group based on the group index\r\n    protected setCurrentGroup(index? : number) {\r\n        \r\n        index = index ?? this.animatGroupsIndex;\r\n        this.animatGroupsIndex = index;\r\n        this.animatGroups.forEach((sg, i) => sg.forEach(s => {\r\n            s.isActive = i == index;\r\n            s.spos.setToZero();   //Reset subposition\r\n            s.reset(this.gpos); //Make sure all sprites are in the character's position after set\r\n        }));\r\n        this.animatGroupCurr.forEach(x => x.setImageIndex(this.animImageIndex));\r\n    }\r\n\r\n    //Deactivate this gameObject\r\n    public deactivate() {\r\n        this.isActive = false;\r\n        this.animatGroups.forEach(sg => sg.forEach(s => s.isActive = false));\r\n        this.underBricks.forEach(b => b.pressure -= 1);\r\n        this.underBricks = [];\r\n    }\r\n}"],
  "mappings": "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",
  "names": []
}
