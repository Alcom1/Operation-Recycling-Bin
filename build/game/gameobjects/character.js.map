{
  "version": 3,
  "sources": ["C:\\Users\\Alcom\\Desktop\\Dev\\Git\\Operation Recycling Bin\\src\\game\\gameobjects\\character.ts"],
  "sourcesContent": ["import GameObject, { GameObjectParams } from \"engine/gameobjects/gameobject\";\r\nimport { Faction, GMULTX, GMULTY } from \"engine/utilities/math\";\r\nimport Vect, { Point } from \"engine/utilities/vect\";\r\nimport BrickHandler from \"./brickhandler\";\r\nimport Brick from \"./bricknormal\";\r\nimport Anim, { OffsetImageParams, AnimationParams } from \"./anim\";\r\nimport BrickPhantom from \"./brickphantom\";\r\n\r\n/** Parameters for a character */\r\nexport interface CharacterParams extends GameObjectParams {\r\n    height? : number;\r\n    speed? : number;\r\n    animMain : AnimationParams;\r\n    isForward? : boolean;\r\n    isGlide? : boolean;\r\n    stateAnimations : number[];\r\n    animsMisc : AnimationParams[];\r\n}\r\n\r\n/** Base character */\r\nexport default class Character extends GameObject {\r\n\r\n    public get height() { return this._height; }    // Collision height of this character\r\n    protected _height: number;\r\n    public get move() { return this._move; }        // Movement direction of this character\r\n    protected _move: Vect;                          \r\n    private _speed: number;                         // Speed of this character\r\n    public get speed() { return this._speed }\r\n    protected brickHandler!: BrickHandler;          // Brick handler for brick pressure (bricks under this character)\r\n    private isGlide: boolean;                       // If the character sprite matches the character's subposition\r\n\r\n    protected animations: Anim[] = [];              // Animations, 2D array for character-states and then sub-states\r\n    protected stateAnimations: number[];            // Array of which animation each state uses. Sometimes it's not 1:1.\r\n    protected stateIndex: number = 0;               // Current state\r\n\r\n    protected bricks : Brick[] = [];                // Phantom bricks for this character's collisions\r\n\r\n    /** Getters */\r\n    protected get animationsCurr() : Anim {                               // The animations for the current state\r\n        return this.animations[this.stateAnimations[this.stateIndex]]; \r\n    }\r\n    public get isNormalMovment() : boolean { return this.stateIndex == 0 }  // If the current state is normal movment\r\n    protected get animationSubindex() : number { return this.move.x }       // Sub-index for animations (by default, based on horizontal movement)\r\n   \r\n    /** z-index get/setters */\r\n    public get zIndex() : number { return super.zIndex; }\r\n    public set zIndex(value : number) { \r\n        super.zIndex = value; \r\n        this.animations.forEach(s => s.zIndex = value);\r\n    }\r\n    public get zpos() : Vect { \r\n        return this.gpos.getAdd({ \r\n            x : -1, \r\n            y : 1 - this.height + (this.spos.y < 0 ? -1 : 0)\r\n        });\r\n    }\r\n    public get zSize() : Point {\r\n        return {\r\n            x : 2 + (this.isGlide && this.stateIndex == 0 && this.move.y == 0 && this.move.x == 1 ? 1 : 0), //Wow!\r\n            y : this.height + (this.spos.y != 0 ? 1 : 0)\r\n        }; \r\n    }\r\n\r\n    /** Constructor */\r\n    constructor(params: CharacterParams) {\r\n        super(params);\r\n\r\n        this._faction = this.faction == Faction.FRIENDLY ?              // Characters can only be friendly or hostile\r\n            Faction.FRIENDLY :\r\n            Faction.HOSTILE;\r\n        this.tags.push(\"Character\");                                    // All characters need to share a tag\r\n        \r\n        this._speed = params.speed ?? 1;                                // Default speed\r\n        this._move = new Vect(params.isForward ?? true ? 1 : -1, 0);    // Default move direction\r\n        this._height = params.height ?? 2;                              // Default height for a character\r\n        this.isGlide = params.isGlide ?? false;                         // Default glide state\r\n        this.stateAnimations = [0, ...(\r\n            params.stateAnimations ?? (                                 // Get special state animations or...\r\n            params.animsMisc ? params.animsMisc.map((x, i) => i + 1) :  // Get default animations or...\r\n            []))];                                                      // There's only one animation.\r\n\r\n        // Add segment to scene and this character\r\n        this.animations.push(new Anim({\r\n            ...params,\r\n            ...params.animMain,\r\n            speed : this.isGlide ? 6 : params.speed, \r\n            isLoop : this.isGlide,          // Loops are handled manually by non-gliders to prevent stuttering\r\n            framesSize : GMULTX * 6,        // Wide frame\r\n            gposOffset : { x : -3, y : 0 }  // Move back by 1. Animations are centered around this character\r\n        } as AnimationParams));\r\n\r\n        // Setup miscellaneous animations.\r\n        params.animsMisc?.forEach(m => {\r\n\r\n            this.animations.push(new Anim({\r\n                ...params,\r\n                speed : null,\r\n                ...m\r\n            } as AnimationParams));\r\n        });\r\n\r\n        //Add animations to scene\r\n        this.animations.forEach(a => this.parent.pushGO(a));\r\n\r\n        //Add phantom bricks for this character's collisions\r\n        for (let i = 0; i < this.height; i++) {\r\n            this.bricks.push(this.parent.pushGO(new BrickPhantom({\r\n                ...params,\r\n                faction : this.faction,\r\n                glide : this.isGlide,\r\n                width : 2,\r\n                position : this.gpos.getAdd({ x : -1, y : -i})\r\n            })) as Brick)\r\n        }\r\n    }\r\n\r\n    /** Initialize this character. Get brick handler & set the default state */\r\n    public init() {\r\n\r\n        // Get brickhandler for pressure checks\r\n        this.brickHandler = this.engine.tag.get(\"BrickHandler\", \"LevelInterface\")[0] as BrickHandler;\r\n\r\n        // Set active groups\r\n        this.setStateIndex();\r\n    }\r\n\r\n    /** Update this character */\r\n    public update(dt: number) {\r\n\r\n        // Normal movement\r\n        if (this.isNormalMovment) {\r\n\r\n            // Only gliders have gradual normal movement\r\n            if (this.isGlide) {\r\n\r\n                // Horizontal movement\r\n                if (this.move.y == 0) {\r\n                    this.spos.x += this.move.x * this._speed * GMULTX * dt;\r\n                }\r\n                // Vertical movement\r\n                else {\r\n                    this.spos.y += this.move.y * this._speed * GMULTY * dt;\r\n                }\r\n            }\r\n        }\r\n        // Movement for special states\r\n        else {\r\n\r\n            this.handleSpecialMovement(dt);\r\n        }\r\n        \r\n        // Glide characters move gradually, continously set the animation to match its subposition\r\n        if (this.isGlide) {\r\n            this.animationsCurr.spos = this.spos;\r\n        }\r\n    }\r\n\r\n    /** Special movement. Do nothing - override */\r\n    protected handleSpecialMovement(dt: number) {\r\n        \r\n    }\r\n\r\n    /** Reverse the direction of this character */\r\n    protected reverse() {\r\n\r\n        this._move.x *= -1;                                          // Reverse direction\r\n        this.animations[0].setImageIndex(this.animationSubindex);   // Establish sprites for new direction\r\n        this.animationsCurr.reset();\r\n        \r\n        // If gliding force-reset the sprite to match its current position\r\n        if (this.isGlide) {\r\n            this.animationsCurr.reset(this.gpos);\r\n        }\r\n    }\r\n\r\n    /** Move this character and its bricks by an offset*/\r\n    protected moveAll(offset : Point, isAnimReset : boolean = true) {\r\n\r\n        this.gpos.add(offset);\r\n        this.bricks.forEach((b,i) => {\r\n\r\n            b.gpos = this.gpos.getAdd({ x : -1, y : -i });\r\n        });\r\n\r\n        if(isAnimReset) {\r\n            \r\n            this.setStateIndex();\r\n        }\r\n    }\r\n\r\n    /** Set current & active group based on the group index */\r\n    protected setStateIndex(index? : number) {\r\n        \r\n        this.stateIndex = index ?? this.stateIndex;\r\n        this.animations.forEach((s, i) => {\r\n            s.isActive = i == this.stateAnimations[this.stateIndex];\r\n            s.spos.setToZero(); // Reset subposition\r\n            s.reset(this.gpos); // Make sure all sprites are in the character's position after set\r\n        });\r\n        this.animationsCurr.setImageIndex(this.animationSubindex);\r\n    }\r\n\r\n    /** */\r\n    public handleStep() {\r\n\r\n    }\r\n\r\n    /** */\r\n    public handleStepUpdate(proxs : Point[]) {\r\n\r\n    }\r\n\r\n    /** */\r\n    public getNoPlaceZone() : Point[] {\r\n        return [];\r\n    }\r\n\r\n    /** Deactivate this character */\r\n    protected deactivate() {\r\n\r\n        this.isActive = false;\r\n        this.animations.forEach(s => s.isActive = false);\r\n        this.bricks.forEach(b => b.isActive = false);\r\n    }\r\n}"],
  "mappings": "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",
  "names": []
}
